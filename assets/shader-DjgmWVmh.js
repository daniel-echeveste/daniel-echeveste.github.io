import{d as Te,n as E,V as St,H as rn,L as Y,I as G,J as ls,K as et,Q as nt,p as us,g as on,X as pn,Y as jn,Z as Pt,M as fs,_ as ps,b as ds,z as dn,$ as hn,o as at,P as hs,U as K,a0 as ys,a1 as ms,e as gs,j as gt}from"./index-nD5F6TBz.js";import{C as yn}from"./vanilla-307d3a93.esm-BBHfaU2k.js";const Yn=0,xs=1,ws=2,mn=2,Be=1.25,gn=1,Xt=6*4+4+4,Se=65535,As=Math.pow(2,-24),_e=Symbol("SKIP_GENERATION");function bs(n){return n.index?n.index.count:n.attributes.position.count}function Ft(n){return bs(n)/3}function Ts(n,t=ArrayBuffer){return n>65535?new Uint32Array(new t(4*n)):new Uint16Array(new t(2*n))}function Ss(n,t){if(!n.index){const e=n.attributes.position.count,s=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=Ts(e,s);n.setIndex(new Te(i,1));for(let o=0;o<e;o++)i[o]=o}}function Zn(n,t){const e=Ft(n),s=t||n.drawRange,i=s.start/3,o=(s.start+s.count)/3,a=Math.max(0,i),c=Math.min(e,o)-a;return[{offset:Math.floor(a),count:Math.floor(c)}]}function Kn(n,t){if(!n.groups||!n.groups.length)return Zn(n,t);const e=[],s=new Set,i=t||n.drawRange,o=i.start/3,a=(i.start+i.count)/3;for(const r of n.groups){const f=r.start/3,l=(r.start+r.count)/3;s.add(Math.max(o,f)),s.add(Math.min(a,l))}const c=Array.from(s.values()).sort((r,f)=>r-f);for(let r=0;r<c.length-1;r++){const f=c[r],l=c[r+1];e.push({offset:Math.floor(f),count:Math.floor(l-f)})}return e}function Ps(n,t){const e=Ft(n),s=Kn(n,t).sort((a,c)=>a.offset-c.offset),i=s[s.length-1];i.count=Math.min(e-i.offset,i.count);let o=0;return s.forEach(({count:a})=>o+=a),e!==o}function ve(n,t,e,s,i){let o=1/0,a=1/0,c=1/0,r=-1/0,f=-1/0,l=-1/0,p=1/0,u=1/0,d=1/0,A=-1/0,T=-1/0,g=-1/0;for(let h=t*6,y=(t+e)*6;h<y;h+=6){const m=n[h+0],x=n[h+1],w=m-x,S=m+x;w<o&&(o=w),S>r&&(r=S),m<p&&(p=m),m>A&&(A=m);const b=n[h+2],P=n[h+3],B=b-P,v=b+P;B<a&&(a=B),v>f&&(f=v),b<u&&(u=b),b>T&&(T=b);const I=n[h+4],_=n[h+5],M=I-_,C=I+_;M<c&&(c=M),C>l&&(l=C),I<d&&(d=I),I>g&&(g=I)}s[0]=o,s[1]=a,s[2]=c,s[3]=r,s[4]=f,s[5]=l,i[0]=p,i[1]=u,i[2]=d,i[3]=A,i[4]=T,i[5]=g}function Bs(n,t=null,e=null,s=null){const i=n.attributes.position,o=n.index?n.index.array:null,a=Ft(n),c=i.normalized;let r;t===null?(r=new Float32Array(a*6*4),e=0,s=a):(r=t,e=e||0,s=s||a);const f=i.array,l=i.offset||0;let p=3;i.isInterleavedBufferAttribute&&(p=i.data.stride);const u=["getX","getY","getZ"];for(let d=e;d<e+s;d++){const A=d*3,T=d*6;let g=A+0,h=A+1,y=A+2;o&&(g=o[g],h=o[h],y=o[y]),c||(g=g*p+l,h=h*p+l,y=y*p+l);for(let m=0;m<3;m++){let x,w,S;c?(x=i[u[m]](g),w=i[u[m]](h),S=i[u[m]](y)):(x=f[g+m],w=f[h+m],S=f[y+m]);let b=x;w<b&&(b=w),S<b&&(b=S);let P=x;w>P&&(P=w),S>P&&(P=S);const B=(P-b)/2,v=m*2;r[T+v+0]=b+B,r[T+v+1]=B+(Math.abs(b)+B)*As}}return r}function U(n,t,e){return e.min.x=t[n],e.min.y=t[n+1],e.min.z=t[n+2],e.max.x=t[n+3],e.max.y=t[n+4],e.max.z=t[n+5],e}function xn(n){let t=-1,e=-1/0;for(let s=0;s<3;s++){const i=n[s+3]-n[s];i>e&&(e=i,t=s)}return t}function wn(n,t){t.set(n)}function An(n,t,e){let s,i;for(let o=0;o<3;o++){const a=o+3;s=n[o],i=t[o],e[o]=s<i?s:i,s=n[a],i=t[a],e[a]=s>i?s:i}}function Yt(n,t,e){for(let s=0;s<3;s++){const i=t[n+2*s],o=t[n+2*s+1],a=i-o,c=i+o;a<e[s]&&(e[s]=a),c>e[s+3]&&(e[s+3]=c)}}function Dt(n){const t=n[3]-n[0],e=n[4]-n[1],s=n[5]-n[2];return 2*(t*e+e*s+s*t)}const ot=32,_s=(n,t)=>n.candidate-t.candidate,lt=new Array(ot).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),Zt=new Float32Array(6);function vs(n,t,e,s,i,o){let a=-1,c=0;if(o===Yn)a=xn(t),a!==-1&&(c=(t[a]+t[a+3])/2);else if(o===xs)a=xn(n),a!==-1&&(c=Ms(e,s,i,a));else if(o===ws){const r=Dt(n);let f=Be*i;const l=s*6,p=(s+i)*6;for(let u=0;u<3;u++){const d=t[u],g=(t[u+3]-d)/ot;if(i<ot/4){const h=[...lt];h.length=i;let y=0;for(let x=l;x<p;x+=6,y++){const w=h[y];w.candidate=e[x+2*u],w.count=0;const{bounds:S,leftCacheBounds:b,rightCacheBounds:P}=w;for(let B=0;B<3;B++)P[B]=1/0,P[B+3]=-1/0,b[B]=1/0,b[B+3]=-1/0,S[B]=1/0,S[B+3]=-1/0;Yt(x,e,S)}h.sort(_s);let m=i;for(let x=0;x<m;x++){const w=h[x];for(;x+1<m&&h[x+1].candidate===w.candidate;)h.splice(x+1,1),m--}for(let x=l;x<p;x+=6){const w=e[x+2*u];for(let S=0;S<m;S++){const b=h[S];w>=b.candidate?Yt(x,e,b.rightCacheBounds):(Yt(x,e,b.leftCacheBounds),b.count++)}}for(let x=0;x<m;x++){const w=h[x],S=w.count,b=i-w.count,P=w.leftCacheBounds,B=w.rightCacheBounds;let v=0;S!==0&&(v=Dt(P)/r);let I=0;b!==0&&(I=Dt(B)/r);const _=gn+Be*(v*S+I*b);_<f&&(a=u,f=_,c=w.candidate)}}else{for(let m=0;m<ot;m++){const x=lt[m];x.count=0,x.candidate=d+g+m*g;const w=x.bounds;for(let S=0;S<3;S++)w[S]=1/0,w[S+3]=-1/0}for(let m=l;m<p;m+=6){let S=~~((e[m+2*u]-d)/g);S>=ot&&(S=ot-1);const b=lt[S];b.count++,Yt(m,e,b.bounds)}const h=lt[ot-1];wn(h.bounds,h.rightCacheBounds);for(let m=ot-2;m>=0;m--){const x=lt[m],w=lt[m+1];An(x.bounds,w.rightCacheBounds,x.rightCacheBounds)}let y=0;for(let m=0;m<ot-1;m++){const x=lt[m],w=x.count,S=x.bounds,P=lt[m+1].rightCacheBounds;w!==0&&(y===0?wn(S,Zt):An(S,Zt,Zt)),y+=w;let B=0,v=0;y!==0&&(B=Dt(Zt)/r);const I=i-y;I!==0&&(v=Dt(P)/r);const _=gn+Be*(B*y+v*I);_<f&&(a=u,f=_,c=x.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${o} used.`);return{axis:a,pos:c}}function Ms(n,t,e,s){let i=0;for(let o=t,a=t+e;o<a;o++)i+=n[o*6+s*2];return i/e}class Me{constructor(){this.boundingData=new Float32Array(6)}}function Is(n,t,e,s,i,o){let a=s,c=s+i-1;const r=o.pos,f=o.axis*2;for(;;){for(;a<=c&&e[a*6+f]<r;)a++;for(;a<=c&&e[c*6+f]>=r;)c--;if(a<c){for(let l=0;l<3;l++){let p=t[a*3+l];t[a*3+l]=t[c*3+l],t[c*3+l]=p}for(let l=0;l<6;l++){let p=e[a*6+l];e[a*6+l]=e[c*6+l],e[c*6+l]=p}a++,c--}else return a}}function Es(n,t,e,s,i,o){let a=s,c=s+i-1;const r=o.pos,f=o.axis*2;for(;;){for(;a<=c&&e[a*6+f]<r;)a++;for(;a<=c&&e[c*6+f]>=r;)c--;if(a<c){let l=n[a];n[a]=n[c],n[c]=l;for(let p=0;p<6;p++){let u=e[a*6+p];e[a*6+p]=e[c*6+p],e[c*6+p]=u}a++,c--}else return a}}function $(n,t){return t[n+15]===65535}function q(n,t){return t[n+6]}function O(n,t){return t[n+14]}function X(n){return n+8}function W(n,t){return t[n+6]}function Jn(n,t){return t[n+7]}let Qn,Ot,ye,ts;const Cs=Math.pow(2,32);function Ye(n){return"count"in n?1:1+Ye(n.left)+Ye(n.right)}function zs(n,t,e){return Qn=new Float32Array(e),Ot=new Uint32Array(e),ye=new Uint16Array(e),ts=new Uint8Array(e),Ze(n,t)}function Ze(n,t){const e=n/4,s=n/2,i="count"in t,o=t.boundingData;for(let a=0;a<6;a++)Qn[e+a]=o[a];if(i)if(t.buffer){const a=t.buffer;ts.set(new Uint8Array(a),n);for(let c=n,r=n+a.byteLength;c<r;c+=Xt){const f=c/2;$(f,ye)||(Ot[c/4+6]+=e)}return n+a.byteLength}else{const a=t.offset,c=t.count;return Ot[e+6]=a,ye[s+14]=c,ye[s+15]=Se,n+Xt}else{const a=t.left,c=t.right,r=t.splitAxis;let f;if(f=Ze(n+Xt,a),f/4>Cs)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return Ot[e+6]=f/4,f=Ze(f,c),Ot[e+7]=r,f}}function Ns(n,t){const e=(n.index?n.index.count:n.attributes.position.count)/3,s=e>2**16,i=s?4:2,o=t?new SharedArrayBuffer(e*i):new ArrayBuffer(e*i),a=s?new Uint32Array(o):new Uint16Array(o);for(let c=0,r=a.length;c<r;c++)a[c]=c;return a}function Ls(n,t,e,s,i){const{maxDepth:o,verbose:a,maxLeafTris:c,strategy:r,onProgress:f,indirect:l}=i,p=n._indirectBuffer,u=n.geometry,d=u.index?u.index.array:null,A=l?Es:Is,T=Ft(u),g=new Float32Array(6);let h=!1;const y=new Me;return ve(t,e,s,y.boundingData,g),x(y,e,s,g),y;function m(w){f&&f(w/T)}function x(w,S,b,P=null,B=0){if(!h&&B>=o&&(h=!0,a&&(console.warn(`MeshBVH: Max depth of ${o} reached when generating BVH. Consider increasing maxDepth.`),console.warn(u))),b<=c||B>=o)return m(S+b),w.offset=S,w.count=b,w;const v=vs(w.boundingData,P,t,S,b,r);if(v.axis===-1)return m(S+b),w.offset=S,w.count=b,w;const I=A(p,d,t,S,b,v);if(I===S||I===S+b)m(S+b),w.offset=S,w.count=b;else{w.splitAxis=v.axis;const _=new Me,M=S,C=I-S;w.left=_,ve(t,M,C,_.boundingData,g),x(_,M,C,g,B+1);const z=new Me,N=I,D=b-C;w.right=z,ve(t,N,D,z.boundingData,g),x(z,N,D,g,B+1)}return w}}function Us(n,t){const e=n.geometry;t.indirect&&(n._indirectBuffer=Ns(e,t.useSharedArrayBuffer),Ps(e,t.range)&&!t.verbose&&console.warn('MeshBVH: Provided geometry contains groups or a range that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),n._indirectBuffer||Ss(e,t);const s=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=Bs(e),o=t.indirect?Zn(e,t.range):Kn(e,t.range);n._roots=o.map(a=>{const c=Ls(n,i,a.offset,a.count,t),r=Ye(c),f=new s(Xt*r);return zs(0,c,f),f})}class ct{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let s=1/0,i=-1/0;for(let o=0,a=t.length;o<a;o++){const r=t[o][e];s=r<s?r:s,i=r>i?r:i}this.min=s,this.max=i}setFromPoints(t,e){let s=1/0,i=-1/0;for(let o=0,a=e.length;o<a;o++){const c=e[o],r=t.dot(c);s=r<s?r:s,i=r>i?r:i}this.min=s,this.max=i}isSeparated(t){return this.min>t.max||t.min>this.max}}ct.prototype.setFromBox=function(){const n=new E;return function(e,s){const i=s.min,o=s.max;let a=1/0,c=-1/0;for(let r=0;r<=1;r++)for(let f=0;f<=1;f++)for(let l=0;l<=1;l++){n.x=i.x*r+o.x*(1-r),n.y=i.y*f+o.y*(1-f),n.z=i.z*l+o.z*(1-l);const p=e.dot(n);a=Math.min(p,a),c=Math.max(p,c)}this.min=a,this.max=c}}();const Rs=function(){const n=new E,t=new E,e=new E;return function(i,o,a){const c=i.start,r=n,f=o.start,l=t;e.subVectors(c,f),n.subVectors(i.end,i.start),t.subVectors(o.end,o.start);const p=e.dot(l),u=l.dot(r),d=l.dot(l),A=e.dot(r),g=r.dot(r)*d-u*u;let h,y;g!==0?h=(p*u-A*d)/g:h=0,y=(p+h*u)/d,a.x=h,a.y=y}}(),cn=function(){const n=new St,t=new E,e=new E;return function(i,o,a,c){Rs(i,o,n);let r=n.x,f=n.y;if(r>=0&&r<=1&&f>=0&&f<=1){i.at(r,a),o.at(f,c);return}else if(r>=0&&r<=1){f<0?o.at(0,c):o.at(1,c),i.closestPointToPoint(c,!0,a);return}else if(f>=0&&f<=1){r<0?i.at(0,a):i.at(1,a),o.closestPointToPoint(a,!0,c);return}else{let l;r<0?l=i.start:l=i.end;let p;f<0?p=o.start:p=o.end;const u=t,d=e;if(i.closestPointToPoint(p,!0,t),o.closestPointToPoint(l,!0,e),u.distanceToSquared(p)<=d.distanceToSquared(l)){a.copy(u),c.copy(p);return}else{a.copy(l),c.copy(d);return}}}}(),Fs=function(){const n=new E,t=new E,e=new rn,s=new Y;return function(o,a){const{radius:c,center:r}=o,{a:f,b:l,c:p}=a;if(s.start=f,s.end=l,s.closestPointToPoint(r,!0,n).distanceTo(r)<=c||(s.start=f,s.end=p,s.closestPointToPoint(r,!0,n).distanceTo(r)<=c)||(s.start=l,s.end=p,s.closestPointToPoint(r,!0,n).distanceTo(r)<=c))return!0;const T=a.getPlane(e);if(Math.abs(T.distanceToPoint(r))<=c){const h=T.projectPoint(r,t);if(a.containsPoint(h))return!0}return!1}}(),Ds=1e-15;function Ie(n){return Math.abs(n)<Ds}class Z extends G{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new E),this.satBounds=new Array(4).fill().map(()=>new ct),this.points=[this.a,this.b,this.c],this.sphere=new ls,this.plane=new rn,this.needsUpdate=!0}intersectsSphere(t){return Fs(t,this)}update(){const t=this.a,e=this.b,s=this.c,i=this.points,o=this.satAxes,a=this.satBounds,c=o[0],r=a[0];this.getNormal(c),r.setFromPoints(c,i);const f=o[1],l=a[1];f.subVectors(t,e),l.setFromPoints(f,i);const p=o[2],u=a[2];p.subVectors(e,s),u.setFromPoints(p,i);const d=o[3],A=a[3];d.subVectors(s,t),A.setFromPoints(d,i),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(c,t),this.needsUpdate=!1}}Z.prototype.closestPointToSegment=function(){const n=new E,t=new E,e=new Y;return function(i,o=null,a=null){const{start:c,end:r}=i,f=this.points;let l,p=1/0;for(let u=0;u<3;u++){const d=(u+1)%3;e.start.copy(f[u]),e.end.copy(f[d]),cn(e,i,n,t),l=n.distanceToSquared(t),l<p&&(p=l,o&&o.copy(n),a&&a.copy(t))}return this.closestPointToPoint(c,n),l=c.distanceToSquared(n),l<p&&(p=l,o&&o.copy(n),a&&a.copy(c)),this.closestPointToPoint(r,n),l=r.distanceToSquared(n),l<p&&(p=l,o&&o.copy(n),a&&a.copy(r)),Math.sqrt(p)}}();Z.prototype.intersectsTriangle=function(){const n=new Z,t=new Array(3),e=new Array(3),s=new ct,i=new ct,o=new E,a=new E,c=new E,r=new E,f=new E,l=new Y,p=new Y,u=new Y,d=new E;function A(T,g,h){const y=T.points;let m=0,x=-1;for(let w=0;w<3;w++){const{start:S,end:b}=l;S.copy(y[w]),b.copy(y[(w+1)%3]),l.delta(a);const P=Ie(g.distanceToPoint(S));if(Ie(g.normal.dot(a))&&P){h.copy(l),m=2;break}const B=g.intersectLine(l,d);if(!B&&P&&d.copy(S),(B||P)&&!Ie(d.distanceTo(b))){if(m<=1)(m===1?h.start:h.end).copy(d),P&&(x=m);else if(m>=2){(x===1?h.start:h.end).copy(d),m=2;break}if(m++,m===2&&x===-1)break}}return m}return function(g,h=null,y=!1){this.needsUpdate&&this.update(),g.isExtendedTriangle?g.needsUpdate&&g.update():(n.copy(g),n.update(),g=n);const m=this.plane,x=g.plane;if(Math.abs(m.normal.dot(x.normal))>1-1e-10){const w=this.satBounds,S=this.satAxes;e[0]=g.a,e[1]=g.b,e[2]=g.c;for(let B=0;B<4;B++){const v=w[B],I=S[B];if(s.setFromPoints(I,e),v.isSeparated(s))return!1}const b=g.satBounds,P=g.satAxes;t[0]=this.a,t[1]=this.b,t[2]=this.c;for(let B=0;B<4;B++){const v=b[B],I=P[B];if(s.setFromPoints(I,t),v.isSeparated(s))return!1}for(let B=0;B<4;B++){const v=S[B];for(let I=0;I<4;I++){const _=P[I];if(o.crossVectors(v,_),s.setFromPoints(o,t),i.setFromPoints(o,e),s.isSeparated(i))return!1}}return h&&(y||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),h.start.set(0,0,0),h.end.set(0,0,0)),!0}else{const w=A(this,x,p);if(w===1&&g.containsPoint(p.end))return h&&(h.start.copy(p.end),h.end.copy(p.end)),!0;if(w!==2)return!1;const S=A(g,m,u);if(S===1&&this.containsPoint(u.end))return h&&(h.start.copy(u.end),h.end.copy(u.end)),!0;if(S!==2)return!1;if(p.delta(c),u.delta(r),c.dot(r)<0){let M=u.start;u.start=u.end,u.end=M}const b=p.start.dot(c),P=p.end.dot(c),B=u.start.dot(c),v=u.end.dot(c),I=P<B,_=b<v;return b!==v&&B!==P&&I===_?!1:(h&&(f.subVectors(p.start,u.start),f.dot(c)>0?h.start.copy(p.start):h.start.copy(u.start),f.subVectors(p.end,u.end),f.dot(c)<0?h.end.copy(p.end):h.end.copy(u.end)),!0)}}}();Z.prototype.distanceToPoint=function(){const n=new E;return function(e){return this.closestPointToPoint(e,n),e.distanceTo(n)}}();Z.prototype.distanceToTriangle=function(){const n=new E,t=new E,e=["a","b","c"],s=new Y,i=new Y;return function(a,c=null,r=null){const f=c||r?s:null;if(this.intersectsTriangle(a,f))return(c||r)&&(c&&f.getCenter(c),r&&f.getCenter(r)),0;let l=1/0;for(let p=0;p<3;p++){let u;const d=e[p],A=a[d];this.closestPointToPoint(A,n),u=A.distanceToSquared(n),u<l&&(l=u,c&&c.copy(n),r&&r.copy(A));const T=this[d];a.closestPointToPoint(T,n),u=T.distanceToSquared(n),u<l&&(l=u,c&&c.copy(T),r&&r.copy(n))}for(let p=0;p<3;p++){const u=e[p],d=e[(p+1)%3];s.set(this[u],this[d]);for(let A=0;A<3;A++){const T=e[A],g=e[(A+1)%3];i.set(a[T],a[g]),cn(s,i,n,t);const h=n.distanceToSquared(t);h<l&&(l=h,c&&c.copy(n),r&&r.copy(t))}}return Math.sqrt(l)}}();class k{constructor(t,e,s){this.isOrientedBox=!0,this.min=new E,this.max=new E,this.matrix=new et,this.invMatrix=new et,this.points=new Array(8).fill().map(()=>new E),this.satAxes=new Array(3).fill().map(()=>new E),this.satBounds=new Array(3).fill().map(()=>new ct),this.alignedSatBounds=new Array(3).fill().map(()=>new ct),this.needsUpdate=!1,t&&this.min.copy(t),e&&this.max.copy(e),s&&this.matrix.copy(s)}set(t,e,s){this.min.copy(t),this.max.copy(e),this.matrix.copy(s),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}k.prototype.update=function(){return function(){const t=this.matrix,e=this.min,s=this.max,i=this.points;for(let f=0;f<=1;f++)for(let l=0;l<=1;l++)for(let p=0;p<=1;p++){const u=1*f|2*l|4*p,d=i[u];d.x=f?s.x:e.x,d.y=l?s.y:e.y,d.z=p?s.z:e.z,d.applyMatrix4(t)}const o=this.satBounds,a=this.satAxes,c=i[0];for(let f=0;f<3;f++){const l=a[f],p=o[f],u=1<<f,d=i[u];l.subVectors(c,d),p.setFromPoints(l,i)}const r=this.alignedSatBounds;r[0].setFromPointsField(i,"x"),r[1].setFromPointsField(i,"y"),r[2].setFromPointsField(i,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();k.prototype.intersectsBox=function(){const n=new ct;return function(e){this.needsUpdate&&this.update();const s=e.min,i=e.max,o=this.satBounds,a=this.satAxes,c=this.alignedSatBounds;if(n.min=s.x,n.max=i.x,c[0].isSeparated(n)||(n.min=s.y,n.max=i.y,c[1].isSeparated(n))||(n.min=s.z,n.max=i.z,c[2].isSeparated(n)))return!1;for(let r=0;r<3;r++){const f=a[r],l=o[r];if(n.setFromBox(f,e),l.isSeparated(n))return!1}return!0}}();k.prototype.intersectsTriangle=function(){const n=new Z,t=new Array(3),e=new ct,s=new ct,i=new E;return function(a){this.needsUpdate&&this.update(),a.isExtendedTriangle?a.needsUpdate&&a.update():(n.copy(a),n.update(),a=n);const c=this.satBounds,r=this.satAxes;t[0]=a.a,t[1]=a.b,t[2]=a.c;for(let u=0;u<3;u++){const d=c[u],A=r[u];if(e.setFromPoints(A,t),d.isSeparated(e))return!1}const f=a.satBounds,l=a.satAxes,p=this.points;for(let u=0;u<3;u++){const d=f[u],A=l[u];if(e.setFromPoints(A,p),d.isSeparated(e))return!1}for(let u=0;u<3;u++){const d=r[u];for(let A=0;A<4;A++){const T=l[A];if(i.crossVectors(d,T),e.setFromPoints(i,t),s.setFromPoints(i,p),e.isSeparated(s))return!1}}return!0}}();k.prototype.closestPointToPoint=function(){return function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e}}();k.prototype.distanceToPoint=function(){const n=new E;return function(e){return this.closestPointToPoint(e,n),e.distanceTo(n)}}();k.prototype.distanceToBox=function(){const n=["x","y","z"],t=new Array(12).fill().map(()=>new Y),e=new Array(12).fill().map(()=>new Y),s=new E,i=new E;return function(a,c=0,r=null,f=null){if(this.needsUpdate&&this.update(),this.intersectsBox(a))return(r||f)&&(a.getCenter(i),this.closestPointToPoint(i,s),a.closestPointToPoint(s,i),r&&r.copy(s),f&&f.copy(i)),0;const l=c*c,p=a.min,u=a.max,d=this.points;let A=1/0;for(let g=0;g<8;g++){const h=d[g];i.copy(h).clamp(p,u);const y=h.distanceToSquared(i);if(y<A&&(A=y,r&&r.copy(h),f&&f.copy(i),y<l))return Math.sqrt(y)}let T=0;for(let g=0;g<3;g++)for(let h=0;h<=1;h++)for(let y=0;y<=1;y++){const m=(g+1)%3,x=(g+2)%3,w=h<<m|y<<x,S=1<<g|h<<m|y<<x,b=d[w],P=d[S];t[T].set(b,P);const v=n[g],I=n[m],_=n[x],M=e[T],C=M.start,z=M.end;C[v]=p[v],C[I]=h?p[I]:u[I],C[_]=y?p[_]:u[I],z[v]=u[v],z[I]=h?p[I]:u[I],z[_]=y?p[_]:u[I],T++}for(let g=0;g<=1;g++)for(let h=0;h<=1;h++)for(let y=0;y<=1;y++){i.x=g?u.x:p.x,i.y=h?u.y:p.y,i.z=y?u.z:p.z,this.closestPointToPoint(i,s);const m=i.distanceToSquared(s);if(m<A&&(A=m,r&&r.copy(s),f&&f.copy(i),m<l))return Math.sqrt(m)}for(let g=0;g<12;g++){const h=t[g];for(let y=0;y<12;y++){const m=e[y];cn(h,m,s,i);const x=s.distanceToSquared(i);if(x<A&&(A=x,r&&r.copy(s),f&&f.copy(i),x<l))return Math.sqrt(x)}}return Math.sqrt(A)}}();class an{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class Vs extends an{constructor(){super(()=>new Z)}}const j=new Vs;class ks{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let e=null;this.setBuffer=s=>{e&&t.push(e),e=s,this.float32Array=new Float32Array(s),this.uint16Array=new Uint16Array(s),this.uint32Array=new Uint32Array(s)},this.clearBuffer=()=>{e=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,t.length!==0&&this.setBuffer(t.pop())}}}const L=new ks;let dt,Rt;const _t=[],Kt=new an(()=>new nt);function $s(n,t,e,s,i,o){dt=Kt.getPrimitive(),Rt=Kt.getPrimitive(),_t.push(dt,Rt),L.setBuffer(n._roots[t]);const a=Ke(0,n.geometry,e,s,i,o);L.clearBuffer(),Kt.releasePrimitive(dt),Kt.releasePrimitive(Rt),_t.pop(),_t.pop();const c=_t.length;return c>0&&(Rt=_t[c-1],dt=_t[c-2]),a}function Ke(n,t,e,s,i=null,o=0,a=0){const{float32Array:c,uint16Array:r,uint32Array:f}=L;let l=n*2;if($(l,r)){const u=q(n,f),d=O(l,r);return U(n,c,dt),s(u,d,!1,a,o+n,dt)}else{let u=function(_){const{uint16Array:M,uint32Array:C}=L;let z=_*2;for(;!$(z,M);)_=X(_),z=_*2;return q(_,C)},d=function(_){const{uint16Array:M,uint32Array:C}=L;let z=_*2;for(;!$(z,M);)_=W(_,C),z=_*2;return q(_,C)+O(z,M)};const A=X(n),T=W(n,f);let g=A,h=T,y,m,x,w;if(i&&(x=dt,w=Rt,U(g,c,x),U(h,c,w),y=i(x),m=i(w),m<y)){g=T,h=A;const _=y;y=m,m=_,x=w}x||(x=dt,U(g,c,x));const S=$(g*2,r),b=e(x,S,y,a+1,o+g);let P;if(b===mn){const _=u(g),C=d(g)-_;P=s(_,C,!0,a+1,o+g,x)}else P=b&&Ke(g,t,e,s,i,o,a+1);if(P)return!0;w=Rt,U(h,c,w);const B=$(h*2,r),v=e(w,B,m,a+1,o+h);let I;if(v===mn){const _=u(h),C=d(h)-_;I=s(_,C,!0,a+1,o+h,w)}else I=v&&Ke(h,t,e,s,i,o,a+1);return!!I}}const Vt=new E,Ee=new E;function Gs(n,t,e={},s=0,i=1/0){const o=s*s,a=i*i;let c=1/0,r=null;if(n.shapecast({boundsTraverseOrder:l=>(Vt.copy(t).clamp(l.min,l.max),Vt.distanceToSquared(t)),intersectsBounds:(l,p,u)=>u<c&&u<a,intersectsTriangle:(l,p)=>{l.closestPointToPoint(t,Vt);const u=t.distanceToSquared(Vt);return u<c&&(Ee.copy(Vt),c=u,r=p),u<o}}),c===1/0)return null;const f=Math.sqrt(c);return e.point?e.point.copy(Ee):e.point=Ee.clone(),e.distance=f,e.faceIndex=r,e}const vt=new E,Mt=new E,It=new E,Jt=new St,Qt=new St,te=new St,bn=new E,Tn=new E,Sn=new E,ee=new E;function qs(n,t,e,s,i,o,a,c){let r;if(o===us?r=n.intersectTriangle(s,e,t,!0,i):r=n.intersectTriangle(t,e,s,o!==on,i),r===null)return null;const f=n.origin.distanceTo(i);return f<a||f>c?null:{distance:f,point:i.clone()}}function Hs(n,t,e,s,i,o,a,c,r,f,l){vt.fromBufferAttribute(t,o),Mt.fromBufferAttribute(t,a),It.fromBufferAttribute(t,c);const p=qs(n,vt,Mt,It,ee,r,f,l);if(p){s&&(Jt.fromBufferAttribute(s,o),Qt.fromBufferAttribute(s,a),te.fromBufferAttribute(s,c),p.uv=G.getInterpolation(ee,vt,Mt,It,Jt,Qt,te,new St)),i&&(Jt.fromBufferAttribute(i,o),Qt.fromBufferAttribute(i,a),te.fromBufferAttribute(i,c),p.uv1=G.getInterpolation(ee,vt,Mt,It,Jt,Qt,te,new St)),e&&(bn.fromBufferAttribute(e,o),Tn.fromBufferAttribute(e,a),Sn.fromBufferAttribute(e,c),p.normal=G.getInterpolation(ee,vt,Mt,It,bn,Tn,Sn,new E),p.normal.dot(n.direction)>0&&p.normal.multiplyScalar(-1));const u={a:o,b:a,c,normal:new E,materialIndex:0};G.getNormal(vt,Mt,It,u.normal),p.face=u,p.faceIndex=o}return p}function Pe(n,t,e,s,i,o,a){const c=s*3;let r=c+0,f=c+1,l=c+2;const p=n.index;n.index&&(r=p.getX(r),f=p.getX(f),l=p.getX(l));const{position:u,normal:d,uv:A,uv1:T}=n.attributes,g=Hs(e,u,d,A,T,r,f,l,t,o,a);return g?(g.faceIndex=s,i&&i.push(g),g):null}function F(n,t,e,s){const i=n.a,o=n.b,a=n.c;let c=t,r=t+1,f=t+2;e&&(c=e.getX(c),r=e.getX(r),f=e.getX(f)),i.x=s.getX(c),i.y=s.getY(c),i.z=s.getZ(c),o.x=s.getX(r),o.y=s.getY(r),o.z=s.getZ(r),a.x=s.getX(f),a.y=s.getY(f),a.z=s.getZ(f)}function Os(n,t,e,s,i,o,a,c){const{geometry:r,_indirectBuffer:f}=n;for(let l=s,p=s+i;l<p;l++)Pe(r,t,e,l,o,a,c)}function Xs(n,t,e,s,i,o,a){const{geometry:c,_indirectBuffer:r}=n;let f=1/0,l=null;for(let p=s,u=s+i;p<u;p++){let d;d=Pe(c,t,e,p,null,o,a),d&&d.distance<f&&(l=d,f=d.distance)}return l}function Ws(n,t,e,s,i,o,a){const{geometry:c}=e,{index:r}=c,f=c.attributes.position;for(let l=n,p=t+n;l<p;l++){let u;if(u=l,F(a,u*3,r,f),a.needsUpdate=!0,s(a,u,i,o))return!0}return!1}function js(n,t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=n.geometry,s=e.index?e.index.array:null,i=e.attributes.position;let o,a,c,r,f=0;const l=n._roots;for(let u=0,d=l.length;u<d;u++)o=l[u],a=new Uint32Array(o),c=new Uint16Array(o),r=new Float32Array(o),p(0,f),f+=o.byteLength;function p(u,d,A=!1){const T=u*2;if(c[T+15]===Se){const h=a[u+6],y=c[T+14];let m=1/0,x=1/0,w=1/0,S=-1/0,b=-1/0,P=-1/0;for(let B=3*h,v=3*(h+y);B<v;B++){let I=s[B];const _=i.getX(I),M=i.getY(I),C=i.getZ(I);_<m&&(m=_),_>S&&(S=_),M<x&&(x=M),M>b&&(b=M),C<w&&(w=C),C>P&&(P=C)}return r[u+0]!==m||r[u+1]!==x||r[u+2]!==w||r[u+3]!==S||r[u+4]!==b||r[u+5]!==P?(r[u+0]=m,r[u+1]=x,r[u+2]=w,r[u+3]=S,r[u+4]=b,r[u+5]=P,!0):!1}else{const h=u+8,y=a[u+6],m=h+d,x=y+d;let w=A,S=!1,b=!1;t?w||(S=t.has(m),b=t.has(x),w=!S&&!b):(S=!0,b=!0);const P=w||S,B=w||b;let v=!1;P&&(v=p(h,d,w));let I=!1;B&&(I=p(y,d,w));const _=v||I;if(_)for(let M=0;M<3;M++){const C=h+M,z=y+M,N=r[C],D=r[C+3],Bt=r[z],mt=r[z+3];r[u+M]=N<Bt?N:Bt,r[u+M+3]=D>mt?D:mt}return _}}}function yt(n,t,e,s,i){let o,a,c,r,f,l;const p=1/e.direction.x,u=1/e.direction.y,d=1/e.direction.z,A=e.origin.x,T=e.origin.y,g=e.origin.z;let h=t[n],y=t[n+3],m=t[n+1],x=t[n+3+1],w=t[n+2],S=t[n+3+2];return p>=0?(o=(h-A)*p,a=(y-A)*p):(o=(y-A)*p,a=(h-A)*p),u>=0?(c=(m-T)*u,r=(x-T)*u):(c=(x-T)*u,r=(m-T)*u),o>r||c>a||((c>o||isNaN(o))&&(o=c),(r<a||isNaN(a))&&(a=r),d>=0?(f=(w-g)*d,l=(S-g)*d):(f=(S-g)*d,l=(w-g)*d),o>l||f>a)?!1:((f>o||o!==o)&&(o=f),(l<a||a!==a)&&(a=l),o<=i&&a>=s)}function Ys(n,t,e,s,i,o,a,c){const{geometry:r,_indirectBuffer:f}=n;for(let l=s,p=s+i;l<p;l++){let u=f?f[l]:l;Pe(r,t,e,u,o,a,c)}}function Zs(n,t,e,s,i,o,a){const{geometry:c,_indirectBuffer:r}=n;let f=1/0,l=null;for(let p=s,u=s+i;p<u;p++){let d;d=Pe(c,t,e,r?r[p]:p,null,o,a),d&&d.distance<f&&(l=d,f=d.distance)}return l}function Ks(n,t,e,s,i,o,a){const{geometry:c}=e,{index:r}=c,f=c.attributes.position;for(let l=n,p=t+n;l<p;l++){let u;if(u=e.resolveTriangleIndex(l),F(a,u*3,r,f),a.needsUpdate=!0,s(a,u,i,o))return!0}return!1}function Js(n,t,e,s,i,o,a){L.setBuffer(n._roots[t]),Je(0,n,e,s,i,o,a),L.clearBuffer()}function Je(n,t,e,s,i,o,a){const{float32Array:c,uint16Array:r,uint32Array:f}=L,l=n*2;if($(l,r)){const u=q(n,f),d=O(l,r);Os(t,e,s,u,d,i,o,a)}else{const u=X(n);yt(u,c,s,o,a)&&Je(u,t,e,s,i,o,a);const d=W(n,f);yt(d,c,s,o,a)&&Je(d,t,e,s,i,o,a)}}const Qs=["x","y","z"];function ti(n,t,e,s,i,o){L.setBuffer(n._roots[t]);const a=Qe(0,n,e,s,i,o);return L.clearBuffer(),a}function Qe(n,t,e,s,i,o){const{float32Array:a,uint16Array:c,uint32Array:r}=L;let f=n*2;if($(f,c)){const p=q(n,r),u=O(f,c);return Xs(t,e,s,p,u,i,o)}else{const p=Jn(n,r),u=Qs[p],A=s.direction[u]>=0;let T,g;A?(T=X(n),g=W(n,r)):(T=W(n,r),g=X(n));const y=yt(T,a,s,i,o)?Qe(T,t,e,s,i,o):null;if(y){const w=y.point[u];if(A?w<=a[g+p]:w>=a[g+p+3])return y}const x=yt(g,a,s,i,o)?Qe(g,t,e,s,i,o):null;return y&&x?y.distance<=x.distance?y:x:y||x||null}}const ne=new nt,Et=new Z,Ct=new Z,kt=new et,Pn=new k,se=new k;function ei(n,t,e,s){L.setBuffer(n._roots[t]);const i=tn(0,n,e,s);return L.clearBuffer(),i}function tn(n,t,e,s,i=null){const{float32Array:o,uint16Array:a,uint32Array:c}=L;let r=n*2;if(i===null&&(e.boundingBox||e.computeBoundingBox(),Pn.set(e.boundingBox.min,e.boundingBox.max,s),i=Pn),$(r,a)){const l=t.geometry,p=l.index,u=l.attributes.position,d=e.index,A=e.attributes.position,T=q(n,c),g=O(r,a);if(kt.copy(s).invert(),e.boundsTree)return U(n,o,se),se.matrix.copy(kt),se.needsUpdate=!0,e.boundsTree.shapecast({intersectsBounds:y=>se.intersectsBox(y),intersectsTriangle:y=>{y.a.applyMatrix4(s),y.b.applyMatrix4(s),y.c.applyMatrix4(s),y.needsUpdate=!0;for(let m=T*3,x=(g+T)*3;m<x;m+=3)if(F(Ct,m,p,u),Ct.needsUpdate=!0,y.intersectsTriangle(Ct))return!0;return!1}});for(let h=T*3,y=(g+T)*3;h<y;h+=3){F(Et,h,p,u),Et.a.applyMatrix4(kt),Et.b.applyMatrix4(kt),Et.c.applyMatrix4(kt),Et.needsUpdate=!0;for(let m=0,x=d.count;m<x;m+=3)if(F(Ct,m,d,A),Ct.needsUpdate=!0,Et.intersectsTriangle(Ct))return!0}}else{const l=n+8,p=c[n+6];return U(l,o,ne),!!(i.intersectsBox(ne)&&tn(l,t,e,s,i)||(U(p,o,ne),i.intersectsBox(ne)&&tn(p,t,e,s,i)))}}const ie=new et,Ce=new k,$t=new k,ni=new E,si=new E,ii=new E,ri=new E;function oi(n,t,e,s={},i={},o=0,a=1/0){t.boundingBox||t.computeBoundingBox(),Ce.set(t.boundingBox.min,t.boundingBox.max,e),Ce.needsUpdate=!0;const c=n.geometry,r=c.attributes.position,f=c.index,l=t.attributes.position,p=t.index,u=j.getPrimitive(),d=j.getPrimitive();let A=ni,T=si,g=null,h=null;i&&(g=ii,h=ri);let y=1/0,m=null,x=null;return ie.copy(e).invert(),$t.matrix.copy(ie),n.shapecast({boundsTraverseOrder:w=>Ce.distanceToBox(w),intersectsBounds:(w,S,b)=>b<y&&b<a?(S&&($t.min.copy(w.min),$t.max.copy(w.max),$t.needsUpdate=!0),!0):!1,intersectsRange:(w,S)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:P=>$t.distanceToBox(P),intersectsBounds:(P,B,v)=>v<y&&v<a,intersectsRange:(P,B)=>{for(let v=P,I=P+B;v<I;v++){F(d,3*v,p,l),d.a.applyMatrix4(e),d.b.applyMatrix4(e),d.c.applyMatrix4(e),d.needsUpdate=!0;for(let _=w,M=w+S;_<M;_++){F(u,3*_,f,r),u.needsUpdate=!0;const C=u.distanceToTriangle(d,A,g);if(C<y&&(T.copy(A),h&&h.copy(g),y=C,m=_,x=v),C<o)return!0}}}});{const b=Ft(t);for(let P=0,B=b;P<B;P++){F(d,3*P,p,l),d.a.applyMatrix4(e),d.b.applyMatrix4(e),d.c.applyMatrix4(e),d.needsUpdate=!0;for(let v=w,I=w+S;v<I;v++){F(u,3*v,f,r),u.needsUpdate=!0;const _=u.distanceToTriangle(d,A,g);if(_<y&&(T.copy(A),h&&h.copy(g),y=_,m=v,x=P),_<o)return!0}}}}}),j.releasePrimitive(u),j.releasePrimitive(d),y===1/0?null:(s.point?s.point.copy(T):s.point=T.clone(),s.distance=y,s.faceIndex=m,i&&(i.point?i.point.copy(h):i.point=h.clone(),i.point.applyMatrix4(ie),T.applyMatrix4(ie),i.distance=T.sub(i.point).length(),i.faceIndex=x),s)}function ci(n,t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=n.geometry,s=e.index?e.index.array:null,i=e.attributes.position;let o,a,c,r,f=0;const l=n._roots;for(let u=0,d=l.length;u<d;u++)o=l[u],a=new Uint32Array(o),c=new Uint16Array(o),r=new Float32Array(o),p(0,f),f+=o.byteLength;function p(u,d,A=!1){const T=u*2;if(c[T+15]===Se){const h=a[u+6],y=c[T+14];let m=1/0,x=1/0,w=1/0,S=-1/0,b=-1/0,P=-1/0;for(let B=h,v=h+y;B<v;B++){const I=3*n.resolveTriangleIndex(B);for(let _=0;_<3;_++){let M=I+_;M=s?s[M]:M;const C=i.getX(M),z=i.getY(M),N=i.getZ(M);C<m&&(m=C),C>S&&(S=C),z<x&&(x=z),z>b&&(b=z),N<w&&(w=N),N>P&&(P=N)}}return r[u+0]!==m||r[u+1]!==x||r[u+2]!==w||r[u+3]!==S||r[u+4]!==b||r[u+5]!==P?(r[u+0]=m,r[u+1]=x,r[u+2]=w,r[u+3]=S,r[u+4]=b,r[u+5]=P,!0):!1}else{const h=u+8,y=a[u+6],m=h+d,x=y+d;let w=A,S=!1,b=!1;t?w||(S=t.has(m),b=t.has(x),w=!S&&!b):(S=!0,b=!0);const P=w||S,B=w||b;let v=!1;P&&(v=p(h,d,w));let I=!1;B&&(I=p(y,d,w));const _=v||I;if(_)for(let M=0;M<3;M++){const C=h+M,z=y+M,N=r[C],D=r[C+3],Bt=r[z],mt=r[z+3];r[u+M]=N<Bt?N:Bt,r[u+M+3]=D>mt?D:mt}return _}}}function ai(n,t,e,s,i,o,a){L.setBuffer(n._roots[t]),en(0,n,e,s,i,o,a),L.clearBuffer()}function en(n,t,e,s,i,o,a){const{float32Array:c,uint16Array:r,uint32Array:f}=L,l=n*2;if($(l,r)){const u=q(n,f),d=O(l,r);Ys(t,e,s,u,d,i,o,a)}else{const u=X(n);yt(u,c,s,o,a)&&en(u,t,e,s,i,o,a);const d=W(n,f);yt(d,c,s,o,a)&&en(d,t,e,s,i,o,a)}}const li=["x","y","z"];function ui(n,t,e,s,i,o){L.setBuffer(n._roots[t]);const a=nn(0,n,e,s,i,o);return L.clearBuffer(),a}function nn(n,t,e,s,i,o){const{float32Array:a,uint16Array:c,uint32Array:r}=L;let f=n*2;if($(f,c)){const p=q(n,r),u=O(f,c);return Zs(t,e,s,p,u,i,o)}else{const p=Jn(n,r),u=li[p],A=s.direction[u]>=0;let T,g;A?(T=X(n),g=W(n,r)):(T=W(n,r),g=X(n));const y=yt(T,a,s,i,o)?nn(T,t,e,s,i,o):null;if(y){const w=y.point[u];if(A?w<=a[g+p]:w>=a[g+p+3])return y}const x=yt(g,a,s,i,o)?nn(g,t,e,s,i,o):null;return y&&x?y.distance<=x.distance?y:x:y||x||null}}const re=new nt,zt=new Z,Nt=new Z,Gt=new et,Bn=new k,oe=new k;function fi(n,t,e,s){L.setBuffer(n._roots[t]);const i=sn(0,n,e,s);return L.clearBuffer(),i}function sn(n,t,e,s,i=null){const{float32Array:o,uint16Array:a,uint32Array:c}=L;let r=n*2;if(i===null&&(e.boundingBox||e.computeBoundingBox(),Bn.set(e.boundingBox.min,e.boundingBox.max,s),i=Bn),$(r,a)){const l=t.geometry,p=l.index,u=l.attributes.position,d=e.index,A=e.attributes.position,T=q(n,c),g=O(r,a);if(Gt.copy(s).invert(),e.boundsTree)return U(n,o,oe),oe.matrix.copy(Gt),oe.needsUpdate=!0,e.boundsTree.shapecast({intersectsBounds:y=>oe.intersectsBox(y),intersectsTriangle:y=>{y.a.applyMatrix4(s),y.b.applyMatrix4(s),y.c.applyMatrix4(s),y.needsUpdate=!0;for(let m=T,x=g+T;m<x;m++)if(F(Nt,3*t.resolveTriangleIndex(m),p,u),Nt.needsUpdate=!0,y.intersectsTriangle(Nt))return!0;return!1}});for(let h=T,y=g+T;h<y;h++){const m=t.resolveTriangleIndex(h);F(zt,3*m,p,u),zt.a.applyMatrix4(Gt),zt.b.applyMatrix4(Gt),zt.c.applyMatrix4(Gt),zt.needsUpdate=!0;for(let x=0,w=d.count;x<w;x+=3)if(F(Nt,x,d,A),Nt.needsUpdate=!0,zt.intersectsTriangle(Nt))return!0}}else{const l=n+8,p=c[n+6];return U(l,o,re),!!(i.intersectsBox(re)&&sn(l,t,e,s,i)||(U(p,o,re),i.intersectsBox(re)&&sn(p,t,e,s,i)))}}const ce=new et,ze=new k,qt=new k,pi=new E,di=new E,hi=new E,yi=new E;function mi(n,t,e,s={},i={},o=0,a=1/0){t.boundingBox||t.computeBoundingBox(),ze.set(t.boundingBox.min,t.boundingBox.max,e),ze.needsUpdate=!0;const c=n.geometry,r=c.attributes.position,f=c.index,l=t.attributes.position,p=t.index,u=j.getPrimitive(),d=j.getPrimitive();let A=pi,T=di,g=null,h=null;i&&(g=hi,h=yi);let y=1/0,m=null,x=null;return ce.copy(e).invert(),qt.matrix.copy(ce),n.shapecast({boundsTraverseOrder:w=>ze.distanceToBox(w),intersectsBounds:(w,S,b)=>b<y&&b<a?(S&&(qt.min.copy(w.min),qt.max.copy(w.max),qt.needsUpdate=!0),!0):!1,intersectsRange:(w,S)=>{if(t.boundsTree){const b=t.boundsTree;return b.shapecast({boundsTraverseOrder:P=>qt.distanceToBox(P),intersectsBounds:(P,B,v)=>v<y&&v<a,intersectsRange:(P,B)=>{for(let v=P,I=P+B;v<I;v++){const _=b.resolveTriangleIndex(v);F(d,3*_,p,l),d.a.applyMatrix4(e),d.b.applyMatrix4(e),d.c.applyMatrix4(e),d.needsUpdate=!0;for(let M=w,C=w+S;M<C;M++){const z=n.resolveTriangleIndex(M);F(u,3*z,f,r),u.needsUpdate=!0;const N=u.distanceToTriangle(d,A,g);if(N<y&&(T.copy(A),h&&h.copy(g),y=N,m=M,x=v),N<o)return!0}}}})}else{const b=Ft(t);for(let P=0,B=b;P<B;P++){F(d,3*P,p,l),d.a.applyMatrix4(e),d.b.applyMatrix4(e),d.c.applyMatrix4(e),d.needsUpdate=!0;for(let v=w,I=w+S;v<I;v++){const _=n.resolveTriangleIndex(v);F(u,3*_,f,r),u.needsUpdate=!0;const M=u.distanceToTriangle(d,A,g);if(M<y&&(T.copy(A),h&&h.copy(g),y=M,m=v,x=P),M<o)return!0}}}}}),j.releasePrimitive(u),j.releasePrimitive(d),y===1/0?null:(s.point?s.point.copy(T):s.point=T.clone(),s.distance=y,s.faceIndex=m,i&&(i.point?i.point.copy(h):i.point=h.clone(),i.point.applyMatrix4(ce),T.applyMatrix4(ce),i.distance=T.sub(i.point).length(),i.faceIndex=x),s)}function gi(){return typeof SharedArrayBuffer<"u"}const Wt=new L.constructor,we=new L.constructor,ft=new an(()=>new nt),Lt=new nt,Ut=new nt,Ne=new nt,Le=new nt;let Ue=!1;function xi(n,t,e,s){if(Ue)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");Ue=!0;const i=n._roots,o=t._roots;let a,c=0,r=0;const f=new et().copy(e).invert();for(let l=0,p=i.length;l<p;l++){Wt.setBuffer(i[l]),r=0;const u=ft.getPrimitive();U(0,Wt.float32Array,u),u.applyMatrix4(f);for(let d=0,A=o.length;d<A&&(we.setBuffer(o[d]),a=J(0,0,e,f,s,c,r,0,0,u),we.clearBuffer(),r+=o[d].length,!a);d++);if(ft.releasePrimitive(u),Wt.clearBuffer(),c+=i[l].length,a)break}return Ue=!1,a}function J(n,t,e,s,i,o=0,a=0,c=0,r=0,f=null,l=!1){let p,u;l?(p=we,u=Wt):(p=Wt,u=we);const d=p.float32Array,A=p.uint32Array,T=p.uint16Array,g=u.float32Array,h=u.uint32Array,y=u.uint16Array,m=n*2,x=t*2,w=$(m,T),S=$(x,y);let b=!1;if(S&&w)l?b=i(q(t,h),O(t*2,y),q(n,A),O(n*2,T),r,a+t,c,o+n):b=i(q(n,A),O(n*2,T),q(t,h),O(t*2,y),c,o+n,r,a+t);else if(S){const P=ft.getPrimitive();U(t,g,P),P.applyMatrix4(e);const B=X(n),v=W(n,A);U(B,d,Lt),U(v,d,Ut);const I=P.intersectsBox(Lt),_=P.intersectsBox(Ut);b=I&&J(t,B,s,e,i,a,o,r,c+1,P,!l)||_&&J(t,v,s,e,i,a,o,r,c+1,P,!l),ft.releasePrimitive(P)}else{const P=X(t),B=W(t,h);U(P,g,Ne),U(B,g,Le);const v=f.intersectsBox(Ne),I=f.intersectsBox(Le);if(v&&I)b=J(n,P,e,s,i,o,a,c,r+1,f,l)||J(n,B,e,s,i,o,a,c,r+1,f,l);else if(v)if(w)b=J(n,P,e,s,i,o,a,c,r+1,f,l);else{const _=ft.getPrimitive();_.copy(Ne).applyMatrix4(e);const M=X(n),C=W(n,A);U(M,d,Lt),U(C,d,Ut);const z=_.intersectsBox(Lt),N=_.intersectsBox(Ut);b=z&&J(P,M,s,e,i,a,o,r,c+1,_,!l)||N&&J(P,C,s,e,i,a,o,r,c+1,_,!l),ft.releasePrimitive(_)}else if(I)if(w)b=J(n,B,e,s,i,o,a,c,r+1,f,l);else{const _=ft.getPrimitive();_.copy(Le).applyMatrix4(e);const M=X(n),C=W(n,A);U(M,d,Lt),U(C,d,Ut);const z=_.intersectsBox(Lt),N=_.intersectsBox(Ut);b=z&&J(B,M,s,e,i,a,o,r,c+1,_,!l)||N&&J(B,C,s,e,i,a,o,r,c+1,_,!l),ft.releasePrimitive(_)}}return b}const ae=new k,_n=new nt,wi={strategy:Yn,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0,range:null};class ln{static serialize(t,e={}){e={cloneBuffers:!0,...e};const s=t.geometry,i=t._roots,o=t._indirectBuffer,a=s.getIndex();let c;return e.cloneBuffers?c={roots:i.map(r=>r.slice()),index:a?a.array.slice():null,indirectBuffer:o?o.slice():null}:c={roots:i,index:a?a.array:null,indirectBuffer:o},c}static deserialize(t,e,s={}){s={setIndex:!0,indirect:!!t.indirectBuffer,...s};const{index:i,roots:o,indirectBuffer:a}=t,c=new ln(e,{...s,[_e]:!0});if(c._roots=o,c._indirectBuffer=a||null,s.setIndex){const r=e.getIndex();if(r===null){const f=new Te(t.index,1,!1);e.setIndex(f)}else r.array!==i&&(r.array.set(i),r.needsUpdate=!0)}return c}get indirect(){return!!this._indirectBuffer}constructor(t,e={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(e=Object.assign({...wi,[_e]:!1},e),e.useSharedArrayBuffer&&!gi())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=t,this._roots=null,this._indirectBuffer=null,e[_e]||(Us(this,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new nt))),this.resolveTriangleIndex=e.indirect?s=>this._indirectBuffer[s]:s=>s}refit(t=null){return(this.indirect?ci:js)(this,t)}traverse(t,e=0){const s=this._roots[e],i=new Uint32Array(s),o=new Uint16Array(s);a(0);function a(c,r=0){const f=c*2,l=o[f+15]===Se;if(l){const p=i[c+6],u=o[f+14];t(r,l,new Float32Array(s,c*4,6),p,u)}else{const p=c+Xt/4,u=i[c+6],d=i[c+7];t(r,l,new Float32Array(s,c*4,6),d)||(a(p,r+1),a(u,r+1))}}}raycast(t,e=pn,s=0,i=1/0){const o=this._roots,a=this.geometry,c=[],r=e.isMaterial,f=Array.isArray(e),l=a.groups,p=r?e.side:e,u=this.indirect?ai:Js;for(let d=0,A=o.length;d<A;d++){const T=f?e[l[d].materialIndex].side:p,g=c.length;if(u(this,d,T,t,c,s,i),f){const h=l[d].materialIndex;for(let y=g,m=c.length;y<m;y++)c[y].face.materialIndex=h}}return c}raycastFirst(t,e=pn,s=0,i=1/0){const o=this._roots,a=this.geometry,c=e.isMaterial,r=Array.isArray(e);let f=null;const l=a.groups,p=c?e.side:e,u=this.indirect?ui:ti;for(let d=0,A=o.length;d<A;d++){const T=r?e[l[d].materialIndex].side:p,g=u(this,d,T,t,s,i);g!=null&&(f==null||g.distance<f.distance)&&(f=g,r&&(g.face.materialIndex=l[d].materialIndex))}return f}intersectsGeometry(t,e){let s=!1;const i=this._roots,o=this.indirect?fi:ei;for(let a=0,c=i.length;a<c&&(s=o(this,a,t,e),!s);a++);return s}shapecast(t){const e=j.getPrimitive(),s=this.indirect?Ks:Ws;let{boundsTraverseOrder:i,intersectsBounds:o,intersectsRange:a,intersectsTriangle:c}=t;if(a&&c){const p=a;a=(u,d,A,T,g)=>p(u,d,A,T,g)?!0:s(u,d,this,c,A,T,e)}else a||(c?a=(p,u,d,A)=>s(p,u,this,c,d,A,e):a=(p,u,d)=>d);let r=!1,f=0;const l=this._roots;for(let p=0,u=l.length;p<u;p++){const d=l[p];if(r=$s(this,p,o,a,i,f),r)break;f+=d.byteLength}return j.releasePrimitive(e),r}bvhcast(t,e,s){let{intersectsRanges:i,intersectsTriangles:o}=s;const a=j.getPrimitive(),c=this.geometry.index,r=this.geometry.attributes.position,f=this.indirect?A=>{const T=this.resolveTriangleIndex(A);F(a,T*3,c,r)}:A=>{F(a,A*3,c,r)},l=j.getPrimitive(),p=t.geometry.index,u=t.geometry.attributes.position,d=t.indirect?A=>{const T=t.resolveTriangleIndex(A);F(l,T*3,p,u)}:A=>{F(l,A*3,p,u)};if(o){const A=(T,g,h,y,m,x,w,S)=>{for(let b=h,P=h+y;b<P;b++){d(b),l.a.applyMatrix4(e),l.b.applyMatrix4(e),l.c.applyMatrix4(e),l.needsUpdate=!0;for(let B=T,v=T+g;B<v;B++)if(f(B),a.needsUpdate=!0,o(a,l,B,b,m,x,w,S))return!0}return!1};if(i){const T=i;i=function(g,h,y,m,x,w,S,b){return T(g,h,y,m,x,w,S,b)?!0:A(g,h,y,m,x,w,S,b)}}else i=A}return xi(this,t,e,i)}intersectsBox(t,e){return ae.set(t.min,t.max,e),ae.needsUpdate=!0,this.shapecast({intersectsBounds:s=>ae.intersectsBox(s),intersectsTriangle:s=>ae.intersectsTriangle(s)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,s={},i={},o=0,a=1/0){return(this.indirect?mi:oi)(this,t,e,s,i,o,a)}closestPointToPoint(t,e={},s=0,i=1/0){return Gs(this,t,e,s,i)}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(s=>{U(0,new Float32Array(s),_n),t.union(_n)}),t}}const es=1e-6,Ai=es*.5,ns=Math.pow(10,-Math.log10(es)),bi=Ai*ns;function tt(n){return~~(n*ns+bi)}function Ti(n){return`${tt(n.x)},${tt(n.y)}`}function vn(n){return`${tt(n.x)},${tt(n.y)},${tt(n.z)}`}function Si(n){return`${tt(n.x)},${tt(n.y)},${tt(n.z)},${tt(n.w)}`}function Pi(n,t,e){e.direction.subVectors(t,n).normalize();const s=n.dot(e.direction);return e.origin.copy(n).addScaledVector(e.direction,-s),e}function ss(){return typeof SharedArrayBuffer<"u"}function Bi(n){if(n.buffer instanceof SharedArrayBuffer)return n;const t=n.constructor,e=n.buffer,s=new SharedArrayBuffer(e.byteLength),i=new Uint8Array(e);return new Uint8Array(s).set(i,0),new t(s)}function _i(n,t=ArrayBuffer){return n>65535?new Uint32Array(new t(4*n)):new Uint16Array(new t(2*n))}function vi(n,t){if(!n.index){const e=n.attributes.position.count,s=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,i=_i(e,s);n.setIndex(new Te(i,1));for(let o=0;o<e;o++)i[o]=o}}function Mi(n){return n.index?n.index.count:n.attributes.position.count}function un(n){return Mi(n)/3}const Ii=1e-8,Ei=new E;function Ci(n){return~~(n/3)}function zi(n){return n%3}function Mn(n,t){return n.start-t.start}function In(n,t){return Ei.subVectors(t,n.origin).dot(n.direction)}function Ni(n,t,e,s=Ii){n.sort(Mn),t.sort(Mn);for(let c=0;c<n.length;c++){const r=n[c];for(let f=0;f<t.length;f++){const l=t[f];if(!(l.start>r.end)){if(r.end<l.start||l.end<r.start)continue;if(r.start<=l.start&&r.end>=l.end)o(l.end,r.end)||n.splice(c+1,0,{start:l.end,end:r.end,index:r.index}),r.end=l.start,l.start=0,l.end=0;else if(r.start>=l.start&&r.end<=l.end)o(r.end,l.end)||t.splice(f+1,0,{start:r.end,end:l.end,index:l.index}),l.end=r.start,r.start=0,r.end=0;else if(r.start<=l.start&&r.end<=l.end){const p=r.end;r.end=l.start,l.start=p}else if(r.start>=l.start&&r.end>=l.end){const p=l.end;l.end=r.start,r.start=p}else throw new Error}if(e.has(r.index)||e.set(r.index,[]),e.has(l.index)||e.set(l.index,[]),e.get(r.index).push(l.index),e.get(l.index).push(r.index),a(l)&&(t.splice(f,1),f--),a(r)){n.splice(c,1),c--;break}}}i(n),i(t);function i(c){for(let r=0;r<c.length;r++)a(c[r])&&(c.splice(r,1),r--)}function o(c,r){return Math.abs(r-c)<s}function a(c){return Math.abs(c.end-c.start)<s}}const En=1e-5,Cn=1e-4;class Li{constructor(){this._rays=[]}addRay(t){this._rays.push(t)}findClosestRay(t){const e=this._rays,s=t.clone();s.direction.multiplyScalar(-1);let i=1/0,o=null;for(let r=0,f=e.length;r<f;r++){const l=e[r];if(a(l,t)&&a(l,s))continue;const p=c(l,t),u=c(l,s),d=Math.min(p,u);d<i&&(i=d,o=l)}return o;function a(r,f){const l=r.origin.distanceTo(f.origin)>En;return r.direction.angleTo(f.direction)>Cn||l}function c(r,f){const l=r.origin.distanceTo(f.origin),p=r.direction.angleTo(f.direction);return l/En+p/Cn}}}const Re=new E,Fe=new E,le=new jn;function Ui(n,t,e){const s=n.attributes,i=n.index,o=s.position,a=new Map,c=new Map,r=Array.from(t),f=new Li;for(let l=0,p=r.length;l<p;l++){const u=r[l],d=Ci(u),A=zi(u);let T=3*d+A,g=3*d+(A+1)%3;i&&(T=i.getX(T),g=i.getX(g)),Re.fromBufferAttribute(o,T),Fe.fromBufferAttribute(o,g),Pi(Re,Fe,le);let h,y=f.findClosestRay(le);y===null&&(y=le.clone(),f.addRay(y)),c.has(y)||c.set(y,{forward:[],reverse:[],ray:y}),h=c.get(y);let m=In(y,Re),x=In(y,Fe);m>x&&([m,x]=[x,m]),le.direction.dot(y.direction)<0?h.reverse.push({start:m,end:x,index:u}):h.forward.push({start:m,end:x,index:u})}return c.forEach(({forward:l,reverse:p},u)=>{Ni(l,p,a,e),l.length===0&&p.length===0&&c.delete(u)}),{disjointConnectivityMap:a,fragmentMap:c}}const Ri=new St,De=new E,Fi=new Pt,Ve=["","",""];class Di{constructor(t=null){this.data=null,this.disjointConnections=null,this.unmatchedDisjointEdges=null,this.unmatchedEdges=-1,this.matchedEdges=-1,this.useDrawRange=!0,this.useAllAttributes=!1,this.matchDisjointEdges=!1,this.degenerateEpsilon=1e-8,t&&this.updateFrom(t)}getSiblingTriangleIndex(t,e){const s=this.data[t*3+e];return s===-1?-1:~~(s/3)}getSiblingEdgeIndex(t,e){const s=this.data[t*3+e];return s===-1?-1:s%3}getDisjointSiblingTriangleIndices(t,e){const s=t*3+e,i=this.disjointConnections.get(s);return i?i.map(o=>~~(o/3)):[]}getDisjointSiblingEdgeIndices(t,e){const s=t*3+e,i=this.disjointConnections.get(s);return i?i.map(o=>o%3):[]}isFullyConnected(){return this.unmatchedEdges===0}updateFrom(t){const{useAllAttributes:e,useDrawRange:s,matchDisjointEdges:i,degenerateEpsilon:o}=this,a=e?m:y,c=new Map,{attributes:r}=t,f=e?Object.keys(r):null,l=t.index,p=r.position;let u=un(t);const d=u;let A=0;s&&(A=t.drawRange.start,t.drawRange.count!==1/0&&(u=~~(t.drawRange.count/3)));let T=this.data;(!T||T.length<3*d)&&(T=new Int32Array(3*d)),T.fill(-1);let g=0,h=new Set;for(let x=A,w=u*3+A;x<w;x+=3){const S=x;for(let b=0;b<3;b++){let P=S+b;l&&(P=l.getX(P)),Ve[b]=a(P)}for(let b=0;b<3;b++){const P=(b+1)%3,B=Ve[b],v=Ve[P],I=`${v}_${B}`;if(c.has(I)){const _=S+b,M=c.get(I);T[_]=M,T[M]=_,c.delete(I),g+=2,h.delete(M)}else{const _=`${B}_${v}`,M=S+b;c.set(_,M),h.add(M)}}}if(i){const{fragmentMap:x,disjointConnectivityMap:w}=Ui(t,h,o);h.clear(),x.forEach(({forward:S,reverse:b})=>{S.forEach(({index:P})=>h.add(P)),b.forEach(({index:P})=>h.add(P))}),this.unmatchedDisjointEdges=x,this.disjointConnections=w,g=u*3-h.size}this.matchedEdges=g,this.unmatchedEdges=h.size,this.data=T;function y(x){return De.fromBufferAttribute(p,x),vn(De)}function m(x){let w="";for(let S=0,b=f.length;S<b;S++){const P=r[f[S]];let B;switch(P.itemSize){case 1:B=tt(P.getX(x));break;case 2:B=Ti(Ri.fromBufferAttribute(P,x));break;case 3:B=vn(De.fromBufferAttribute(P,x));break;case 4:B=Si(Fi.fromBufferAttribute(P,x));break}w!==""&&(w+="|"),w+=B}return w}}}class Ae extends fs{constructor(...t){super(...t),this.isBrush=!0,this._previousMatrix=new et,this._previousMatrix.elements.fill(0)}markUpdated(){this._previousMatrix.copy(this.matrix)}isDirty(){const{matrix:t,_previousMatrix:e}=this,s=t.elements,i=e.elements;for(let o=0;o<16;o++)if(s[o]!==i[o])return!0;return!1}prepareGeometry(){const t=this.geometry,e=t.attributes,s=ss();if(s)for(const i in e){const o=e[i];if(o.isInterleavedBufferAttribute)throw new Error("Brush: InterleavedBufferAttributes are not supported.");o.array=Bi(o.array)}if(t.boundsTree||(vi(t,{useSharedArrayBuffer:s}),t.boundsTree=new ln(t,{maxLeafTris:3,indirect:!0,useSharedArrayBuffer:s})),t.halfEdges||(t.halfEdges=new Di(t)),!t.groupIndices){const i=un(t),o=new Uint16Array(i),a=t.groups;for(let c=0,r=a.length;c<r;c++){const{start:f,count:l}=a[c];for(let p=f/3,u=(f+l)/3;p<u;p++)o[p]=c}t.groupIndices=o}}disposeCacheData(){const{geometry:t}=this;t.halfEdges=null,t.boundsTree=null,t.groupIndices=null}}const Vi=1e-14,ke=new E,zn=new E,Nn=new E;function pt(n,t=Vi){ke.subVectors(n.b,n.a),zn.subVectors(n.c,n.a),Nn.subVectors(n.b,n.c);const e=ke.angleTo(zn),s=ke.angleTo(Nn),i=Math.PI-e-s;return Math.abs(e)<t||Math.abs(s)<t||Math.abs(i)<t||n.a.distanceToSquared(n.b)<t||n.a.distanceToSquared(n.c)<t||n.b.distanceToSquared(n.c)<t}const $e=1e-10,Ht=1e-10,ki=1e-10,st=new Y,R=new Y,it=new E,Ge=new E,Ln=new E,ue=new rn,qe=new Z;class $i{constructor(){this._pool=[],this._index=0}getTriangle(){return this._index>=this._pool.length&&this._pool.push(new G),this._pool[this._index++]}clear(){this._index=0}reset(){this._pool.length=0,this._index=0}}class Gi{constructor(){this.trianglePool=new $i,this.triangles=[],this.normal=new E,this.coplanarTriangleUsed=!1}initialize(t){this.reset();const{triangles:e,trianglePool:s,normal:i}=this;if(Array.isArray(t))for(let o=0,a=t.length;o<a;o++){const c=t[o];if(o===0)c.getNormal(i);else if(Math.abs(1-c.getNormal(it).dot(i))>$e)throw new Error("Triangle Splitter: Cannot initialize with triangles that have different normals.");const r=s.getTriangle();r.copy(c),e.push(r)}else{t.getNormal(i);const o=s.getTriangle();o.copy(t),e.push(o)}}splitByTriangle(t){const{normal:e,triangles:s}=this;if(t.getNormal(Ge).normalize(),Math.abs(1-Math.abs(Ge.dot(e)))<ki){this.coplanarTriangleUsed=!0;for(let o=0,a=s.length;o<a;o++){const c=s[o];c.coplanarCount=0}const i=[t.a,t.b,t.c];for(let o=0;o<3;o++){const a=(o+1)%3,c=i[o],r=i[a];it.subVectors(r,c).normalize(),Ln.crossVectors(Ge,it),ue.setFromNormalAndCoplanarPoint(Ln,c),this.splitByPlane(ue,t)}}else t.getPlane(ue),this.splitByPlane(ue,t)}splitByPlane(t,e){const{triangles:s,trianglePool:i}=this;qe.copy(e),qe.needsUpdate=!0;for(let o=0,a=s.length;o<a;o++){const c=s[o];if(!qe.intersectsTriangle(c,st,!0))continue;const{a:r,b:f,c:l}=c;let p=0,u=-1,d=!1,A=[],T=[];const g=[r,f,l];for(let h=0;h<3;h++){const y=(h+1)%3;st.start.copy(g[h]),st.end.copy(g[y]);const m=t.distanceToPoint(st.start),x=t.distanceToPoint(st.end);if(Math.abs(m)<Ht&&Math.abs(x)<Ht){d=!0;break}if(m>0?A.push(h):T.push(h),Math.abs(m)<Ht)continue;let w=!!t.intersectLine(st,it);!w&&Math.abs(x)<Ht&&(it.copy(st.end),w=!0),w&&!(it.distanceTo(st.start)<$e)&&(it.distanceTo(st.end)<$e&&(u=h),p===0?R.start.copy(it):R.end.copy(it),p++)}if(!d&&p===2&&R.distance()>Ht)if(u!==-1){u=(u+1)%3;let h=0;h===u&&(h=(h+1)%3);let y=h+1;y===u&&(y=(y+1)%3);const m=i.getTriangle();m.a.copy(g[y]),m.b.copy(R.end),m.c.copy(R.start),pt(m)||s.push(m),c.a.copy(g[h]),c.b.copy(R.start),c.c.copy(R.end),pt(c)&&(s.splice(o,1),o--,a--)}else{const h=A.length>=2?T[0]:A[0];if(h===0){let S=R.start;R.start=R.end,R.end=S}const y=(h+1)%3,m=(h+2)%3,x=i.getTriangle(),w=i.getTriangle();g[y].distanceToSquared(R.start)<g[m].distanceToSquared(R.end)?(x.a.copy(g[y]),x.b.copy(R.start),x.c.copy(R.end),w.a.copy(g[y]),w.b.copy(g[m]),w.c.copy(R.start)):(x.a.copy(g[m]),x.b.copy(R.start),x.c.copy(R.end),w.a.copy(g[y]),w.b.copy(g[m]),w.c.copy(R.end)),c.a.copy(g[h]),c.b.copy(R.end),c.c.copy(R.start),pt(x)||s.push(x),pt(w)||s.push(w),pt(c)&&(s.splice(o,1),o--,a--)}else p===3&&console.warn("TriangleClipper: Coplanar clip not handled")}}reset(){this.triangles.length=0,this.trianglePool.clear(),this.coplanarTriangleUsed=!1}}function qi(n){return n=~~n,n+4-n%4}class Un{constructor(t,e=500){this.expansionFactor=1.5,this.type=t,this.length=0,this.array=null,this.setSize(e)}setType(t){if(this.length!==0)throw new Error("TypeBackedArray: Cannot change the type while there is used data in the buffer.");const e=this.array.buffer;this.array=new t(e),this.type=t}setSize(t){if(this.array&&t===this.array.length)return;const e=this.type,s=ss()?SharedArrayBuffer:ArrayBuffer,i=new e(new s(qi(t*e.BYTES_PER_ELEMENT)));this.array&&i.set(this.array,0),this.array=i}expand(){const{array:t,expansionFactor:e}=this;this.setSize(t.length*e)}push(...t){let{array:e,length:s}=this;s+t.length>e.length&&(this.expand(),e=this.array);for(let i=0,o=t.length;i<o;i++)e[s+i]=t[i];this.length+=t.length}clear(){this.length=0}}class Hi{constructor(){this.groupAttributes=[{}],this.groupCount=0}getType(t){return this.groupAttributes[0][t].type}getItemSize(t){return this.groupAttributes[0][t].itemSize}getNormalized(t){return this.groupAttributes[0][t].normalized}getCount(t){if(this.groupCount<=t)return 0;const e=this.getGroupAttrArray("position",t);return e.length/e.itemSize}getTotalLength(t){const{groupCount:e,groupAttributes:s}=this;let i=0;for(let o=0;o<e;o++){const a=s[o];i+=a[t].length}return i}getGroupAttrSet(t=0){const{groupAttributes:e}=this;if(e[t])return this.groupCount=Math.max(this.groupCount,t+1),e[t];const s=e[0];for(this.groupCount=Math.max(this.groupCount,t+1);t>=e.length;){const i={};e.push(i);for(const o in s){const a=s[o],c=new Un(a.type);c.itemSize=a.itemSize,c.normalized=a.normalized,i[o]=c}}return e[t]}getGroupAttrArray(t,e=0){const{groupAttributes:s}=this;if(!s[0][t])throw new Error(`TypedAttributeData: Attribute with "${t}" has not been initialized`);return this.getGroupAttrSet(e)[t]}initializeArray(t,e,s,i){const{groupAttributes:o}=this,c=o[0][t];if(c){if(c.type!==e)for(let r=0,f=o.length;r<f;r++){const l=o[r][t];l.setType(e),l.itemSize=s,l.normalized=i}}else for(let r=0,f=o.length;r<f;r++){const l=new Un(e);l.itemSize=s,l.normalized=i,o[r][t]=l}}clear(){this.groupCount=0;const{groupAttributes:t}=this;t.forEach(e=>{for(const s in e)e[s].clear()})}delete(t){this.groupAttributes.forEach(e=>{delete e[t]})}reset(){this.groupAttributes=[],this.groupCount=0}}class Rn{constructor(){this.intersectionSet={},this.ids=[]}add(t,e){const{intersectionSet:s,ids:i}=this;s[t]||(s[t]=[],i.push(t)),s[t].push(e)}}const Oi=0,is=1,Xi=2,Wi=3,ji=4,rs=5,os=6,H=new jn,Fn=new et,V=new G,rt=new E,Dn=new Pt,Vn=new Pt,kn=new Pt,He=new Pt,fe=new Pt,pe=new Pt,$n=new Y,Oe=new E,Xe=1e-8,Yi=1e-15,At=-1,bt=1,me=-2,ge=2,jt=0,xt=1,fn=2,Zi=1e-14;let xe=null;function Gn(n){xe=n}function cs(n,t){n.getMidpoint(H.origin),n.getNormal(H.direction);const e=t.raycastFirst(H,on);return!!(e&&H.direction.dot(e.face.normal)>0)?At:bt}function Ki(n,t){function e(){return Math.random()-.5}n.getNormal(Oe),H.direction.copy(Oe),n.getMidpoint(H.origin);const s=3;let i=0,o=1/0;for(let a=0;a<s;a++){H.direction.x+=e()*Xe,H.direction.y+=e()*Xe,H.direction.z+=e()*Xe,H.direction.multiplyScalar(-1);const c=t.raycastFirst(H,on);if(!!(c&&H.direction.dot(c.face.normal)>0)&&i++,c!==null&&(o=Math.min(o,c.distance)),o<=Yi)return c.face.normal.dot(Oe)>0?ge:me;if(i/s>.5||(a-i+1)/s>.5)break}return i/s>.5?At:bt}function Ji(n,t){const e=new Rn,s=new Rn;return Fn.copy(n.matrixWorld).invert().multiply(t.matrixWorld),n.geometry.boundsTree.bvhcast(t.geometry.boundsTree,Fn,{intersectsTriangles(i,o,a,c){if(!pt(i)&&!pt(o)){let r=i.intersectsTriangle(o,$n,!0);if(!r){const f=i.plane,l=o.plane,p=f.normal,u=l.normal;p.dot(u)===1&&Math.abs(f.constant-l.constant)<Zi&&(r=!0)}if(r){let f=n.geometry.boundsTree.resolveTriangleIndex(a),l=t.geometry.boundsTree.resolveTriangleIndex(c);e.add(f,l),s.add(l,f),xe&&(xe.addEdge($n),xe.addIntersectingTriangles(a,i,c,o))}}return!1}}),{aIntersections:e,bIntersections:s}}function Qi(n,t,e,s,i,o,a=!1){const c=e.attributes,r=e.index,f=n*3,l=r.getX(f+0),p=r.getX(f+1),u=r.getX(f+2);for(const d in o){const A=c[d],T=o[d];if(!(d in c))throw new Error(`CSG Operations: Attribute ${d} not available on geometry.`);const g=A.itemSize;d==="position"?(V.a.fromBufferAttribute(A,l).applyMatrix4(s),V.b.fromBufferAttribute(A,p).applyMatrix4(s),V.c.fromBufferAttribute(A,u).applyMatrix4(s),We(V.a,V.b,V.c,t,3,T,a)):d==="normal"?(V.a.fromBufferAttribute(A,l).applyNormalMatrix(i),V.b.fromBufferAttribute(A,p).applyNormalMatrix(i),V.c.fromBufferAttribute(A,u).applyNormalMatrix(i),a&&(V.a.multiplyScalar(-1),V.b.multiplyScalar(-1),V.c.multiplyScalar(-1)),We(V.a,V.b,V.c,t,3,T,a,!0)):(Dn.fromBufferAttribute(A,l),Vn.fromBufferAttribute(A,p),kn.fromBufferAttribute(A,u),We(Dn,Vn,kn,t,g,T,a))}}function tr(n,t,e,s,i,o,a,c=!1){je(n,s,i,o,a,c),je(c?e:t,s,i,o,a,c),je(c?t:e,s,i,o,a,c)}function as(n,t,e=!1){switch(n){case Oi:if(t===bt||t===ge&&!e)return xt;break;case is:if(e){if(t===At)return jt}else if(t===bt||t===me)return xt;break;case Xi:if(e){if(t===bt||t===me)return xt}else if(t===At)return jt;break;case ji:if(t===At)return jt;if(t===bt)return xt;break;case Wi:if(t===At||t===ge&&!e)return xt;break;case rs:if(!e&&(t===bt||t===me))return xt;break;case os:if(!e&&(t===At||t===ge))return xt;break;default:throw new Error(`Unrecognized CSG operation enum "${n}".`)}return fn}function We(n,t,e,s,i,o,a=!1,c=!1){const r=f=>{o.push(f.x),i>1&&o.push(f.y),i>2&&o.push(f.z),i>3&&o.push(f.w)};He.set(0,0,0,0).addScaledVector(n,s.a.x).addScaledVector(t,s.a.y).addScaledVector(e,s.a.z),fe.set(0,0,0,0).addScaledVector(n,s.b.x).addScaledVector(t,s.b.y).addScaledVector(e,s.b.z),pe.set(0,0,0,0).addScaledVector(n,s.c.x).addScaledVector(t,s.c.y).addScaledVector(e,s.c.z),c&&(He.normalize(),fe.normalize(),pe.normalize()),r(He),a?(r(pe),r(fe)):(r(fe),r(pe))}function je(n,t,e,s,i,o=!1){for(const a in i){const c=t[a],r=i[a];if(!(a in t))throw new Error(`CSG Operations: Attribute ${a} no available on geometry.`);const f=c.itemSize;a==="position"?(rt.fromBufferAttribute(c,n).applyMatrix4(e),r.push(rt.x,rt.y,rt.z)):a==="normal"?(rt.fromBufferAttribute(c,n).applyNormalMatrix(s),o&&rt.multiplyScalar(-1),r.push(rt.x,rt.y,rt.z)):(r.push(c.getX(n)),f>1&&r.push(c.getY(n)),f>2&&r.push(c.getZ(n)),f>3&&r.push(c.getW(n)))}}class er{constructor(t){this.triangle=new G().copy(t),this.intersects={}}addTriangle(t,e){this.intersects[t]=new G().copy(e)}getIntersectArray(){const t=[],{intersects:e}=this;for(const s in e)t.push(e[s]);return t}}class qn{constructor(){this.data={}}addTriangleIntersection(t,e,s,i){const{data:o}=this;o[t]||(o[t]=new er(e)),o[t].addTriangle(s,i)}getTrianglesAsArray(t=null){const{data:e}=this,s=[];if(t!==null)t in e&&s.push(e[t].triangle);else for(const i in e)s.push(e[i].triangle);return s}getTriangleIndices(){return Object.keys(this.data).map(t=>parseInt(t))}getIntersectionIndices(t){const{data:e}=this;return e[t]?Object.keys(e[t].intersects).map(s=>parseInt(s)):[]}getIntersectionsAsArray(t=null,e=null){const{data:s}=this,i=new Set,o=[],a=c=>{if(s[c])if(e!==null)s[c].intersects[e]&&o.push(s[c].intersects[e]);else{const r=s[c].intersects;for(const f in r)i.has(f)||(i.add(f),o.push(r[f]))}};if(t!==null)a(t);else for(const c in s)a(c);return o}reset(){this.data={}}}class nr{constructor(){this.enabled=!1,this.triangleIntersectsA=new qn,this.triangleIntersectsB=new qn,this.intersectionEdges=[]}addIntersectingTriangles(t,e,s,i){const{triangleIntersectsA:o,triangleIntersectsB:a}=this;o.addTriangleIntersection(t,e,s,i),a.addTriangleIntersection(s,i,t,e)}addEdge(t){this.intersectionEdges.push(t.clone())}reset(){this.triangleIntersectsA.reset(),this.triangleIntersectsB.reset(),this.intersectionEdges=[]}init(){this.enabled&&(this.reset(),Gn(this))}complete(){this.enabled&&Gn(null)}}const ht=new et,be=new ps,wt=new G,de=new G,ut=new G,he=new G,Q=[],Tt=[];function sr(n){for(const t of n)return t}function ir(n,t,e,s,i,o={}){const{useGroups:a=!0}=o,{aIntersections:c,bIntersections:r}=Ji(n,t),f=[];let l=null,p;return p=a?0:-1,Hn(n,t,c,e,!1,s,i,p),On(n,t,c,e,!1,i,p),e.findIndex(d=>d!==os&&d!==rs)!==-1&&(p=a?n.geometry.groups.length||1:-1,Hn(t,n,r,e,!0,s,i,p),On(t,n,r,e,!0,i,p)),Q.length=0,Tt.length=0,{groups:f,materials:l}}function Hn(n,t,e,s,i,o,a,c=0){const r=n.matrixWorld.determinant()<0;ht.copy(t.matrixWorld).invert().multiply(n.matrixWorld),be.getNormalMatrix(n.matrixWorld).multiplyScalar(r?-1:1);const f=n.geometry.groupIndices,l=n.geometry.index,p=n.geometry.attributes.position,u=t.geometry.boundsTree,d=t.geometry.index,A=t.geometry.attributes.position,T=e.ids,g=e.intersectionSet;for(let h=0,y=T.length;h<y;h++){const m=T[h],x=c===-1?0:f[m]+c,w=3*m,S=l.getX(w+0),b=l.getX(w+1),P=l.getX(w+2);wt.a.fromBufferAttribute(p,S).applyMatrix4(ht),wt.b.fromBufferAttribute(p,b).applyMatrix4(ht),wt.c.fromBufferAttribute(p,P).applyMatrix4(ht),o.reset(),o.initialize(wt);const B=g[m];for(let I=0,_=B.length;I<_;I++){const M=3*B[I],C=d.getX(M+0),z=d.getX(M+1),N=d.getX(M+2);de.a.fromBufferAttribute(A,C),de.b.fromBufferAttribute(A,z),de.c.fromBufferAttribute(A,N),o.splitByTriangle(de)}const v=o.triangles;for(let I=0,_=v.length;I<_;I++){const M=v[I],C=o.coplanarTriangleUsed?Ki(M,u):cs(M,u);Q.length=0,Tt.length=0;for(let z=0,N=s.length;z<N;z++){const D=as(s[z],C,i);D!==fn&&(Tt.push(D),Q.push(a[z].getGroupAttrSet(x)))}if(Q.length!==0){wt.getBarycoord(M.a,he.a),wt.getBarycoord(M.b,he.b),wt.getBarycoord(M.c,he.c);for(let z=0,N=Q.length;z<N;z++){const D=Q[z],mt=Tt[z]===jt;Qi(m,he,n.geometry,n.matrixWorld,be,D,r!==mt)}}}}return T.length}function On(n,t,e,s,i,o,a=0){const c=n.matrixWorld.determinant()<0;ht.copy(t.matrixWorld).invert().multiply(n.matrixWorld),be.getNormalMatrix(n.matrixWorld).multiplyScalar(c?-1:1);const r=t.geometry.boundsTree,f=n.geometry.groupIndices,l=n.geometry.index,p=n.geometry.attributes,u=p.position,d=[],A=n.geometry.halfEdges,T=new Set,g=un(n.geometry);for(let h=0,y=g;h<y;h++)h in e.intersectionSet||T.add(h);for(;T.size>0;){const h=sr(T);T.delete(h),d.push(h);const y=3*h,m=l.getX(y+0),x=l.getX(y+1),w=l.getX(y+2);ut.a.fromBufferAttribute(u,m).applyMatrix4(ht),ut.b.fromBufferAttribute(u,x).applyMatrix4(ht),ut.c.fromBufferAttribute(u,w).applyMatrix4(ht);const S=cs(ut,r);Tt.length=0,Q.length=0;for(let b=0,P=s.length;b<P;b++){const B=as(s[b],S,i);B!==fn&&(Tt.push(B),Q.push(o[b]))}for(;d.length>0;){const b=d.pop();for(let P=0;P<3;P++){const B=A.getSiblingTriangleIndex(b,P);B!==-1&&T.has(B)&&(d.push(B),T.delete(B))}if(Q.length!==0){const P=3*b,B=l.getX(P+0),v=l.getX(P+1),I=l.getX(P+2),_=a===-1?0:f[b]+a;if(ut.a.fromBufferAttribute(u,B),ut.b.fromBufferAttribute(u,v),ut.c.fromBufferAttribute(u,I),!pt(ut))for(let M=0,C=Q.length;M<C;M++){const z=Tt[M],N=Q[M].getGroupAttrSet(_),D=z===jt;tr(B,v,I,p,n.matrixWorld,be,N,D!==c)}}}}}function rr(n){for(let t=0;t<n.length-1;t++){const e=n[t],s=n[t+1];if(e.materialIndex===s.materialIndex){const i=e.start,o=s.start+s.count;s.start=i,s.count=o-i,n.splice(t,1),t--}}}function or(n,t,e,s){e.clear();const i=n.attributes;for(let o=0,a=s.length;o<a;o++){const c=s[o],r=i[c];e.initializeArray(c,r.array.constructor,r.itemSize,r.normalized)}for(const o in e.attributes)s.includes(o)||e.delete(o);for(const o in t.attributes)s.includes(o)||(t.deleteAttribute(o),t.dispose())}function cr(n,t,e){let s=!1,i=-1;const o=n.attributes,a=t.groupAttributes[0];for(const r in a){const f=t.getTotalLength(r),l=t.getType(r),p=t.getItemSize(r),u=t.getNormalized(r);let d=o[r];(!d||d.array.length<f)&&(d=new Te(new l(f),p,u),n.setAttribute(r,d),s=!0);let A=0;for(let T=0,g=Math.min(e.length,t.groupCount);T<g;T++){const h=e[T].index,{array:y,type:m,length:x}=t.groupAttributes[h][r],w=new m(y.buffer,0,x);d.array.set(w,A),A+=w.length}d.needsUpdate=!0,i=f/d.itemSize}if(n.index){const r=n.index.array;if(r.length<i)n.index=null,s=!0;else for(let f=0,l=r.length;f<l;f++)r[f]=f}let c=0;n.clearGroups();for(let r=0,f=Math.min(e.length,t.groupCount);r<f;r++){const{index:l,materialIndex:p}=e[r],u=t.getCount(l);u!==0&&(n.addGroup(c,u,p),c+=u)}n.setDrawRange(0,i),n.boundsTree=null,s&&n.dispose()}function Xn(n,t){let e=t;return Array.isArray(t)||(e=[],n.forEach(s=>{e[s.materialIndex]=t})),e}class ar{constructor(){this.triangleSplitter=new Gi,this.attributeData=[],this.attributes=["position","uv","normal"],this.useGroups=!0,this.consolidateGroups=!0,this.debug=new nr}getGroupRanges(t){return!this.useGroups||t.groups.length===0?[{start:0,count:1/0,materialIndex:0}]:t.groups.map(e=>({...e}))}evaluate(t,e,s,i=new Ae){let o=!0;if(Array.isArray(s)||(s=[s]),Array.isArray(i)||(i=[i],o=!1),i.length!==s.length)throw new Error("Evaluator: operations and target array passed as different sizes.");t.prepareGeometry(),e.prepareGeometry();const{triangleSplitter:a,attributeData:c,attributes:r,useGroups:f,consolidateGroups:l,debug:p}=this;for(;c.length<i.length;)c.push(new Hi);i.forEach((h,y)=>{or(t.geometry,h.geometry,c[y],r)}),p.init(),ir(t,e,s,a,c,{useGroups:f}),p.complete();const u=this.getGroupRanges(t.geometry),d=Xn(u,t.material),A=this.getGroupRanges(e.geometry),T=Xn(A,e.material);A.forEach(h=>h.materialIndex+=d.length);let g=[...u,...A].map((h,y)=>({...h,index:y}));if(f){const h=[...d,...T];l&&(g=g.map(m=>{const x=h[m.materialIndex];return m.materialIndex=h.indexOf(x),m}).sort((m,x)=>m.materialIndex-x.materialIndex));const y=[];for(let m=0,x=h.length;m<x;m++){let w=!1;for(let S=0,b=g.length;S<b;S++){const P=g[S];P.materialIndex===m&&(w=!0,P.materialIndex=y.length)}w&&y.push(h[m])}i.forEach(m=>{m.material=y})}else g=[{start:0,count:1/0,index:0,materialIndex:0}],i.forEach(h=>{h.material=d[0]});return i.forEach((h,y)=>{const m=h.geometry;cr(m,c[y],g),l&&rr(m.groups)}),o?i:i[0]}evaluateHierarchy(t,e=new Ae){t.updateMatrixWorld(!0);const s=(o,a)=>{const c=o.children;for(let r=0,f=c.length;r<f;r++){const l=c[r];l.isOperationGroup?s(l,a):a(l)}},i=o=>{const a=o.children;let c=!1;for(let f=0,l=a.length;f<l;f++){const p=a[f];c=i(p)||c}const r=o.isDirty();if(r&&o.markUpdated(),c&&!o.isOperationGroup){let f;return s(o,l=>{f?f=this.evaluate(f,l,l.operation):f=this.evaluate(o,l,l.operation)}),o._cachedGeometry=f.geometry,o._cachedMaterials=f.material,!0}else return c||r};return i(t),e.geometry=t._cachedGeometry,e.material=t._cachedMaterials,e}reset(){this.triangleSplitter.reset()}}var Wn=`uniform float uTime;\r
uniform float uPositionFrecuency;\r
uniform float uStrength;\r
uniform float uWarpFrequency;\r
uniform float uWarpStrength;

varying vec3 vPosition;\r
varying float vUpDot;\r
vec3 permute(vec3 x) { return mod(((x*44.0)+1.0)*x, 299.0); }

float simplexNoise2d(vec2 v)
{
    const vec4 C = vec4(0.211324865405187, 0.366025403784439,
            -0.577350269189626, 0.024390243902439);
    vec2 i  = floor(v + dot(v, C.yy) );
    vec2 x0 = v -   i + dot(i, C.xx);
    vec2 i1;
    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
    vec4 x12 = x0.xyxy + C.xxzz;
    x12.xy -= i1;
    i = mod(i, 299.0);
    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
    + i.x + vec3(0.0, i1.x, 1.0 ));
    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),
    dot(x12.zw,x12.zw)), 0.0);
    m = m*m ;
    m = m*m ;
    vec3 x = 2.0 * fract(p * C.www) - 1.0;
    vec3 h = abs(x) - 0.5;
    vec3 ox = floor(x + 0.5);
    vec3 a0 = x - ox;
    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
    vec3 g;
    g.x  = a0.x  * x0.x  + h.x  * x0.y;
    g.yz = a0.yz * x12.xz + h.yz * x12.yw;
    return 130.0 * dot(m, g);
}

float getElevation(vec2 position)\r
{\r
    
    vec2 warpedPosition = position;\r
    warpedPosition += uTime * 0.2;\r
    warpedPosition += simplexNoise2d(warpedPosition * uWarpFrequency * uPositionFrecuency) * uWarpStrength;\r
    \r
    float elevation = 0.0;\r
    elevation += simplexNoise2d(warpedPosition * uPositionFrecuency ) / 2.0;\r
    elevation += simplexNoise2d(warpedPosition * uPositionFrecuency * 2.0) / 4.0;\r
    elevation += simplexNoise2d(warpedPosition * uPositionFrecuency * 4.0) / 8.0;

    
    float sign = sign(elevation);\r
    elevation = pow(abs(elevation), 2.0) * sign;\r
    elevation *= uStrength;\r
    return elevation;\r
}\r
void main(){

    
    float shift = 0.01;\r
    vec3 positionA = position + vec3(shift, 0.0, 0.0);\r
    vec3 positionB = position + vec3(0.0, 0.0, -shift);\r
    \r
    
    float elevation = getElevation(csm_Position.xz);\r
    csm_Position.y += elevation;\r
    positionA.y = getElevation(positionA.xz);\r
    positionB.y = getElevation(positionB.xz);

    
    vec3 toA = normalize(positionA - csm_Position);\r
    vec3 toB = normalize(positionB - csm_Position);\r
    csm_Normal = cross(toA, toB);\r
    vPosition = csm_Position;\r
    vPosition.xz += uTime * 0.2;\r
    vUpDot = dot(csm_Normal, vec3(0.0, 1.0, 0.0));\r
    
}`,lr=`uniform vec3 uColorWaterDeep;\r
uniform vec3 uColorWaterShallow;\r
uniform vec3 uColorSand;\r
uniform vec3 uColorSnow;\r
uniform vec3 uColorGrass;\r
uniform vec3 uColorRock;

varying vec3 vPosition;\r
varying float vUpDot;

vec3 permute(vec3 x) { return mod(((x*44.0)+1.0)*x, 299.0); }

float simplexNoise2d(vec2 v)
{
    const vec4 C = vec4(0.211324865405187, 0.366025403784439,
            -0.577350269189626, 0.024390243902439);
    vec2 i  = floor(v + dot(v, C.yy) );
    vec2 x0 = v -   i + dot(i, C.xx);
    vec2 i1;
    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
    vec4 x12 = x0.xyxy + C.xxzz;
    x12.xy -= i1;
    i = mod(i, 299.0);
    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
    + i.x + vec3(0.0, i1.x, 1.0 ));
    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),
    dot(x12.zw,x12.zw)), 0.0);
    m = m*m ;
    m = m*m ;
    vec3 x = 2.0 * fract(p * C.www) - 1.0;
    vec3 h = abs(x) - 0.5;
    vec3 ox = floor(x + 0.5);
    vec3 a0 = x - ox;
    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
    vec3 g;
    g.x  = a0.x  * x0.x  + h.x  * x0.y;
    g.yz = a0.yz * x12.xz + h.yz * x12.yw;
    return 130.0 * dot(m, g);
}\r
void main(){\r
    
    vec3 color = vec3(1.0);

    
    float surfaceWaterMix = smoothstep(-1.0,  -0.1, vPosition.y);\r
    color = mix(uColorWaterDeep, uColorWaterShallow, surfaceWaterMix);

    
    float sandMix = step(-0.1, vPosition.y);\r
    color = mix(color, uColorSand, sandMix);

    
    float grassMix = step(-0.06, vPosition.y); \r
    color = mix(color, uColorGrass, grassMix);

    
    float rockMix = vUpDot;\r
    
    rockMix =  1.0 - smoothstep(0.8,  0.9,  rockMix);\r
    rockMix *= step(-0.06, vPosition.y); \r
    color = mix(color, uColorRock, rockMix);\r
    \r

     
     float snowThreshold = 0.45;\r
     snowThreshold += simplexNoise2d(vPosition.xz * 15.0) * 0.1;\r
     float snowMix = step(snowThreshold,  vPosition.y);\r
     color = mix(color, uColorSnow, snowMix);

    
    
    

   \r
    csm_DiffuseColor = vec4(color, 1.0);\r
    
}`;function pr(){const n=ds({positionFrecuency:{value:.2,min:0,max:1},strength:{value:2,min:0,max:10},warpFrequency:{value:5,min:0,max:10},warpStrength:{value:.5,min:0,max:1},colorWaterDeep:{value:"#002b3d"},colorWaterShallow:{value:"#66a8ff"},colorSand:{value:"#ffe894"},colorSnow:{value:"#ffffff"},colorGrass:{value:"#85d534"},colorRock:{value:"#525137"}}),t=new Ae(new dn(11,2,11)),e=new Ae(new dn(10,2,10)),i=new ar().evaluate(t,e,is);i.material=new hn({color:new at("#ffffff"),roughness:1,metalness:0}),i.castShadow=!0,i.receiveShadow=!0;const o=new hs(10,10,500,500);o.rotateX(-Math.PI*.5);const a={uTime:new K(0),uPositionFrecuency:new K(n.positionFrecuency),uStrength:new K(n.strength),uWarpFrequency:new K(n.warpFrequency),uWarpStrength:new K(n.warpStrength),uColorWaterDeep:new K(new at(n.colorWaterDeep)),uColorWaterShallow:new K(new at(n.colorWaterShallow)),uColorSand:new K(new at(n.colorSand)),uColorSnow:new K(new at(n.colorSnow)),uColorGrass:new K(new at(n.colorGrass)),uColorRock:new K(new at(n.colorRock))},c=new yn({baseMaterial:new hn,vertexShader:Wn,fragmentShader:lr,silent:!0,uniforms:a,roughness:.5,metalness:0}),r=new yn({baseMaterial:new ys,vertexShader:Wn,uniforms:a,silent:!0,depthPacking:ms});return gs((f,l)=>{a.uTime.value+=l}),gt.jsxs(gt.Fragment,{children:[gt.jsx("primitive",{object:i}),gt.jsx("mesh",{geometry:o,material:c,customDepthMaterial:r,receiveShadow:!0,castShadow:!0}),gt.jsxs("mesh",{position:[0,-.1,0],rotation:[-Math.PI*.5,0,0],children:[gt.jsx("planeGeometry",{args:[10,10,500,500]}),gt.jsx("meshPhysicalMaterial",{color:new at(n.colorWaterShallow),transmission:1,roughness:0})]})]})}export{pr as default};
//# sourceMappingURL=shader-DjgmWVmh.js.map
