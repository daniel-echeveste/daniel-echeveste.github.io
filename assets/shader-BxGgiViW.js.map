{"version":3,"file":"shader-BxGgiViW.js","sources":["../../src/shaders/lightShading/vertex.glsl","../../src/shaders/lightShading/fragment.glsl","../../src/shaders/lightShading/shader.jsx"],"sourcesContent":["varying vec3 vNormal;\r\nvarying vec3 vPosition;\r\n\r\nvoid main()\r\n{\r\n    // Position\r\n    vec4 modelPosition = modelMatrix * vec4(position, 1.0);\r\n    gl_Position = projectionMatrix * viewMatrix * modelPosition;\r\n\r\n    // Model normal\r\n    vec4 modelNormal = modelMatrix * vec4(normal, 0.0);\r\n\r\n    // Varying\r\n    vNormal = modelNormal.xyz;\r\n    vPosition = modelPosition.xyz;\r\n}","uniform vec3 uColor;\r\n\r\nvarying vec3 vNormal;\r\nvarying vec3 vPosition;\r\n\r\n#include ../includes/ambientLight.glsl\r\n#include ../includes/directionalLight.glsl\r\n#include ../includes/pointLight.glsl\r\n\r\nvoid main()\r\n{\r\n    vec3 normal = normalize(vNormal);\r\n    vec3 viewDirection = normalize(vPosition - cameraPosition);\r\n    vec3 viewDirection2 = normalize(cameraPosition - vPosition);\r\n    vec3 color = uColor;\r\n\r\n    // Lights\r\n    vec3 light = vec3(0.0);\r\n\r\n    light += ambientLight(\r\n        vec3(1.0), // Light color\r\n        0.03       // Light intensity\r\n    );\r\n\r\n    light += directionalLight(\r\n        vec3(0.1, 0.1, 1.0), // Light color\r\n        1.0,                 // Light intensity,\r\n        normal,              // Normal\r\n        vec3(0.0, 0.0, 3.0), // Light position\r\n        viewDirection,       // View direction\r\n        20.0                 // Specular power\r\n    );\r\n\r\n    light += pointLight(\r\n        vec3(1.0, 0.1, 0.1), // Light color\r\n        1.0,                 // Light intensity,\r\n        normal,              // Normal\r\n        vec3(0.0, 2.5, 0.0), // Light position\r\n        viewDirection,       // View direction\r\n        20.0,                // Specular power\r\n        vPosition,           // Position\r\n        0.25                 // Light decay\r\n    );\r\n\r\n    light += pointLight(\r\n        vec3(0.1, 1.0, 0.5), // Light color\r\n        1.0,                 // Light intensity,\r\n        normal,              // Normal\r\n        vec3(2.0, 0.0, 2.0), // Light position\r\n        viewDirection,       // View direction\r\n        20.0,                // Specular power\r\n        vPosition,           // Position\r\n        0.2                  // Light decay\r\n    );\r\n\r\n    color *= light;\r\n\r\n    // Final color\r\n    gl_FragColor = vec4(color, 1.0);\r\n    #include <tonemapping_fragment>\r\n    #include <colorspace_fragment>\r\n}","import * as THREE from \"three\";\r\nimport vertexShader from \"./vertex.glsl\";\r\nimport fragmentShader from \"./fragment.glsl\";\r\nimport { useRef } from \"react\";\r\nimport { useFrame } from \"@react-three/fiber\";\r\nexport default function LightShading() {\r\n\r\n    const cubeRef = useRef();\r\n    const torusKnotRef = useRef();\r\n    const sphereRef = useRef();\r\n    \r\n    useFrame((state, delta) => {\r\n        if(cubeRef.current){\r\n            cubeRef.current.rotation.x += delta *0.3;\r\n            cubeRef.current.rotation.y += delta *0.3;\r\n        }\r\n        if(torusKnotRef.current){\r\n            torusKnotRef.current.rotation.x += delta *0.3;\r\n            torusKnotRef.current.rotation.y += delta *0.3;\r\n        }\r\n        if(sphereRef.current){\r\n            sphereRef.current.rotation.x += delta *0.3;\r\n            sphereRef.current.rotation.y += delta *0.3;\r\n        }\r\n    })\r\n\r\n    return <>\r\n    {/* sphere */}\r\n    <mesh ref={sphereRef} position={[-3, 0, 0]}>\r\n        <sphereGeometry />\r\n        <shaderMaterial vertexShader={vertexShader} fragmentShader={fragmentShader} uniforms={\r\n            {\r\n                uColor: {value: new THREE.Color(\"white\")}\r\n            }\r\n        } />\r\n    </mesh>\r\n    {/* torus knot */}\r\n    <mesh ref={torusKnotRef} position={[3, 0, 0]}>\r\n        <torusKnotGeometry  args={[1, 0.4, 128, 128]}/>\r\n        <shaderMaterial vertexShader={vertexShader} fragmentShader={fragmentShader} uniforms={\r\n            {\r\n                uColor: {value: new THREE.Color(\"white\")}\r\n            }\r\n        } />\r\n    </mesh>\r\n    {/* box */}\r\n    <mesh ref={cubeRef} position={[0, 0, 0]}>\r\n        <boxGeometry />\r\n        <shaderMaterial vertexShader={vertexShader} fragmentShader={fragmentShader} uniforms={\r\n            {\r\n                uColor: {value: new THREE.Color(\"white\")}\r\n            }\r\n        } />\r\n    </mesh>\r\n\r\n    {/* directonal light helper */}\r\n    <mesh position={[0, 0, 3]}>\r\n        <planeGeometry />\r\n        <meshBasicMaterial color={new THREE.Color(0.1, 0.1, 1.0)} side={THREE.DoubleSide} />\r\n    </mesh>\r\n    {/* point Light helper */}\r\n    <mesh position={[0, 2, 0]} scale={0.2}>\r\n        <sphereGeometry />\r\n        <meshBasicMaterial color={new THREE.Color(1.0, 0.1, 0.1)} />\r\n    </mesh>\r\n    {/* spot Light helper */}\r\n    <mesh position={[2, 0, 2]} scale={0.2}>\r\n        <sphereGeometry />\r\n        <meshBasicMaterial color={new THREE.Color(0.1, 1.0, 0.5)} />\r\n    </mesh>\r\n     <ambientLight intensity={0.5}></ambientLight>\r\n      <directionalLight\r\n        castShadow\r\n        position={[4, 2, -2.25]}\r\n        intensity={10}\r\n      ></directionalLight>\r\n      <pointLight position={[0,3,0]} color=\"red\" intensity={10}></pointLight>\r\n    </>\r\n}"],"names":["vertex_default","fragment_default","LightShading","cubeRef","useRef","torusKnotRef","sphereRef","useFrame","state","delta","jsxs","Fragment","jsx","vertexShader","fragmentShader","THREE.Color","THREE.DoubleSide"],"mappings":"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"}