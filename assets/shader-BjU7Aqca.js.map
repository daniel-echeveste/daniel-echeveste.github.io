{"version":3,"file":"shader-BjU7Aqca.js","sources":["../../node_modules/three-mesh-bvh/src/core/Constants.js","../../node_modules/three-mesh-bvh/src/core/build/geometryUtils.js","../../node_modules/three-mesh-bvh/src/core/build/computeBoundsUtils.js","../../node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js","../../node_modules/three-mesh-bvh/src/core/build/splitUtils.js","../../node_modules/three-mesh-bvh/src/core/MeshBVHNode.js","../../node_modules/three-mesh-bvh/src/core/build/sortUtils.generated.js","../../node_modules/three-mesh-bvh/src/core/build/sortUtils_indirect.generated.js","../../node_modules/three-mesh-bvh/src/core/utils/nodeBufferUtils.js","../../node_modules/three-mesh-bvh/src/core/build/buildUtils.js","../../node_modules/three-mesh-bvh/src/core/build/buildTree.js","../../node_modules/three-mesh-bvh/src/math/SeparatingAxisBounds.js","../../node_modules/three-mesh-bvh/src/math/MathUtilities.js","../../node_modules/three-mesh-bvh/src/math/ExtendedTriangle.js","../../node_modules/three-mesh-bvh/src/math/OrientedBox.js","../../node_modules/three-mesh-bvh/src/utils/PrimitivePool.js","../../node_modules/three-mesh-bvh/src/utils/ExtendedTrianglePool.js","../../node_modules/three-mesh-bvh/src/core/utils/BufferStack.js","../../node_modules/three-mesh-bvh/src/core/cast/shapecast.js","../../node_modules/three-mesh-bvh/src/core/cast/closestPointToPoint.js","../../node_modules/three-mesh-bvh/src/utils/ThreeRayIntersectUtilities.js","../../node_modules/three-mesh-bvh/src/utils/TriangleUtilities.js","../../node_modules/three-mesh-bvh/src/core/utils/iterationUtils.generated.js","../../node_modules/three-mesh-bvh/src/core/cast/refit.generated.js","../../node_modules/three-mesh-bvh/src/core/utils/intersectUtils.js","../../node_modules/three-mesh-bvh/src/core/utils/iterationUtils_indirect.generated.js","../../node_modules/three-mesh-bvh/src/core/cast/raycast.generated.js","../../node_modules/three-mesh-bvh/src/core/cast/raycastFirst.generated.js","../../node_modules/three-mesh-bvh/src/core/cast/intersectsGeometry.generated.js","../../node_modules/three-mesh-bvh/src/core/cast/closestPointToGeometry.generated.js","../../node_modules/three-mesh-bvh/src/core/cast/refit_indirect.generated.js","../../node_modules/three-mesh-bvh/src/core/cast/raycast_indirect.generated.js","../../node_modules/three-mesh-bvh/src/core/cast/raycastFirst_indirect.generated.js","../../node_modules/three-mesh-bvh/src/core/cast/intersectsGeometry_indirect.generated.js","../../node_modules/three-mesh-bvh/src/core/cast/closestPointToGeometry_indirect.generated.js","../../node_modules/three-mesh-bvh/src/utils/BufferUtils.js","../../node_modules/three-mesh-bvh/src/core/cast/bvhcast.js","../../node_modules/three-mesh-bvh/src/core/MeshBVH.js","../../node_modules/three-bvh-csg/src/core/utils/hashUtils.js","../../node_modules/three-bvh-csg/src/core/utils/geometryUtils.js","../../node_modules/three-bvh-csg/src/core/utils/halfEdgeUtils.js","../../node_modules/three-bvh-csg/src/core/utils/RaySet.js","../../node_modules/three-bvh-csg/src/core/utils/computeDisjointEdges.js","../../node_modules/three-bvh-csg/src/core/HalfEdgeMap.js","../../node_modules/three-bvh-csg/src/core/Brush.js","../../node_modules/three-bvh-csg/src/core/utils/triangleUtils.js","../../node_modules/three-bvh-csg/src/core/TriangleSplitter.js","../../node_modules/three-bvh-csg/src/core/TypeBackedArray.js","../../node_modules/three-bvh-csg/src/core/TypedAttributeData.js","../../node_modules/three-bvh-csg/src/core/IntersectionMap.js","../../node_modules/three-bvh-csg/src/core/constants.js","../../node_modules/three-bvh-csg/src/core/operations/operationsUtils.js","../../node_modules/three-bvh-csg/src/core/debug/OperationDebugData.js","../../node_modules/three-bvh-csg/src/core/operations/operations.js","../../node_modules/three-bvh-csg/src/core/Evaluator.js","../../src/shaders/proceduralTerrain/vertex.glsl","../../src/shaders/proceduralTerrain/fragment.glsl","../../src/shaders/proceduralTerrain/shader.jsx"],"sourcesContent":["// Split strategy constants\nexport const CENTER = 0;\nexport const AVERAGE = 1;\nexport const SAH = 2;\n\n// Traversal constants\nexport const NOT_INTERSECTED = 0;\nexport const INTERSECTED = 1;\nexport const CONTAINED = 2;\n\n// SAH cost constants\n// TODO: hone these costs more. The relative difference between them should be the\n// difference in measured time to perform a triangle intersection vs traversing\n// bounds.\nexport const TRIANGLE_INTERSECT_COST = 1.25;\nexport const TRAVERSAL_COST = 1;\n\n\n// Build constants\nexport const BYTES_PER_NODE = 6 * 4 + 4 + 4;\nexport const IS_LEAFNODE_FLAG = 0xFFFF;\n\n// EPSILON for computing floating point error during build\n// https://en.wikipedia.org/wiki/Machine_epsilon#Values_for_standard_hardware_floating_point_arithmetics\nexport const FLOAT32_EPSILON = Math.pow( 2, - 24 );\n\nexport const SKIP_GENERATION = Symbol( 'SKIP_GENERATION' );\n","import { BufferAttribute } from 'three';\n\nexport function getVertexCount( geo ) {\n\n\treturn geo.index ? geo.index.count : geo.attributes.position.count;\n\n}\n\nexport function getTriCount( geo ) {\n\n\treturn getVertexCount( geo ) / 3;\n\n}\n\nexport function getIndexArray( vertexCount, BufferConstructor = ArrayBuffer ) {\n\n\tif ( vertexCount > 65535 ) {\n\n\t\treturn new Uint32Array( new BufferConstructor( 4 * vertexCount ) );\n\n\t} else {\n\n\t\treturn new Uint16Array( new BufferConstructor( 2 * vertexCount ) );\n\n\t}\n\n}\n\n// ensures that an index is present on the geometry\nexport function ensureIndex( geo, options ) {\n\n\tif ( ! geo.index ) {\n\n\t\tconst vertexCount = geo.attributes.position.count;\n\t\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\t\tconst index = getIndexArray( vertexCount, BufferConstructor );\n\t\tgeo.setIndex( new BufferAttribute( index, 1 ) );\n\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\tindex[ i ] = i;\n\n\t\t}\n\n\t}\n\n}\n\n// Computes the set of { offset, count } ranges which need independent BVH roots. Each\n// region in the geometry index that belongs to a different set of material groups requires\n// a separate BVH root, so that triangles indices belonging to one group never get swapped\n// with triangle indices belongs to another group. For example, if the groups were like this:\n//\n// [-------------------------------------------------------------]\n// |__________________|\n//   g0 = [0, 20]  |______________________||_____________________|\n//                      g1 = [16, 40]           g2 = [41, 60]\n//\n// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\nexport function getFullGeometryRange( geo, range ) {\n\n\tconst triCount = getTriCount( geo );\n\tconst drawRange = range ? range : geo.drawRange;\n\tconst start = drawRange.start / 3;\n\tconst end = ( drawRange.start + drawRange.count ) / 3;\n\n\tconst offset = Math.max( 0, start );\n\tconst count = Math.min( triCount, end ) - offset;\n\treturn [ {\n\t\toffset: Math.floor( offset ),\n\t\tcount: Math.floor( count ),\n\t} ];\n\n}\n\nexport function getRootIndexRanges( geo, range ) {\n\n\tif ( ! geo.groups || ! geo.groups.length ) {\n\n\t\treturn getFullGeometryRange( geo, range );\n\n\t}\n\n\tconst ranges = [];\n\tconst rangeBoundaries = new Set();\n\n\tconst drawRange = range ? range : geo.drawRange;\n\tconst drawRangeStart = drawRange.start / 3;\n\tconst drawRangeEnd = ( drawRange.start + drawRange.count ) / 3;\n\tfor ( const group of geo.groups ) {\n\n\t\tconst groupStart = group.start / 3;\n\t\tconst groupEnd = ( group.start + group.count ) / 3;\n\t\trangeBoundaries.add( Math.max( drawRangeStart, groupStart ) );\n\t\trangeBoundaries.add( Math.min( drawRangeEnd, groupEnd ) );\n\n\t}\n\n\n\t// note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\n\tconst sortedBoundaries = Array.from( rangeBoundaries.values() ).sort( ( a, b ) => a - b );\n\tfor ( let i = 0; i < sortedBoundaries.length - 1; i ++ ) {\n\n\t\tconst start = sortedBoundaries[ i ];\n\t\tconst end = sortedBoundaries[ i + 1 ];\n\n\t\tranges.push( {\n\t\t\toffset: Math.floor( start ),\n\t\t\tcount: Math.floor( end - start ),\n\t\t} );\n\n\t}\n\n\treturn ranges;\n\n}\n\nexport function hasGroupGaps( geometry, range ) {\n\n\tconst vertexCount = getTriCount( geometry );\n\tconst groups = getRootIndexRanges( geometry, range )\n\t\t.sort( ( a, b ) => a.offset - b.offset );\n\n\tconst finalGroup = groups[ groups.length - 1 ];\n\tfinalGroup.count = Math.min( vertexCount - finalGroup.offset, finalGroup.count );\n\n\tlet total = 0;\n\tgroups.forEach( ( { count } ) => total += count );\n\treturn vertexCount !== total;\n\n}\n","import { FLOAT32_EPSILON } from '../Constants.js';\nimport { getTriCount } from './geometryUtils.js';\n\n// computes the union of the bounds of all of the given triangles and puts the resulting box in \"target\".\n// A bounding box is computed for the centroids of the triangles, as well, and placed in \"centroidTarget\".\n// These are computed together to avoid redundant accesses to bounds array.\nexport function getBounds( triangleBounds, offset, count, target, centroidTarget ) {\n\n\tlet minx = Infinity;\n\tlet miny = Infinity;\n\tlet minz = Infinity;\n\tlet maxx = - Infinity;\n\tlet maxy = - Infinity;\n\tlet maxz = - Infinity;\n\n\tlet cminx = Infinity;\n\tlet cminy = Infinity;\n\tlet cminz = Infinity;\n\tlet cmaxx = - Infinity;\n\tlet cmaxy = - Infinity;\n\tlet cmaxz = - Infinity;\n\n\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\n\n\t\tconst cx = triangleBounds[ i + 0 ];\n\t\tconst hx = triangleBounds[ i + 1 ];\n\t\tconst lx = cx - hx;\n\t\tconst rx = cx + hx;\n\t\tif ( lx < minx ) minx = lx;\n\t\tif ( rx > maxx ) maxx = rx;\n\t\tif ( cx < cminx ) cminx = cx;\n\t\tif ( cx > cmaxx ) cmaxx = cx;\n\n\t\tconst cy = triangleBounds[ i + 2 ];\n\t\tconst hy = triangleBounds[ i + 3 ];\n\t\tconst ly = cy - hy;\n\t\tconst ry = cy + hy;\n\t\tif ( ly < miny ) miny = ly;\n\t\tif ( ry > maxy ) maxy = ry;\n\t\tif ( cy < cminy ) cminy = cy;\n\t\tif ( cy > cmaxy ) cmaxy = cy;\n\n\t\tconst cz = triangleBounds[ i + 4 ];\n\t\tconst hz = triangleBounds[ i + 5 ];\n\t\tconst lz = cz - hz;\n\t\tconst rz = cz + hz;\n\t\tif ( lz < minz ) minz = lz;\n\t\tif ( rz > maxz ) maxz = rz;\n\t\tif ( cz < cminz ) cminz = cz;\n\t\tif ( cz > cmaxz ) cmaxz = cz;\n\n\t}\n\n\ttarget[ 0 ] = minx;\n\ttarget[ 1 ] = miny;\n\ttarget[ 2 ] = minz;\n\n\ttarget[ 3 ] = maxx;\n\ttarget[ 4 ] = maxy;\n\ttarget[ 5 ] = maxz;\n\n\tcentroidTarget[ 0 ] = cminx;\n\tcentroidTarget[ 1 ] = cminy;\n\tcentroidTarget[ 2 ] = cminz;\n\n\tcentroidTarget[ 3 ] = cmaxx;\n\tcentroidTarget[ 4 ] = cmaxy;\n\tcentroidTarget[ 5 ] = cmaxz;\n\n}\n\n// precomputes the bounding box for each triangle; required for quickly calculating tree splits.\n// result is an array of size tris.length * 6 where triangle i maps to a\n// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index i * 6,\n// representing the center and half-extent in each dimension of triangle i\nexport function computeTriangleBounds( geo, target = null, offset = null, count = null ) {\n\n\tconst posAttr = geo.attributes.position;\n\tconst index = geo.index ? geo.index.array : null;\n\tconst triCount = getTriCount( geo );\n\tconst normalized = posAttr.normalized;\n\tlet triangleBounds;\n\tif ( target === null ) {\n\n\t\ttriangleBounds = new Float32Array( triCount * 6 * 4 );\n\t\toffset = 0;\n\t\tcount = triCount;\n\n\t} else {\n\n\t\ttriangleBounds = target;\n\t\toffset = offset || 0;\n\t\tcount = count || triCount;\n\n\t}\n\n\t// used for non-normalized positions\n\tconst posArr = posAttr.array;\n\n\t// support for an interleaved position buffer\n\tconst bufferOffset = posAttr.offset || 0;\n\tlet stride = 3;\n\tif ( posAttr.isInterleavedBufferAttribute ) {\n\n\t\tstride = posAttr.data.stride;\n\n\t}\n\n\t// used for normalized positions\n\tconst getters = [ 'getX', 'getY', 'getZ' ];\n\n\tfor ( let tri = offset; tri < offset + count; tri ++ ) {\n\n\t\tconst tri3 = tri * 3;\n\t\tconst tri6 = tri * 6;\n\n\t\tlet ai = tri3 + 0;\n\t\tlet bi = tri3 + 1;\n\t\tlet ci = tri3 + 2;\n\n\t\tif ( index ) {\n\n\t\t\tai = index[ ai ];\n\t\t\tbi = index[ bi ];\n\t\t\tci = index[ ci ];\n\n\t\t}\n\n\t\t// we add the stride and offset here since we access the array directly\n\t\t// below for the sake of performance\n\t\tif ( ! normalized ) {\n\n\t\t\tai = ai * stride + bufferOffset;\n\t\t\tbi = bi * stride + bufferOffset;\n\t\t\tci = ci * stride + bufferOffset;\n\n\t\t}\n\n\t\tfor ( let el = 0; el < 3; el ++ ) {\n\n\t\t\tlet a, b, c;\n\n\t\t\tif ( normalized ) {\n\n\t\t\t\ta = posAttr[ getters[ el ] ]( ai );\n\t\t\t\tb = posAttr[ getters[ el ] ]( bi );\n\t\t\t\tc = posAttr[ getters[ el ] ]( ci );\n\n\t\t\t} else {\n\n\t\t\t\ta = posArr[ ai + el ];\n\t\t\t\tb = posArr[ bi + el ];\n\t\t\t\tc = posArr[ ci + el ];\n\n\t\t\t}\n\n\t\t\tlet min = a;\n\t\t\tif ( b < min ) min = b;\n\t\t\tif ( c < min ) min = c;\n\n\t\t\tlet max = a;\n\t\t\tif ( b > max ) max = b;\n\t\t\tif ( c > max ) max = c;\n\n\t\t\t// Increase the bounds size by float32 epsilon to avoid precision errors when\n\t\t\t// converting to 32 bit float. Scale the epsilon by the size of the numbers being\n\t\t\t// worked with.\n\t\t\tconst halfExtents = ( max - min ) / 2;\n\t\t\tconst el2 = el * 2;\n\t\t\ttriangleBounds[ tri6 + el2 + 0 ] = min + halfExtents;\n\t\t\ttriangleBounds[ tri6 + el2 + 1 ] = halfExtents + ( Math.abs( min ) + halfExtents ) * FLOAT32_EPSILON;\n\n\t\t}\n\n\t}\n\n\treturn triangleBounds;\n\n}\n","export function arrayToBox( nodeIndex32, array, target ) {\n\n\ttarget.min.x = array[ nodeIndex32 ];\n\ttarget.min.y = array[ nodeIndex32 + 1 ];\n\ttarget.min.z = array[ nodeIndex32 + 2 ];\n\n\ttarget.max.x = array[ nodeIndex32 + 3 ];\n\ttarget.max.y = array[ nodeIndex32 + 4 ];\n\ttarget.max.z = array[ nodeIndex32 + 5 ];\n\n\treturn target;\n\n}\n\nexport function makeEmptyBounds( target ) {\n\n\ttarget[ 0 ] = target[ 1 ] = target[ 2 ] = Infinity;\n\ttarget[ 3 ] = target[ 4 ] = target[ 5 ] = - Infinity;\n\n}\n\nexport function getLongestEdgeIndex( bounds ) {\n\n\tlet splitDimIdx = - 1;\n\tlet splitDist = - Infinity;\n\n\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\tconst dist = bounds[ i + 3 ] - bounds[ i ];\n\t\tif ( dist > splitDist ) {\n\n\t\t\tsplitDist = dist;\n\t\t\tsplitDimIdx = i;\n\n\t\t}\n\n\t}\n\n\treturn splitDimIdx;\n\n}\n\n// copies bounds a into bounds b\nexport function copyBounds( source, target ) {\n\n\ttarget.set( source );\n\n}\n\n// sets bounds target to the union of bounds a and b\nexport function unionBounds( a, b, target ) {\n\n\tlet aVal, bVal;\n\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\tconst d3 = d + 3;\n\n\t\t// set the minimum values\n\t\taVal = a[ d ];\n\t\tbVal = b[ d ];\n\t\ttarget[ d ] = aVal < bVal ? aVal : bVal;\n\n\t\t// set the max values\n\t\taVal = a[ d3 ];\n\t\tbVal = b[ d3 ];\n\t\ttarget[ d3 ] = aVal > bVal ? aVal : bVal;\n\n\t}\n\n}\n\n// expands the given bounds by the provided triangle bounds\nexport function expandByTriangleBounds( startIndex, triangleBounds, bounds ) {\n\n\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\tconst tCenter = triangleBounds[ startIndex + 2 * d ];\n\t\tconst tHalf = triangleBounds[ startIndex + 2 * d + 1 ];\n\n\t\tconst tMin = tCenter - tHalf;\n\t\tconst tMax = tCenter + tHalf;\n\n\t\tif ( tMin < bounds[ d ] ) {\n\n\t\t\tbounds[ d ] = tMin;\n\n\t\t}\n\n\t\tif ( tMax > bounds[ d + 3 ] ) {\n\n\t\t\tbounds[ d + 3 ] = tMax;\n\n\t\t}\n\n\t}\n\n}\n\n// compute bounds surface area\nexport function computeSurfaceArea( bounds ) {\n\n\tconst d0 = bounds[ 3 ] - bounds[ 0 ];\n\tconst d1 = bounds[ 4 ] - bounds[ 1 ];\n\tconst d2 = bounds[ 5 ] - bounds[ 2 ];\n\n\treturn 2 * ( d0 * d1 + d1 * d2 + d2 * d0 );\n\n}\n","import { getLongestEdgeIndex, computeSurfaceArea, copyBounds, unionBounds, expandByTriangleBounds } from '../../utils/ArrayBoxUtilities.js';\nimport { CENTER, AVERAGE, SAH, TRIANGLE_INTERSECT_COST, TRAVERSAL_COST } from '../Constants.js';\n\nconst BIN_COUNT = 32;\nconst binsSort = ( a, b ) => a.candidate - b.candidate;\nconst sahBins = new Array( BIN_COUNT ).fill().map( () => {\n\n\treturn {\n\n\t\tcount: 0,\n\t\tbounds: new Float32Array( 6 ),\n\t\trightCacheBounds: new Float32Array( 6 ),\n\t\tleftCacheBounds: new Float32Array( 6 ),\n\t\tcandidate: 0,\n\n\t};\n\n} );\nconst leftBounds = new Float32Array( 6 );\n\nexport function getOptimalSplit( nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy ) {\n\n\tlet axis = - 1;\n\tlet pos = 0;\n\n\t// Center\n\tif ( strategy === CENTER ) {\n\n\t\taxis = getLongestEdgeIndex( centroidBoundingData );\n\t\tif ( axis !== - 1 ) {\n\n\t\t\tpos = ( centroidBoundingData[ axis ] + centroidBoundingData[ axis + 3 ] ) / 2;\n\n\t\t}\n\n\t} else if ( strategy === AVERAGE ) {\n\n\t\taxis = getLongestEdgeIndex( nodeBoundingData );\n\t\tif ( axis !== - 1 ) {\n\n\t\t\tpos = getAverage( triangleBounds, offset, count, axis );\n\n\t\t}\n\n\t} else if ( strategy === SAH ) {\n\n\t\tconst rootSurfaceArea = computeSurfaceArea( nodeBoundingData );\n\t\tlet bestCost = TRIANGLE_INTERSECT_COST * count;\n\n\t\t// iterate over all axes\n\t\tconst cStart = offset * 6;\n\t\tconst cEnd = ( offset + count ) * 6;\n\t\tfor ( let a = 0; a < 3; a ++ ) {\n\n\t\t\tconst axisLeft = centroidBoundingData[ a ];\n\t\t\tconst axisRight = centroidBoundingData[ a + 3 ];\n\t\t\tconst axisLength = axisRight - axisLeft;\n\t\t\tconst binWidth = axisLength / BIN_COUNT;\n\n\t\t\t// If we have fewer triangles than we're planning to split then just check all\n\t\t\t// the triangle positions because it will be faster.\n\t\t\tif ( count < BIN_COUNT / 4 ) {\n\n\t\t\t\t// initialize the bin candidates\n\t\t\t\tconst truncatedBins = [ ...sahBins ];\n\t\t\t\ttruncatedBins.length = count;\n\n\t\t\t\t// set the candidates\n\t\t\t\tlet b = 0;\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6, b ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ b ];\n\t\t\t\t\tbin.candidate = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tbin.count = 0;\n\n\t\t\t\t\tconst {\n\t\t\t\t\t\tbounds,\n\t\t\t\t\t\tleftCacheBounds,\n\t\t\t\t\t\trightCacheBounds,\n\t\t\t\t\t} = bin;\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\trightCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\trightCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\tleftCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\tleftCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t}\n\n\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bounds );\n\n\t\t\t\t}\n\n\t\t\t\ttruncatedBins.sort( binsSort );\n\n\t\t\t\t// remove redundant splits\n\t\t\t\tlet splitCount = count;\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\twhile ( bi + 1 < splitCount && truncatedBins[ bi + 1 ].candidate === bin.candidate ) {\n\n\t\t\t\t\t\ttruncatedBins.splice( bi + 1, 1 );\n\t\t\t\t\t\tsplitCount --;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// find the appropriate bin for each triangle and expand the bounds.\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\tconst center = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\t\tif ( center >= bin.candidate ) {\n\n\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.rightCacheBounds );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.leftCacheBounds );\n\t\t\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// expand all the bounds\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\tconst leftCount = bin.count;\n\t\t\t\t\tconst rightCount = count - bin.count;\n\n\t\t\t\t\t// check the cost of this split\n\t\t\t\t\tconst leftBounds = bin.leftCacheBounds;\n\t\t\t\t\tconst rightBounds = bin.rightCacheBounds;\n\n\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet rightProb = 0;\n\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// reset the bins\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT; i ++ ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tbin.count = 0;\n\t\t\t\t\tbin.candidate = axisLeft + binWidth + i * binWidth;\n\n\t\t\t\t\tconst bounds = bin.bounds;\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// iterate over all center positions\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\tconst triCenter = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tconst relativeCenter = triCenter - axisLeft;\n\n\t\t\t\t\t// in the partition function if the centroid lies on the split plane then it is\n\t\t\t\t\t// considered to be on the right side of the split\n\t\t\t\t\tlet binIndex = ~ ~ ( relativeCenter / binWidth );\n\t\t\t\t\tif ( binIndex >= BIN_COUNT ) binIndex = BIN_COUNT - 1;\n\n\t\t\t\t\tconst bin = sahBins[ binIndex ];\n\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.bounds );\n\n\t\t\t\t}\n\n\t\t\t\t// cache the unioned bounds from right to left so we don't have to regenerate them each time\n\t\t\t\tconst lastBin = sahBins[ BIN_COUNT - 1 ];\n\t\t\t\tcopyBounds( lastBin.bounds, lastBin.rightCacheBounds );\n\t\t\t\tfor ( let i = BIN_COUNT - 2; i >= 0; i -- ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\tunionBounds( bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds );\n\n\t\t\t\t}\n\n\t\t\t\tlet leftCount = 0;\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT - 1; i ++ ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tconst binCount = bin.count;\n\t\t\t\t\tconst bounds = bin.bounds;\n\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\tconst rightBounds = nextBin.rightCacheBounds;\n\n\t\t\t\t\t// don't do anything with the bounds if the new bounds have no triangles\n\t\t\t\t\tif ( binCount !== 0 ) {\n\n\t\t\t\t\t\tif ( leftCount === 0 ) {\n\n\t\t\t\t\t\t\tcopyBounds( bounds, leftBounds );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tunionBounds( bounds, leftBounds, leftBounds );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tleftCount += binCount;\n\n\t\t\t\t\t// check the cost of this split\n\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\tlet rightProb = 0;\n\n\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst rightCount = count - leftCount;\n\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\tconsole.warn( `MeshBVH: Invalid build strategy value ${ strategy } used.` );\n\n\t}\n\n\treturn { axis, pos };\n\n}\n\n// returns the average coordinate on the specified axis of the all the provided triangles\nfunction getAverage( triangleBounds, offset, count, axis ) {\n\n\tlet avg = 0;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tavg += triangleBounds[ i * 6 + axis * 2 ];\n\n\t}\n\n\treturn avg / count;\n\n}\n","export class MeshBVHNode {\n\n\tconstructor() {\n\n\t\t// internal nodes have boundingData, left, right, and splitAxis\n\t\t// leaf nodes have offset and count (referring to primitives in the mesh geometry)\n\n\t\tthis.boundingData = new Float32Array( 6 );\n\n\t}\n\n}\n","/********************************************************/\n/* This file is generated from \"sortUtils.template.js\". */\n/********************************************************/\n// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\nfunction partition( indirectBuffer, index, triangleBounds, offset, count, split ) {\n\n\tlet left = offset;\n\tlet right = offset + count - 1;\n\tconst pos = split.pos;\n\tconst axisOffset = split.axis * 2;\n\n\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n\twhile ( true ) {\n\n\t\twhile ( left <= right && triangleBounds[ left * 6 + axisOffset ] < pos ) {\n\n\t\t\tleft ++;\n\n\t\t}\n\n\t\t// if a triangle center lies on the partition plane it is considered to be on the right side\n\t\twhile ( left <= right && triangleBounds[ right * 6 + axisOffset ] >= pos ) {\n\n\t\t\tright --;\n\n\t\t}\n\n\t\tif ( left < right ) {\n\n\t\t\t// we need to swap all of the information associated with the triangles at index\n\t\t\t// left and right; that's the verts in the geometry index, the bounds,\n\t\t\t// and perhaps the SAH planes\n\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tlet t0 = index[ left * 3 + i ];\n\t\t\t\tindex[ left * 3 + i ] = index[ right * 3 + i ];\n\t\t\t\tindex[ right * 3 + i ] = t0;\n\n\t\t\t}\n\n\n\t\t\t// swap bounds\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tlet tb = triangleBounds[ left * 6 + i ];\n\t\t\t\ttriangleBounds[ left * 6 + i ] = triangleBounds[ right * 6 + i ];\n\t\t\t\ttriangleBounds[ right * 6 + i ] = tb;\n\n\t\t\t}\n\n\t\t\tleft ++;\n\t\t\tright --;\n\n\t\t} else {\n\n\t\t\treturn left;\n\n\t\t}\n\n\t}\n\n}\n\nexport { partition };\n","/********************************************************/\n/* This file is generated from \"sortUtils.template.js\". */\n/********************************************************/\n// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\nfunction partition_indirect( indirectBuffer, index, triangleBounds, offset, count, split ) {\n\n\tlet left = offset;\n\tlet right = offset + count - 1;\n\tconst pos = split.pos;\n\tconst axisOffset = split.axis * 2;\n\n\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n\twhile ( true ) {\n\n\t\twhile ( left <= right && triangleBounds[ left * 6 + axisOffset ] < pos ) {\n\n\t\t\tleft ++;\n\n\t\t}\n\n\t\t// if a triangle center lies on the partition plane it is considered to be on the right side\n\t\twhile ( left <= right && triangleBounds[ right * 6 + axisOffset ] >= pos ) {\n\n\t\t\tright --;\n\n\t\t}\n\n\t\tif ( left < right ) {\n\n\t\t\t// we need to swap all of the information associated with the triangles at index\n\t\t\t// left and right; that's the verts in the geometry index, the bounds,\n\t\t\t// and perhaps the SAH planes\n\t\t\tlet t = indirectBuffer[ left ];\n\t\t\tindirectBuffer[ left ] = indirectBuffer[ right ];\n\t\t\tindirectBuffer[ right ] = t;\n\n\n\t\t\t// swap bounds\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tlet tb = triangleBounds[ left * 6 + i ];\n\t\t\t\ttriangleBounds[ left * 6 + i ] = triangleBounds[ right * 6 + i ];\n\t\t\t\ttriangleBounds[ right * 6 + i ] = tb;\n\n\t\t\t}\n\n\t\t\tleft ++;\n\t\t\tright --;\n\n\t\t} else {\n\n\t\t\treturn left;\n\n\t\t}\n\n\t}\n\n}\n\nexport { partition_indirect };\n","export function IS_LEAF( n16, uint16Array ) {\n\n\treturn uint16Array[ n16 + 15 ] === 0xFFFF;\n\n}\n\nexport function OFFSET( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 6 ];\n\n}\n\nexport function COUNT( n16, uint16Array ) {\n\n\treturn uint16Array[ n16 + 14 ];\n\n}\n\nexport function LEFT_NODE( n32 ) {\n\n\treturn n32 + 8;\n\n}\n\nexport function RIGHT_NODE( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 6 ];\n\n}\n\nexport function SPLIT_AXIS( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 7 ];\n\n}\n\nexport function BOUNDING_DATA_INDEX( n32 ) {\n\n\treturn n32;\n\n}\n","import { BYTES_PER_NODE, IS_LEAFNODE_FLAG } from '../Constants.js';\nimport { IS_LEAF } from '../utils/nodeBufferUtils.js';\n\nlet float32Array, uint32Array, uint16Array, uint8Array;\nconst MAX_POINTER = Math.pow( 2, 32 );\n\nexport function countNodes( node ) {\n\n\tif ( 'count' in node ) {\n\n\t\treturn 1;\n\n\t} else {\n\n\t\treturn 1 + countNodes( node.left ) + countNodes( node.right );\n\n\t}\n\n}\n\nexport function populateBuffer( byteOffset, node, buffer ) {\n\n\tfloat32Array = new Float32Array( buffer );\n\tuint32Array = new Uint32Array( buffer );\n\tuint16Array = new Uint16Array( buffer );\n\tuint8Array = new Uint8Array( buffer );\n\n\treturn _populateBuffer( byteOffset, node );\n\n}\n\n// pack structure\n// boundingData  \t\t\t\t: 6 float32\n// right / offset \t\t\t\t: 1 uint32\n// splitAxis / isLeaf + count \t: 1 uint32 / 2 uint16\nfunction _populateBuffer( byteOffset, node ) {\n\n\tconst stride4Offset = byteOffset / 4;\n\tconst stride2Offset = byteOffset / 2;\n\tconst isLeaf = 'count' in node;\n\tconst boundingData = node.boundingData;\n\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\tfloat32Array[ stride4Offset + i ] = boundingData[ i ];\n\n\t}\n\n\tif ( isLeaf ) {\n\n\t\tif ( node.buffer ) {\n\n\t\t\tconst buffer = node.buffer;\n\t\t\tuint8Array.set( new Uint8Array( buffer ), byteOffset );\n\n\t\t\tfor ( let offset = byteOffset, l = byteOffset + buffer.byteLength; offset < l; offset += BYTES_PER_NODE ) {\n\n\t\t\t\tconst offset2 = offset / 2;\n\t\t\t\tif ( ! IS_LEAF( offset2, uint16Array ) ) {\n\n\t\t\t\t\tuint32Array[ ( offset / 4 ) + 6 ] += stride4Offset;\n\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn byteOffset + buffer.byteLength;\n\n\t\t} else {\n\n\t\t\tconst offset = node.offset;\n\t\t\tconst count = node.count;\n\t\t\tuint32Array[ stride4Offset + 6 ] = offset;\n\t\t\tuint16Array[ stride2Offset + 14 ] = count;\n\t\t\tuint16Array[ stride2Offset + 15 ] = IS_LEAFNODE_FLAG;\n\t\t\treturn byteOffset + BYTES_PER_NODE;\n\n\t\t}\n\n\t} else {\n\n\t\tconst left = node.left;\n\t\tconst right = node.right;\n\t\tconst splitAxis = node.splitAxis;\n\n\t\tlet nextUnusedPointer;\n\t\tnextUnusedPointer = _populateBuffer( byteOffset + BYTES_PER_NODE, left );\n\n\t\tif ( ( nextUnusedPointer / 4 ) > MAX_POINTER ) {\n\n\t\t\tthrow new Error( 'MeshBVH: Cannot store child pointer greater than 32 bits.' );\n\n\t\t}\n\n\t\tuint32Array[ stride4Offset + 6 ] = nextUnusedPointer / 4;\n\t\tnextUnusedPointer = _populateBuffer( nextUnusedPointer, right );\n\n\t\tuint32Array[ stride4Offset + 7 ] = splitAxis;\n\t\treturn nextUnusedPointer;\n\n\t}\n\n}\n","import { ensureIndex, getFullGeometryRange, getRootIndexRanges, getTriCount, hasGroupGaps, } from './geometryUtils.js';\nimport { getBounds, computeTriangleBounds } from './computeBoundsUtils.js';\nimport { getOptimalSplit } from './splitUtils.js';\nimport { MeshBVHNode } from '../MeshBVHNode.js';\nimport { BYTES_PER_NODE } from '../Constants.js';\n\nimport { partition } from './sortUtils.generated.js';\nimport { partition_indirect } from './sortUtils_indirect.generated.js';\nimport { countNodes, populateBuffer } from './buildUtils.js';\n\nexport function generateIndirectBuffer( geometry, useSharedArrayBuffer ) {\n\n\tconst triCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\n\tconst useUint32 = triCount > 2 ** 16;\n\tconst byteCount = useUint32 ? 4 : 2;\n\n\tconst buffer = useSharedArrayBuffer ? new SharedArrayBuffer( triCount * byteCount ) : new ArrayBuffer( triCount * byteCount );\n\tconst indirectBuffer = useUint32 ? new Uint32Array( buffer ) : new Uint16Array( buffer );\n\tfor ( let i = 0, l = indirectBuffer.length; i < l; i ++ ) {\n\n\t\tindirectBuffer[ i ] = i;\n\n\t}\n\n\treturn indirectBuffer;\n\n}\n\nexport function buildTree( bvh, triangleBounds, offset, count, options ) {\n\n\t// epxand variables\n\tconst {\n\t\tmaxDepth,\n\t\tverbose,\n\t\tmaxLeafTris,\n\t\tstrategy,\n\t\tonProgress,\n\t\tindirect,\n\t} = options;\n\tconst indirectBuffer = bvh._indirectBuffer;\n\tconst geometry = bvh.geometry;\n\tconst indexArray = geometry.index ? geometry.index.array : null;\n\tconst partionFunc = indirect ? partition_indirect : partition;\n\n\t// generate intermediate variables\n\tconst totalTriangles = getTriCount( geometry );\n\tconst cacheCentroidBoundingData = new Float32Array( 6 );\n\tlet reachedMaxDepth = false;\n\n\tconst root = new MeshBVHNode();\n\tgetBounds( triangleBounds, offset, count, root.boundingData, cacheCentroidBoundingData );\n\tsplitNode( root, offset, count, cacheCentroidBoundingData );\n\treturn root;\n\n\tfunction triggerProgress( trianglesProcessed ) {\n\n\t\tif ( onProgress ) {\n\n\t\t\tonProgress( trianglesProcessed / totalTriangles );\n\n\t\t}\n\n\t}\n\n\t// either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\n\t// recording the offset and count of its triangles and writing them into the reordered geometry index.\n\tfunction splitNode( node, offset, count, centroidBoundingData = null, depth = 0 ) {\n\n\t\tif ( ! reachedMaxDepth && depth >= maxDepth ) {\n\n\t\t\treachedMaxDepth = true;\n\t\t\tif ( verbose ) {\n\n\t\t\t\tconsole.warn( `MeshBVH: Max depth of ${ maxDepth } reached when generating BVH. Consider increasing maxDepth.` );\n\t\t\t\tconsole.warn( geometry );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// early out if we've met our capacity\n\t\tif ( count <= maxLeafTris || depth >= maxDepth ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\t\t\treturn node;\n\n\t\t}\n\n\t\t// Find where to split the volume\n\t\tconst split = getOptimalSplit( node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy );\n\t\tif ( split.axis === - 1 ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\t\t\treturn node;\n\n\t\t}\n\n\t\tconst splitOffset = partionFunc( indirectBuffer, indexArray, triangleBounds, offset, count, split );\n\n\t\t// create the two new child nodes\n\t\tif ( splitOffset === offset || splitOffset === offset + count ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\n\t\t} else {\n\n\t\t\tnode.splitAxis = split.axis;\n\n\t\t\t// create the left child and compute its bounding box\n\t\t\tconst left = new MeshBVHNode();\n\t\t\tconst lstart = offset;\n\t\t\tconst lcount = splitOffset - offset;\n\t\t\tnode.left = left;\n\n\t\t\tgetBounds( triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData );\n\t\t\tsplitNode( left, lstart, lcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t\t// repeat for right\n\t\t\tconst right = new MeshBVHNode();\n\t\t\tconst rstart = splitOffset;\n\t\t\tconst rcount = count - lcount;\n\t\t\tnode.right = right;\n\n\t\t\tgetBounds( triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData );\n\t\t\tsplitNode( right, rstart, rcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n}\n\nexport function buildPackedTree( bvh, options ) {\n\n\tconst geometry = bvh.geometry;\n\tif ( options.indirect ) {\n\n\t\tbvh._indirectBuffer = generateIndirectBuffer( geometry, options.useSharedArrayBuffer );\n\n\t\tif ( hasGroupGaps( geometry, options.range ) && ! options.verbose ) {\n\n\t\t\tconsole.warn(\n\t\t\t\t'MeshBVH: Provided geometry contains groups or a range that do not fully span the vertex contents while using the \"indirect\" option. ' +\n\t\t\t\t'BVH may incorrectly report intersections on unrendered portions of the geometry.'\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\tif ( ! bvh._indirectBuffer ) {\n\n\t\tensureIndex( geometry, options );\n\n\t}\n\n\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\n\tconst triangleBounds = computeTriangleBounds( geometry );\n\tconst geometryRanges = options.indirect ? getFullGeometryRange( geometry, options.range ) : getRootIndexRanges( geometry, options.range );\n\tbvh._roots = geometryRanges.map( range => {\n\n\t\tconst root = buildTree( bvh, triangleBounds, range.offset, range.count, options );\n\t\tconst nodeCount = countNodes( root );\n\t\tconst buffer = new BufferConstructor( BYTES_PER_NODE * nodeCount );\n\t\tpopulateBuffer( 0, root, buffer );\n\t\treturn buffer;\n\n\t} );\n\n}\n","import { Vector3 } from 'three';\n\nexport class SeparatingAxisBounds {\n\n\tconstructor() {\n\n\t\tthis.min = Infinity;\n\t\tthis.max = - Infinity;\n\n\t}\n\n\tsetFromPointsField( points, field ) {\n\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tconst val = p[ field ];\n\t\t\tmin = val < min ? val : min;\n\t\t\tmax = val > max ? val : max;\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tsetFromPoints( axis, points ) {\n\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tconst val = axis.dot( p );\n\t\t\tmin = val < min ? val : min;\n\t\t\tmax = val > max ? val : max;\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tisSeparated( other ) {\n\n\t\treturn this.min > other.max || other.min > this.max;\n\n\t}\n\n}\n\nSeparatingAxisBounds.prototype.setFromBox = ( function () {\n\n\tconst p = new Vector3();\n\treturn function setFromBox( axis, box ) {\n\n\t\tconst boxMin = box.min;\n\t\tconst boxMax = box.max;\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tp.x = boxMin.x * x + boxMax.x * ( 1 - x );\n\t\t\t\t\tp.y = boxMin.y * y + boxMax.y * ( 1 - y );\n\t\t\t\t\tp.z = boxMin.z * z + boxMax.z * ( 1 - z );\n\n\t\t\t\t\tconst val = axis.dot( p );\n\t\t\t\t\tmin = Math.min( val, min );\n\t\t\t\t\tmax = Math.max( val, max );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t};\n\n} )();\n\nexport const areIntersecting = ( function () {\n\n\tconst cacheSatBounds = new SeparatingAxisBounds();\n\treturn function areIntersecting( shape1, shape2 ) {\n\n\t\tconst points1 = shape1.points;\n\t\tconst satAxes1 = shape1.satAxes;\n\t\tconst satBounds1 = shape1.satBounds;\n\n\t\tconst points2 = shape2.points;\n\t\tconst satAxes2 = shape2.satAxes;\n\t\tconst satBounds2 = shape2.satBounds;\n\n\t\t// check axes of the first shape\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds1[ i ];\n\t\t\tconst sa = satAxes1[ i ];\n\t\t\tcacheSatBounds.setFromPoints( sa, points2 );\n\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\n\n\t\t}\n\n\t\t// check axes of the second shape\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds2[ i ];\n\t\t\tconst sa = satAxes2[ i ];\n\t\t\tcacheSatBounds.setFromPoints( sa, points1 );\n\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\n\n\t\t}\n\n\t};\n\n} )();\n","import { Vector3, Vector2, Plane, Line3 } from 'three';\n\nexport const closestPointLineToLine = ( function () {\n\n\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/Line.cpp#L56\n\tconst dir1 = new Vector3();\n\tconst dir2 = new Vector3();\n\tconst v02 = new Vector3();\n\treturn function closestPointLineToLine( l1, l2, result ) {\n\n\t\tconst v0 = l1.start;\n\t\tconst v10 = dir1;\n\t\tconst v2 = l2.start;\n\t\tconst v32 = dir2;\n\n\t\tv02.subVectors( v0, v2 );\n\t\tdir1.subVectors( l1.end, l1.start );\n\t\tdir2.subVectors( l2.end, l2.start );\n\n\t\t// float d0232 = v02.Dot(v32);\n\t\tconst d0232 = v02.dot( v32 );\n\n\t\t// float d3210 = v32.Dot(v10);\n\t\tconst d3210 = v32.dot( v10 );\n\n\t\t// float d3232 = v32.Dot(v32);\n\t\tconst d3232 = v32.dot( v32 );\n\n\t\t// float d0210 = v02.Dot(v10);\n\t\tconst d0210 = v02.dot( v10 );\n\n\t\t// float d1010 = v10.Dot(v10);\n\t\tconst d1010 = v10.dot( v10 );\n\n\t\t// float denom = d1010*d3232 - d3210*d3210;\n\t\tconst denom = d1010 * d3232 - d3210 * d3210;\n\n\t\tlet d, d2;\n\t\tif ( denom !== 0 ) {\n\n\t\t\td = ( d0232 * d3210 - d0210 * d3232 ) / denom;\n\n\t\t} else {\n\n\t\t\td = 0;\n\n\t\t}\n\n\t\td2 = ( d0232 + d * d3210 ) / d3232;\n\n\t\tresult.x = d;\n\t\tresult.y = d2;\n\n\t};\n\n} )();\n\nexport const closestPointsSegmentToSegment = ( function () {\n\n\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/LineSegment.cpp#L187\n\tconst paramResult = new Vector2();\n\tconst temp1 = new Vector3();\n\tconst temp2 = new Vector3();\n\treturn function closestPointsSegmentToSegment( l1, l2, target1, target2 ) {\n\n\t\tclosestPointLineToLine( l1, l2, paramResult );\n\n\t\tlet d = paramResult.x;\n\t\tlet d2 = paramResult.y;\n\t\tif ( d >= 0 && d <= 1 && d2 >= 0 && d2 <= 1 ) {\n\n\t\t\tl1.at( d, target1 );\n\t\t\tl2.at( d2, target2 );\n\n\t\t\treturn;\n\n\t\t} else if ( d >= 0 && d <= 1 ) {\n\n\t\t\t// Only d2 is out of bounds.\n\t\t\tif ( d2 < 0 ) {\n\n\t\t\t\tl2.at( 0, target2 );\n\n\t\t\t} else {\n\n\t\t\t\tl2.at( 1, target2 );\n\n\t\t\t}\n\n\t\t\tl1.closestPointToPoint( target2, true, target1 );\n\t\t\treturn;\n\n\t\t} else if ( d2 >= 0 && d2 <= 1 ) {\n\n\t\t\t// Only d is out of bounds.\n\t\t\tif ( d < 0 ) {\n\n\t\t\t\tl1.at( 0, target1 );\n\n\t\t\t} else {\n\n\t\t\t\tl1.at( 1, target1 );\n\n\t\t\t}\n\n\t\t\tl2.closestPointToPoint( target1, true, target2 );\n\t\t\treturn;\n\n\t\t} else {\n\n\t\t\t// Both u and u2 are out of bounds.\n\t\t\tlet p;\n\t\t\tif ( d < 0 ) {\n\n\t\t\t\tp = l1.start;\n\n\t\t\t} else {\n\n\t\t\t\tp = l1.end;\n\n\t\t\t}\n\n\t\t\tlet p2;\n\t\t\tif ( d2 < 0 ) {\n\n\t\t\t\tp2 = l2.start;\n\n\t\t\t} else {\n\n\t\t\t\tp2 = l2.end;\n\n\t\t\t}\n\n\t\t\tconst closestPoint = temp1;\n\t\t\tconst closestPoint2 = temp2;\n\t\t\tl1.closestPointToPoint( p2, true, temp1 );\n\t\t\tl2.closestPointToPoint( p, true, temp2 );\n\n\t\t\tif ( closestPoint.distanceToSquared( p2 ) <= closestPoint2.distanceToSquared( p ) ) {\n\n\t\t\t\ttarget1.copy( closestPoint );\n\t\t\t\ttarget2.copy( p2 );\n\t\t\t\treturn;\n\n\t\t\t} else {\n\n\t\t\t\ttarget1.copy( p );\n\t\t\t\ttarget2.copy( closestPoint2 );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n} )();\n\n\nexport const sphereIntersectTriangle = ( function () {\n\n\t// https://stackoverflow.com/questions/34043955/detect-collision-between-sphere-and-triangle-in-three-js\n\tconst closestPointTemp = new Vector3();\n\tconst projectedPointTemp = new Vector3();\n\tconst planeTemp = new Plane();\n\tconst lineTemp = new Line3();\n\treturn function sphereIntersectTriangle( sphere, triangle ) {\n\n\t\tconst { radius, center } = sphere;\n\t\tconst { a, b, c } = triangle;\n\n\t\t// phase 1\n\t\tlineTemp.start = a;\n\t\tlineTemp.end = b;\n\t\tconst closestPoint1 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint1.distanceTo( center ) <= radius ) return true;\n\n\t\tlineTemp.start = a;\n\t\tlineTemp.end = c;\n\t\tconst closestPoint2 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint2.distanceTo( center ) <= radius ) return true;\n\n\t\tlineTemp.start = b;\n\t\tlineTemp.end = c;\n\t\tconst closestPoint3 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint3.distanceTo( center ) <= radius ) return true;\n\n\t\t// phase 2\n\t\tconst plane = triangle.getPlane( planeTemp );\n\t\tconst dp = Math.abs( plane.distanceToPoint( center ) );\n\t\tif ( dp <= radius ) {\n\n\t\t\tconst pp = plane.projectPoint( center, projectedPointTemp );\n\t\t\tconst cp = triangle.containsPoint( pp );\n\t\t\tif ( cp ) return true;\n\n\t\t}\n\n\t\treturn false;\n\n\t};\n\n} )();\n","import { Triangle, Vector3, Line3, Sphere, Plane } from 'three';\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\nimport { closestPointsSegmentToSegment, sphereIntersectTriangle } from './MathUtilities.js';\n\nconst ZERO_EPSILON = 1e-15;\nfunction isNearZero( value ) {\n\n\treturn Math.abs( value ) < ZERO_EPSILON;\n\n}\n\nexport class ExtendedTriangle extends Triangle {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tthis.isExtendedTriangle = true;\n\t\tthis.satAxes = new Array( 4 ).fill().map( () => new Vector3() );\n\t\tthis.satBounds = new Array( 4 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.points = [ this.a, this.b, this.c ];\n\t\tthis.sphere = new Sphere();\n\t\tthis.plane = new Plane();\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn sphereIntersectTriangle( sphere, this );\n\n\t}\n\n\tupdate() {\n\n\t\tconst a = this.a;\n\t\tconst b = this.b;\n\t\tconst c = this.c;\n\t\tconst points = this.points;\n\n\t\tconst satAxes = this.satAxes;\n\t\tconst satBounds = this.satBounds;\n\n\t\tconst axis0 = satAxes[ 0 ];\n\t\tconst sab0 = satBounds[ 0 ];\n\t\tthis.getNormal( axis0 );\n\t\tsab0.setFromPoints( axis0, points );\n\n\t\tconst axis1 = satAxes[ 1 ];\n\t\tconst sab1 = satBounds[ 1 ];\n\t\taxis1.subVectors( a, b );\n\t\tsab1.setFromPoints( axis1, points );\n\n\t\tconst axis2 = satAxes[ 2 ];\n\t\tconst sab2 = satBounds[ 2 ];\n\t\taxis2.subVectors( b, c );\n\t\tsab2.setFromPoints( axis2, points );\n\n\t\tconst axis3 = satAxes[ 3 ];\n\t\tconst sab3 = satBounds[ 3 ];\n\t\taxis3.subVectors( c, a );\n\t\tsab3.setFromPoints( axis3, points );\n\n\t\tthis.sphere.setFromPoints( this.points );\n\t\tthis.plane.setFromNormalAndCoplanarPoint( axis0, a );\n\t\tthis.needsUpdate = false;\n\n\t}\n\n}\n\nExtendedTriangle.prototype.closestPointToSegment = ( function () {\n\n\tconst point1 = new Vector3();\n\tconst point2 = new Vector3();\n\tconst edge = new Line3();\n\n\treturn function distanceToSegment( segment, target1 = null, target2 = null ) {\n\n\t\tconst { start, end } = segment;\n\t\tconst points = this.points;\n\t\tlet distSq;\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check the triangle edges\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst nexti = ( i + 1 ) % 3;\n\t\t\tedge.start.copy( points[ i ] );\n\t\t\tedge.end.copy( points[ nexti ] );\n\n\t\t\tclosestPointsSegmentToSegment( edge, segment, point1, point2 );\n\n\t\t\tdistSq = point1.distanceToSquared( point2 );\n\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check end points\n\t\tthis.closestPointToPoint( start, point1 );\n\t\tdistSq = start.distanceToSquared( point1 );\n\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\tclosestDistanceSq = distSq;\n\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\tif ( target2 ) target2.copy( start );\n\n\t\t}\n\n\t\tthis.closestPointToPoint( end, point1 );\n\t\tdistSq = end.distanceToSquared( point1 );\n\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\tclosestDistanceSq = distSq;\n\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\tif ( target2 ) target2.copy( end );\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n\nExtendedTriangle.prototype.intersectsTriangle = ( function () {\n\n\tconst saTri2 = new ExtendedTriangle();\n\tconst arr1 = new Array( 3 );\n\tconst arr2 = new Array( 3 );\n\tconst cachedSatBounds = new SeparatingAxisBounds();\n\tconst cachedSatBounds2 = new SeparatingAxisBounds();\n\tconst cachedAxis = new Vector3();\n\tconst dir = new Vector3();\n\tconst dir1 = new Vector3();\n\tconst dir2 = new Vector3();\n\tconst tempDir = new Vector3();\n\tconst edge = new Line3();\n\tconst edge1 = new Line3();\n\tconst edge2 = new Line3();\n\tconst tempPoint = new Vector3();\n\n\tfunction triIntersectPlane( tri, plane, targetEdge ) {\n\n\t\t// find the edge that intersects the other triangle plane\n\t\tconst points = tri.points;\n\t\tlet count = 0;\n\t\tlet startPointIntersection = - 1;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst { start, end } = edge;\n\t\t\tstart.copy( points[ i ] );\n\t\t\tend.copy( points[ ( i + 1 ) % 3 ] );\n\t\t\tedge.delta( dir );\n\n\t\t\tconst startIntersects = isNearZero( plane.distanceToPoint( start ) );\n\t\t\tif ( isNearZero( plane.normal.dot( dir ) ) && startIntersects ) {\n\n\t\t\t\t// if the edge lies on the plane then take the line\n\t\t\t\ttargetEdge.copy( edge );\n\t\t\t\tcount = 2;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t// check if the start point is near the plane because \"intersectLine\" is not robust to that case\n\t\t\tconst doesIntersect = plane.intersectLine( edge, tempPoint );\n\t\t\tif ( ! doesIntersect && startIntersects ) {\n\n\t\t\t\ttempPoint.copy( start );\n\n\t\t\t}\n\n\t\t\t// ignore the end point\n\t\t\tif ( ( doesIntersect || startIntersects ) && ! isNearZero( tempPoint.distanceTo( end ) ) ) {\n\n\t\t\t\tif ( count <= 1 ) {\n\n\t\t\t\t\t// assign to the start or end point and save which index was snapped to\n\t\t\t\t\t// the start point if necessary\n\t\t\t\t\tconst point = count === 1 ? targetEdge.start : targetEdge.end;\n\t\t\t\t\tpoint.copy( tempPoint );\n\t\t\t\t\tif ( startIntersects ) {\n\n\t\t\t\t\t\tstartPointIntersection = count;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( count >= 2 ) {\n\n\t\t\t\t\t// if we're here that means that there must have been one point that had\n\t\t\t\t\t// snapped to the start point so replace it here\n\t\t\t\t\tconst point = startPointIntersection === 1 ? targetEdge.start : targetEdge.end;\n\t\t\t\t\tpoint.copy( tempPoint );\n\t\t\t\t\tcount = 2;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tcount ++;\n\t\t\t\tif ( count === 2 && startPointIntersection === - 1 ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn count;\n\n\t}\n\n\t// TODO: If the triangles are coplanar and intersecting the target is nonsensical. It should at least\n\t// be a line contained by both triangles if not a different special case somehow represented in the return result.\n\treturn function intersectsTriangle( other, target = null, suppressLog = false ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( ! other.isExtendedTriangle ) {\n\n\t\t\tsaTri2.copy( other );\n\t\t\tsaTri2.update();\n\t\t\tother = saTri2;\n\n\t\t} else if ( other.needsUpdate ) {\n\n\t\t\tother.update();\n\n\t\t}\n\n\t\tconst plane1 = this.plane;\n\t\tconst plane2 = other.plane;\n\n\t\tif ( Math.abs( plane1.normal.dot( plane2.normal ) ) > 1.0 - 1e-10 ) {\n\n\t\t\t// perform separating axis intersection test only for coplanar triangles\n\t\t\tconst satBounds1 = this.satBounds;\n\t\t\tconst satAxes1 = this.satAxes;\n\t\t\tarr2[ 0 ] = other.a;\n\t\t\tarr2[ 1 ] = other.b;\n\t\t\tarr2[ 2 ] = other.c;\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\tconst sb = satBounds1[ i ];\n\t\t\t\tconst sa = satAxes1[ i ];\n\t\t\t\tcachedSatBounds.setFromPoints( sa, arr2 );\n\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\t}\n\n\t\t\tconst satBounds2 = other.satBounds;\n\t\t\tconst satAxes2 = other.satAxes;\n\t\t\tarr1[ 0 ] = this.a;\n\t\t\tarr1[ 1 ] = this.b;\n\t\t\tarr1[ 2 ] = this.c;\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\tconst sb = satBounds2[ i ];\n\t\t\t\tconst sa = satAxes2[ i ];\n\t\t\t\tcachedSatBounds.setFromPoints( sa, arr1 );\n\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\t}\n\n\t\t\t// check crossed axes\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\tconst sa1 = satAxes1[ i ];\n\t\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\n\n\t\t\t\t\tconst sa2 = satAxes2[ i2 ];\n\t\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\n\t\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, arr1 );\n\t\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, arr2 );\n\t\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( target ) {\n\n\t\t\t\t// TODO find two points that intersect on the edges and make that the result\n\t\t\t\tif ( ! suppressLog ) {\n\n\t\t\t\t\tconsole.warn( 'ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0.' );\n\n\t\t\t\t}\n\n\t\t\t\ttarget.start.set( 0, 0, 0 );\n\t\t\t\ttarget.end.set( 0, 0, 0 );\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\t// find the edge that intersects the other triangle plane\n\t\t\tconst count1 = triIntersectPlane( this, plane2, edge1 );\n\t\t\tif ( count1 === 1 && other.containsPoint( edge1.end ) ) {\n\n\t\t\t\tif ( target ) {\n\n\t\t\t\t\ttarget.start.copy( edge1.end );\n\t\t\t\t\ttarget.end.copy( edge1.end );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t} else if ( count1 !== 2 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// find the other triangles edge that intersects this plane\n\t\t\tconst count2 = triIntersectPlane( other, plane1, edge2 );\n\t\t\tif ( count2 === 1 && this.containsPoint( edge2.end ) ) {\n\n\t\t\t\tif ( target ) {\n\n\t\t\t\t\ttarget.start.copy( edge2.end );\n\t\t\t\t\ttarget.end.copy( edge2.end );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t} else if ( count2 !== 2 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// find swap the second edge so both lines are running the same direction\n\t\t\tedge1.delta( dir1 );\n\t\t\tedge2.delta( dir2 );\n\n\t\t\tif ( dir1.dot( dir2 ) < 0 ) {\n\n\t\t\t\tlet tmp = edge2.start;\n\t\t\t\tedge2.start = edge2.end;\n\t\t\t\tedge2.end = tmp;\n\n\t\t\t}\n\n\t\t\t// check if the edges are overlapping\n\t\t\tconst s1 = edge1.start.dot( dir1 );\n\t\t\tconst e1 = edge1.end.dot( dir1 );\n\t\t\tconst s2 = edge2.start.dot( dir1 );\n\t\t\tconst e2 = edge2.end.dot( dir1 );\n\t\t\tconst separated1 = e1 < s2;\n\t\t\tconst separated2 = s1 < e2;\n\n\t\t\tif ( s1 !== e2 && s2 !== e1 && separated1 === separated2 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// assign the target output\n\t\t\tif ( target ) {\n\n\t\t\t\ttempDir.subVectors( edge1.start, edge2.start );\n\t\t\t\tif ( tempDir.dot( dir1 ) > 0 ) {\n\n\t\t\t\t\ttarget.start.copy( edge1.start );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttarget.start.copy( edge2.start );\n\n\t\t\t\t}\n\n\t\t\t\ttempDir.subVectors( edge1.end, edge2.end );\n\t\t\t\tif ( tempDir.dot( dir1 ) < 0 ) {\n\n\t\t\t\t\ttarget.end.copy( edge1.end );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttarget.end.copy( edge2.end );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t};\n\n} )();\n\n\nExtendedTriangle.prototype.distanceToPoint = ( function () {\n\n\tconst target = new Vector3();\n\treturn function distanceToPoint( point ) {\n\n\t\tthis.closestPointToPoint( point, target );\n\t\treturn point.distanceTo( target );\n\n\t};\n\n} )();\n\n\nExtendedTriangle.prototype.distanceToTriangle = ( function () {\n\n\tconst point = new Vector3();\n\tconst point2 = new Vector3();\n\tconst cornerFields = [ 'a', 'b', 'c' ];\n\tconst line1 = new Line3();\n\tconst line2 = new Line3();\n\n\treturn function distanceToTriangle( other, target1 = null, target2 = null ) {\n\n\t\tconst lineTarget = target1 || target2 ? line1 : null;\n\t\tif ( this.intersectsTriangle( other, lineTarget ) ) {\n\n\t\t\tif ( target1 || target2 ) {\n\n\t\t\t\tif ( target1 ) lineTarget.getCenter( target1 );\n\t\t\t\tif ( target2 ) lineTarget.getCenter( target2 );\n\n\t\t\t}\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check all point distances\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tlet dist;\n\t\t\tconst field = cornerFields[ i ];\n\t\t\tconst otherVec = other[ field ];\n\t\t\tthis.closestPointToPoint( otherVec, point );\n\n\t\t\tdist = otherVec.distanceToSquared( point );\n\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( point );\n\t\t\t\tif ( target2 ) target2.copy( otherVec );\n\n\t\t\t}\n\n\n\t\t\tconst thisVec = this[ field ];\n\t\t\tother.closestPointToPoint( thisVec, point );\n\n\t\t\tdist = thisVec.distanceToSquared( point );\n\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( thisVec );\n\t\t\t\tif ( target2 ) target2.copy( point );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst f11 = cornerFields[ i ];\n\t\t\tconst f12 = cornerFields[ ( i + 1 ) % 3 ];\n\t\t\tline1.set( this[ f11 ], this[ f12 ] );\n\t\t\tfor ( let i2 = 0; i2 < 3; i2 ++ ) {\n\n\t\t\t\tconst f21 = cornerFields[ i2 ];\n\t\t\t\tconst f22 = cornerFields[ ( i2 + 1 ) % 3 ];\n\t\t\t\tline2.set( other[ f21 ], other[ f22 ] );\n\n\t\t\t\tclosestPointsSegmentToSegment( line1, line2, point, point2 );\n\n\t\t\t\tconst dist = point.distanceToSquared( point2 );\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( point );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n","import { Vector3, Matrix4, Line3 } from 'three';\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\nimport { ExtendedTriangle } from './ExtendedTriangle.js';\nimport { closestPointsSegmentToSegment } from './MathUtilities.js';\n\nexport class OrientedBox {\n\n\tconstructor( min, max, matrix ) {\n\n\t\tthis.isOrientedBox = true;\n\t\tthis.min = new Vector3();\n\t\tthis.max = new Vector3();\n\t\tthis.matrix = new Matrix4();\n\t\tthis.invMatrix = new Matrix4();\n\t\tthis.points = new Array( 8 ).fill().map( () => new Vector3() );\n\t\tthis.satAxes = new Array( 3 ).fill().map( () => new Vector3() );\n\t\tthis.satBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.alignedSatBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.needsUpdate = false;\n\n\t\tif ( min ) this.min.copy( min );\n\t\tif ( max ) this.max.copy( max );\n\t\tif ( matrix ) this.matrix.copy( matrix );\n\n\t}\n\n\tset( min, max, matrix ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\t\tthis.matrix.copy( matrix );\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tcopy( other ) {\n\n\t\tthis.min.copy( other.min );\n\t\tthis.max.copy( other.max );\n\t\tthis.matrix.copy( other.matrix );\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n\nOrientedBox.prototype.update = ( function () {\n\n\treturn function update() {\n\n\t\tconst matrix = this.matrix;\n\t\tconst min = this.min;\n\t\tconst max = this.max;\n\n\t\tconst points = this.points;\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tconst i = ( ( 1 << 0 ) * x ) | ( ( 1 << 1 ) * y ) | ( ( 1 << 2 ) * z );\n\t\t\t\t\tconst v = points[ i ];\n\t\t\t\t\tv.x = x ? max.x : min.x;\n\t\t\t\t\tv.y = y ? max.y : min.y;\n\t\t\t\t\tv.z = z ? max.z : min.z;\n\n\t\t\t\t\tv.applyMatrix4( matrix );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\t\tconst minVec = points[ 0 ];\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst axis = satAxes[ i ];\n\t\t\tconst sb = satBounds[ i ];\n\t\t\tconst index = 1 << i;\n\t\t\tconst pi = points[ index ];\n\n\t\t\taxis.subVectors( minVec, pi );\n\t\t\tsb.setFromPoints( axis, points );\n\n\t\t}\n\n\t\tconst alignedSatBounds = this.alignedSatBounds;\n\t\talignedSatBounds[ 0 ].setFromPointsField( points, 'x' );\n\t\talignedSatBounds[ 1 ].setFromPointsField( points, 'y' );\n\t\talignedSatBounds[ 2 ].setFromPointsField( points, 'z' );\n\n\t\tthis.invMatrix.copy( this.matrix ).invert();\n\t\tthis.needsUpdate = false;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.intersectsBox = ( function () {\n\n\tconst aabbBounds = new SeparatingAxisBounds();\n\treturn function intersectsBox( box ) {\n\n\t\t// TODO: should this be doing SAT against the AABB?\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tconst min = box.min;\n\t\tconst max = box.max;\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\t\tconst alignedSatBounds = this.alignedSatBounds;\n\n\t\taabbBounds.min = min.x;\n\t\taabbBounds.max = max.x;\n\t\tif ( alignedSatBounds[ 0 ].isSeparated( aabbBounds ) ) return false;\n\n\t\taabbBounds.min = min.y;\n\t\taabbBounds.max = max.y;\n\t\tif ( alignedSatBounds[ 1 ].isSeparated( aabbBounds ) ) return false;\n\n\t\taabbBounds.min = min.z;\n\t\taabbBounds.max = max.z;\n\t\tif ( alignedSatBounds[ 2 ].isSeparated( aabbBounds ) ) return false;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst axis = satAxes[ i ];\n\t\t\tconst sb = satBounds[ i ];\n\t\t\taabbBounds.setFromBox( axis, box );\n\t\t\tif ( sb.isSeparated( aabbBounds ) ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.intersectsTriangle = ( function () {\n\n\tconst saTri = new ExtendedTriangle();\n\tconst pointsArr = new Array( 3 );\n\tconst cachedSatBounds = new SeparatingAxisBounds();\n\tconst cachedSatBounds2 = new SeparatingAxisBounds();\n\tconst cachedAxis = new Vector3();\n\treturn function intersectsTriangle( triangle ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( ! triangle.isExtendedTriangle ) {\n\n\t\t\tsaTri.copy( triangle );\n\t\t\tsaTri.update();\n\t\t\ttriangle = saTri;\n\n\t\t} else if ( triangle.needsUpdate ) {\n\n\t\t\ttriangle.update();\n\n\t\t}\n\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\n\t\tpointsArr[ 0 ] = triangle.a;\n\t\tpointsArr[ 1 ] = triangle.b;\n\t\tpointsArr[ 2 ] = triangle.c;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds[ i ];\n\t\t\tconst sa = satAxes[ i ];\n\t\t\tcachedSatBounds.setFromPoints( sa, pointsArr );\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t}\n\n\t\tconst triSatBounds = triangle.satBounds;\n\t\tconst triSatAxes = triangle.satAxes;\n\t\tconst points = this.points;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = triSatBounds[ i ];\n\t\t\tconst sa = triSatAxes[ i ];\n\t\t\tcachedSatBounds.setFromPoints( sa, points );\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t}\n\n\t\t// check crossed axes\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sa1 = satAxes[ i ];\n\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\n\n\t\t\t\tconst sa2 = triSatAxes[ i2 ];\n\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\n\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, pointsArr );\n\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, points );\n\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.closestPointToPoint = ( function () {\n\n\treturn function closestPointToPoint( point, target1 ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\ttarget1\n\t\t\t.copy( point )\n\t\t\t.applyMatrix4( this.invMatrix )\n\t\t\t.clamp( this.min, this.max )\n\t\t\t.applyMatrix4( this.matrix );\n\n\t\treturn target1;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.distanceToPoint = ( function () {\n\n\tconst target = new Vector3();\n\treturn function distanceToPoint( point ) {\n\n\t\tthis.closestPointToPoint( point, target );\n\t\treturn point.distanceTo( target );\n\n\t};\n\n} )();\n\nOrientedBox.prototype.distanceToBox = ( function () {\n\n\tconst xyzFields = [ 'x', 'y', 'z' ];\n\tconst segments1 = new Array( 12 ).fill().map( () => new Line3() );\n\tconst segments2 = new Array( 12 ).fill().map( () => new Line3() );\n\n\tconst point1 = new Vector3();\n\tconst point2 = new Vector3();\n\n\t// early out if we find a value below threshold\n\treturn function distanceToBox( box, threshold = 0, target1 = null, target2 = null ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( this.intersectsBox( box ) ) {\n\n\t\t\tif ( target1 || target2 ) {\n\n\t\t\t\tbox.getCenter( point2 );\n\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\tbox.closestPointToPoint( point1, point2 );\n\n\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t}\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tconst threshold2 = threshold * threshold;\n\t\tconst min = box.min;\n\t\tconst max = box.max;\n\t\tconst points = this.points;\n\n\n\t\t// iterate over every edge and compare distances\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check over all these points\n\t\tfor ( let i = 0; i < 8; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tpoint2.copy( p ).clamp( min, max );\n\n\t\t\tconst dist = p.distanceToSquared( point2 );\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( p );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate and check all line segment distances\n\t\tlet count = 0;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tfor ( let i1 = 0; i1 <= 1; i1 ++ ) {\n\n\t\t\t\tfor ( let i2 = 0; i2 <= 1; i2 ++ ) {\n\n\t\t\t\t\tconst nextIndex = ( i + 1 ) % 3;\n\t\t\t\t\tconst nextIndex2 = ( i + 2 ) % 3;\n\n\t\t\t\t\t// get obb line segments\n\t\t\t\t\tconst index = i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\tconst index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\tconst p1 = points[ index ];\n\t\t\t\t\tconst p2 = points[ index2 ];\n\t\t\t\t\tconst line1 = segments1[ count ];\n\t\t\t\t\tline1.set( p1, p2 );\n\n\n\t\t\t\t\t// get aabb line segments\n\t\t\t\t\tconst f1 = xyzFields[ i ];\n\t\t\t\t\tconst f2 = xyzFields[ nextIndex ];\n\t\t\t\t\tconst f3 = xyzFields[ nextIndex2 ];\n\t\t\t\t\tconst line2 = segments2[ count ];\n\t\t\t\t\tconst start = line2.start;\n\t\t\t\t\tconst end = line2.end;\n\n\t\t\t\t\tstart[ f1 ] = min[ f1 ];\n\t\t\t\t\tstart[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\tstart[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\tend[ f1 ] = max[ f1 ];\n\t\t\t\t\tend[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\tend[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\tcount ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check all the other boxes point\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tpoint2.x = x ? max.x : min.x;\n\t\t\t\t\tpoint2.y = y ? max.y : min.y;\n\t\t\t\t\tpoint2.z = z ? max.z : min.z;\n\n\t\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\t\tconst dist = point2.distanceToSquared( point1 );\n\t\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 12; i ++ ) {\n\n\t\t\tconst l1 = segments1[ i ];\n\t\t\tfor ( let i2 = 0; i2 < 12; i2 ++ ) {\n\n\t\t\t\tconst l2 = segments2[ i2 ];\n\t\t\t\tclosestPointsSegmentToSegment( l1, l2, point1, point2 );\n\t\t\t\tconst dist = point1.distanceToSquared( point2 );\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n","export class PrimitivePool {\n\n\tconstructor( getNewPrimitive ) {\n\n\t\tthis._getNewPrimitive = getNewPrimitive;\n\t\tthis._primitives = [];\n\n\t}\n\n\tgetPrimitive() {\n\n\t\tconst primitives = this._primitives;\n\t\tif ( primitives.length === 0 ) {\n\n\t\t\treturn this._getNewPrimitive();\n\n\t\t} else {\n\n\t\t\treturn primitives.pop();\n\n\t\t}\n\n\t}\n\n\treleasePrimitive( primitive ) {\n\n\t\tthis._primitives.push( primitive );\n\n\t}\n\n}\n","import { ExtendedTriangle } from '../math/ExtendedTriangle.js';\nimport { PrimitivePool } from './PrimitivePool.js';\n\nclass ExtendedTrianglePoolBase extends PrimitivePool {\n\n\tconstructor() {\n\n\t\tsuper( () => new ExtendedTriangle() );\n\n\t}\n\n}\n\nexport const ExtendedTrianglePool = /* @__PURE__ */ new ExtendedTrianglePoolBase();\n","class _BufferStack {\n\n\tconstructor() {\n\n\t\tthis.float32Array = null;\n\t\tthis.uint16Array = null;\n\t\tthis.uint32Array = null;\n\n\t\tconst stack = [];\n\t\tlet prevBuffer = null;\n\t\tthis.setBuffer = buffer => {\n\n\t\t\tif ( prevBuffer ) {\n\n\t\t\t\tstack.push( prevBuffer );\n\n\t\t\t}\n\n\t\t\tprevBuffer = buffer;\n\t\t\tthis.float32Array = new Float32Array( buffer );\n\t\t\tthis.uint16Array = new Uint16Array( buffer );\n\t\t\tthis.uint32Array = new Uint32Array( buffer );\n\n\t\t};\n\n\t\tthis.clearBuffer = () => {\n\n\t\t\tprevBuffer = null;\n\t\t\tthis.float32Array = null;\n\t\t\tthis.uint16Array = null;\n\t\t\tthis.uint32Array = null;\n\n\t\t\tif ( stack.length !== 0 ) {\n\n\t\t\t\tthis.setBuffer( stack.pop() );\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n}\n\nexport const BufferStack = new _BufferStack();\n","import { Box3 } from 'three';\nimport { CONTAINED } from '../Constants.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { PrimitivePool } from '../../utils/PrimitivePool.js';\nimport { COUNT, OFFSET, LEFT_NODE, RIGHT_NODE, IS_LEAF, BOUNDING_DATA_INDEX } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\n\nlet _box1, _box2;\nconst boxStack = [];\nconst boxPool = /* @__PURE__ */ new PrimitivePool( () => new Box3() );\n\nexport function shapecast( bvh, root, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset ) {\n\n\t// setup\n\t_box1 = boxPool.getPrimitive();\n\t_box2 = boxPool.getPrimitive();\n\tboxStack.push( _box1, _box2 );\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\n\tconst result = shapecastTraverse( 0, bvh.geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\n\n\t// cleanup\n\tBufferStack.clearBuffer();\n\tboxPool.releasePrimitive( _box1 );\n\tboxPool.releasePrimitive( _box2 );\n\tboxStack.pop();\n\tboxStack.pop();\n\n\tconst length = boxStack.length;\n\tif ( length > 0 ) {\n\n\t\t_box2 = boxStack[ length - 1 ];\n\t\t_box1 = boxStack[ length - 2 ];\n\n\t}\n\n\treturn result;\n\n}\n\nfunction shapecastTraverse(\n\tnodeIndex32,\n\tgeometry,\n\tintersectsBoundsFunc,\n\tintersectsRangeFunc,\n\tnodeScoreFunc = null,\n\tnodeIndexByteOffset = 0, // offset for unique node identifier\n\tdepth = 0\n) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, _box1 );\n\t\treturn intersectsRangeFunc( offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, _box1 );\n\n\t} else {\n\n\t\tconst left = LEFT_NODE( nodeIndex32 );\n\t\tconst right = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tlet c1 = left;\n\t\tlet c2 = right;\n\n\t\tlet score1, score2;\n\t\tlet box1, box2;\n\t\tif ( nodeScoreFunc ) {\n\n\t\t\tbox1 = _box1;\n\t\t\tbox2 = _box2;\n\n\t\t\t// bounding data is not offset\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\t\tscore1 = nodeScoreFunc( box1 );\n\t\t\tscore2 = nodeScoreFunc( box2 );\n\n\t\t\tif ( score2 < score1 ) {\n\n\t\t\t\tc1 = right;\n\t\t\t\tc2 = left;\n\n\t\t\t\tconst temp = score1;\n\t\t\t\tscore1 = score2;\n\t\t\t\tscore2 = temp;\n\n\t\t\t\tbox1 = box2;\n\t\t\t\t// box2 is always set before use below\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Check box 1 intersection\n\t\tif ( ! box1 ) {\n\n\t\t\tbox1 = _box1;\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\n\t\t}\n\n\t\tconst isC1Leaf = IS_LEAF( c1 * 2, uint16Array );\n\t\tconst c1Intersection = intersectsBoundsFunc( box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1 );\n\n\t\tlet c1StopTraversal;\n\t\tif ( c1Intersection === CONTAINED ) {\n\n\t\t\tconst offset = getLeftOffset( c1 );\n\t\t\tconst end = getRightEndOffset( c1 );\n\t\t\tconst count = end - offset;\n\n\t\t\tc1StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c1, box1 );\n\n\t\t} else {\n\n\t\t\tc1StopTraversal =\n\t\t\t\tc1Intersection &&\n\t\t\t\tshapecastTraverse(\n\t\t\t\t\tc1,\n\t\t\t\t\tgeometry,\n\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\tnodeIndexByteOffset,\n\t\t\t\t\tdepth + 1\n\t\t\t\t);\n\n\t\t}\n\n\t\tif ( c1StopTraversal ) return true;\n\n\t\t// Check box 2 intersection\n\t\t// cached box2 will have been overwritten by previous traversal\n\t\tbox2 = _box2;\n\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\tconst isC2Leaf = IS_LEAF( c2 * 2, uint16Array );\n\t\tconst c2Intersection = intersectsBoundsFunc( box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2 );\n\n\t\tlet c2StopTraversal;\n\t\tif ( c2Intersection === CONTAINED ) {\n\n\t\t\tconst offset = getLeftOffset( c2 );\n\t\t\tconst end = getRightEndOffset( c2 );\n\t\t\tconst count = end - offset;\n\n\t\t\tc2StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c2, box2 );\n\n\t\t} else {\n\n\t\t\tc2StopTraversal =\n\t\t\t\tc2Intersection &&\n\t\t\t\tshapecastTraverse(\n\t\t\t\t\tc2,\n\t\t\t\t\tgeometry,\n\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\tnodeIndexByteOffset,\n\t\t\t\t\tdepth + 1\n\t\t\t\t);\n\n\t\t}\n\n\t\tif ( c2StopTraversal ) return true;\n\n\t\treturn false;\n\n\t\t// Define these inside the function so it has access to the local variables needed\n\t\t// when converting to the buffer equivalents\n\t\tfunction getLeftOffset( nodeIndex32 ) {\n\n\t\t\tconst { uint16Array, uint32Array } = BufferStack;\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t// traverse until we find a leaf\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\tnodeIndex32 = LEFT_NODE( nodeIndex32 );\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t}\n\n\t\t\treturn OFFSET( nodeIndex32, uint32Array );\n\n\t\t}\n\n\t\tfunction getRightEndOffset( nodeIndex32 ) {\n\n\t\t\tconst { uint16Array, uint32Array } = BufferStack;\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t// traverse until we find a leaf\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\t// adjust offset to point to the right node\n\t\t\t\tnodeIndex32 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t}\n\n\t\t\t// return the end offset of the triangle range\n\t\t\treturn OFFSET( nodeIndex32, uint32Array ) + COUNT( nodeIndex16, uint16Array );\n\n\t\t}\n\n\t}\n\n}\n","import { Vector3 } from 'three';\n\nconst temp = /* @__PURE__ */ new Vector3();\nconst temp1 = /* @__PURE__ */ new Vector3();\n\nexport function closestPointToPoint(\n\tbvh,\n\tpoint,\n\ttarget = { },\n\tminThreshold = 0,\n\tmaxThreshold = Infinity,\n) {\n\n\t// early out if under minThreshold\n\t// skip checking if over maxThreshold\n\t// set minThreshold = maxThreshold to quickly check if a point is within a threshold\n\t// returns Infinity if no value found\n\tconst minThresholdSq = minThreshold * minThreshold;\n\tconst maxThresholdSq = maxThreshold * maxThreshold;\n\tlet closestDistanceSq = Infinity;\n\tlet closestDistanceTriIndex = null;\n\tbvh.shapecast(\n\n\t\t{\n\n\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\ttemp.copy( point ).clamp( box.min, box.max );\n\t\t\t\treturn temp.distanceToSquared( point );\n\n\t\t\t},\n\n\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\treturn score < closestDistanceSq && score < maxThresholdSq;\n\n\t\t\t},\n\n\t\t\tintersectsTriangle: ( tri, triIndex ) => {\n\n\t\t\t\ttri.closestPointToPoint( point, temp );\n\t\t\t\tconst distSq = point.distanceToSquared( temp );\n\t\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\t\ttemp1.copy( temp );\n\t\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\t\tclosestDistanceTriIndex = triIndex;\n\n\t\t\t\t}\n\n\t\t\t\tif ( distSq < minThresholdSq ) {\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t}\n\n\t);\n\n\tif ( closestDistanceSq === Infinity ) return null;\n\n\tconst closestDistance = Math.sqrt( closestDistanceSq );\n\n\tif ( ! target.point ) target.point = temp1.clone();\n\telse target.point.copy( temp1 );\n\ttarget.distance = closestDistance,\n\ttarget.faceIndex = closestDistanceTriIndex;\n\n\treturn target;\n\n}\n","import { Vector3, Vector2, Triangle, DoubleSide, BackSide } from 'three';\n\n// Ripped and modified From THREE.js Mesh raycast\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L115\nconst _vA = /* @__PURE__ */ new Vector3();\nconst _vB = /* @__PURE__ */ new Vector3();\nconst _vC = /* @__PURE__ */ new Vector3();\n\nconst _uvA = /* @__PURE__ */ new Vector2();\nconst _uvB = /* @__PURE__ */ new Vector2();\nconst _uvC = /* @__PURE__ */ new Vector2();\n\nconst _normalA = /* @__PURE__ */ new Vector3();\nconst _normalB = /* @__PURE__ */ new Vector3();\nconst _normalC = /* @__PURE__ */ new Vector3();\n\nconst _intersectionPoint = /* @__PURE__ */ new Vector3();\nfunction checkIntersection( ray, pA, pB, pC, point, side, near, far ) {\n\n\tlet intersect;\n\tif ( side === BackSide ) {\n\n\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t} else {\n\n\t\tintersect = ray.intersectTriangle( pA, pB, pC, side !== DoubleSide, point );\n\n\t}\n\n\tif ( intersect === null ) return null;\n\n\tconst distance = ray.origin.distanceTo( point );\n\n\tif ( distance < near || distance > far ) return null;\n\n\treturn {\n\n\t\tdistance: distance,\n\t\tpoint: point.clone(),\n\n\t};\n\n}\n\nfunction checkBufferGeometryIntersection( ray, position, normal, uv, uv1, a, b, c, side, near, far ) {\n\n\t_vA.fromBufferAttribute( position, a );\n\t_vB.fromBufferAttribute( position, b );\n\t_vC.fromBufferAttribute( position, c );\n\n\tconst intersection = checkIntersection( ray, _vA, _vB, _vC, _intersectionPoint, side, near, far );\n\n\tif ( intersection ) {\n\n\t\tif ( uv ) {\n\n\t\t\t_uvA.fromBufferAttribute( uv, a );\n\t\t\t_uvB.fromBufferAttribute( uv, b );\n\t\t\t_uvC.fromBufferAttribute( uv, c );\n\n\t\t\tintersection.uv = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );\n\n\t\t}\n\n\t\tif ( uv1 ) {\n\n\t\t\t_uvA.fromBufferAttribute( uv1, a );\n\t\t\t_uvB.fromBufferAttribute( uv1, b );\n\t\t\t_uvC.fromBufferAttribute( uv1, c );\n\n\t\t\tintersection.uv1 = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );\n\n\t\t}\n\n\t\tif ( normal ) {\n\n\t\t\t_normalA.fromBufferAttribute( normal, a );\n\t\t\t_normalB.fromBufferAttribute( normal, b );\n\t\t\t_normalC.fromBufferAttribute( normal, c );\n\n\t\t\tintersection.normal = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _normalA, _normalB, _normalC, new Vector3() );\n\t\t\tif ( intersection.normal.dot( ray.direction ) > 0 ) {\n\n\t\t\t\tintersection.normal.multiplyScalar( - 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst face = {\n\t\t\ta: a,\n\t\t\tb: b,\n\t\t\tc: c,\n\t\t\tnormal: new Vector3(),\n\t\t\tmaterialIndex: 0\n\t\t};\n\n\t\tTriangle.getNormal( _vA, _vB, _vC, face.normal );\n\n\t\tintersection.face = face;\n\t\tintersection.faceIndex = a;\n\n\t}\n\n\treturn intersection;\n\n}\n\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L258\nfunction intersectTri( geo, side, ray, tri, intersections, near, far ) {\n\n\tconst triOffset = tri * 3;\n\tlet a = triOffset + 0;\n\tlet b = triOffset + 1;\n\tlet c = triOffset + 2;\n\n\tconst index = geo.index;\n\tif ( geo.index ) {\n\n\t\ta = index.getX( a );\n\t\tb = index.getX( b );\n\t\tc = index.getX( c );\n\n\t}\n\n\tconst { position, normal, uv, uv1 } = geo.attributes;\n\tconst intersection = checkBufferGeometryIntersection( ray, position, normal, uv, uv1, a, b, c, side, near, far );\n\n\tif ( intersection ) {\n\n\t\tintersection.faceIndex = tri;\n\t\tif ( intersections ) intersections.push( intersection );\n\t\treturn intersection;\n\n\t}\n\n\treturn null;\n\n}\n\nexport { intersectTri };\n","\nimport { Vector2, Vector3, Triangle } from 'three';\n\n// sets the vertices of triangle `tri` with the 3 vertices after i\nexport function setTriangle( tri, i, index, pos ) {\n\n\tconst ta = tri.a;\n\tconst tb = tri.b;\n\tconst tc = tri.c;\n\n\tlet i0 = i;\n\tlet i1 = i + 1;\n\tlet i2 = i + 2;\n\tif ( index ) {\n\n\t\ti0 = index.getX( i0 );\n\t\ti1 = index.getX( i1 );\n\t\ti2 = index.getX( i2 );\n\n\t}\n\n\tta.x = pos.getX( i0 );\n\tta.y = pos.getY( i0 );\n\tta.z = pos.getZ( i0 );\n\n\ttb.x = pos.getX( i1 );\n\ttb.y = pos.getY( i1 );\n\ttb.z = pos.getZ( i1 );\n\n\ttc.x = pos.getX( i2 );\n\ttc.y = pos.getY( i2 );\n\ttc.z = pos.getZ( i2 );\n\n}\n\nconst tempV1 = /* @__PURE__ */ new Vector3();\nconst tempV2 = /* @__PURE__ */ new Vector3();\nconst tempV3 = /* @__PURE__ */ new Vector3();\nconst tempUV1 = /* @__PURE__ */ new Vector2();\nconst tempUV2 = /* @__PURE__ */ new Vector2();\nconst tempUV3 = /* @__PURE__ */ new Vector2();\n\nexport function getTriangleHitPointInfo( point, geometry, triangleIndex, target ) {\n\n\tconst indices = geometry.getIndex().array;\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst uvs = geometry.getAttribute( 'uv' );\n\n\tconst a = indices[ triangleIndex * 3 ];\n\tconst b = indices[ triangleIndex * 3 + 1 ];\n\tconst c = indices[ triangleIndex * 3 + 2 ];\n\n\ttempV1.fromBufferAttribute( positions, a );\n\ttempV2.fromBufferAttribute( positions, b );\n\ttempV3.fromBufferAttribute( positions, c );\n\n\t// find the associated material index\n\tlet materialIndex = 0;\n\tconst groups = geometry.groups;\n\tconst firstVertexIndex = triangleIndex * 3;\n\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\t\tconst { start, count } = group;\n\t\tif ( firstVertexIndex >= start && firstVertexIndex < start + count ) {\n\n\t\t\tmaterialIndex = group.materialIndex;\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\t// extract uvs\n\tlet uv = null;\n\tif ( uvs ) {\n\n\t\ttempUV1.fromBufferAttribute( uvs, a );\n\t\ttempUV2.fromBufferAttribute( uvs, b );\n\t\ttempUV3.fromBufferAttribute( uvs, c );\n\n\t\tif ( target && target.uv ) uv = target.uv;\n\t\telse uv = new Vector2();\n\n\t\tTriangle.getInterpolation( point, tempV1, tempV2, tempV3, tempUV1, tempUV2, tempUV3, uv );\n\n\t}\n\n\t// adjust the provided target or create a new one\n\tif ( target ) {\n\n\t\tif ( ! target.face ) target.face = { };\n\t\ttarget.face.a = a;\n\t\ttarget.face.b = b;\n\t\ttarget.face.c = c;\n\t\ttarget.face.materialIndex = materialIndex;\n\t\tif ( ! target.face.normal ) target.face.normal = new Vector3();\n\t\tTriangle.getNormal( tempV1, tempV2, tempV3, target.face.normal );\n\n\t\tif ( uv ) target.uv = uv;\n\n\t\treturn target;\n\n\t} else {\n\n\t\treturn {\n\t\t\tface: {\n\t\t\t\ta: a,\n\t\t\t\tb: b,\n\t\t\t\tc: c,\n\t\t\t\tmaterialIndex: materialIndex,\n\t\t\t\tnormal: Triangle.getNormal( tempV1, tempV2, tempV3, new Vector3() )\n\t\t\t},\n\t\t\tuv: uv\n\t\t};\n\n\t}\n\n}\n","import { intersectTri } from '../../utils/ThreeRayIntersectUtilities.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\n\n/*************************************************************/\n/* This file is generated from \"iterationUtils.template.js\". */\n/*************************************************************/\n/* eslint-disable indent */\n\nfunction intersectTris( bvh, side, ray, offset, count, intersections, near, far ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\n\t\tintersectTri( geometry, side, ray, i, intersections, near, far );\n\n\n\t}\n\n}\n\nfunction intersectClosestTri( bvh, side, ray, offset, count, near, far ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tlet dist = Infinity;\n\tlet res = null;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tlet intersection;\n\n\t\tintersection = intersectTri( geometry, side, ray, i, null, near, far );\n\n\n\t\tif ( intersection && intersection.distance < dist ) {\n\n\t\t\tres = intersection;\n\t\t\tdist = intersection.distance;\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\nfunction iterateOverTriangles(\n\toffset,\n\tcount,\n\tbvh,\n\tintersectsTriangleFunc,\n\tcontained,\n\tdepth,\n\ttriangle\n) {\n\n\tconst { geometry } = bvh;\n\tconst { index } = geometry;\n\tconst pos = geometry.attributes.position;\n\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\tlet tri;\n\n\t\ttri = i;\n\n\t\tsetTriangle( triangle, tri * 3, index, pos );\n\t\ttriangle.needsUpdate = true;\n\n\t\tif ( intersectsTriangleFunc( triangle, tri, contained, depth ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\nexport { intersectClosestTri, intersectTris, iterateOverTriangles };\n","import { IS_LEAFNODE_FLAG } from '../Constants.js';\n\n/****************************************************/\n/* This file is generated from \"refit.template.js\". */\n/****************************************************/\n\nfunction refit( bvh, nodeIndices = null ) {\n\n\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\n\n\t\tnodeIndices = new Set( nodeIndices );\n\n\t}\n\n\tconst geometry = bvh.geometry;\n\tconst indexArr = geometry.index ? geometry.index.array : null;\n\tconst posAttr = geometry.attributes.position;\n\n\tlet buffer, uint32Array, uint16Array, float32Array;\n\tlet byteOffset = 0;\n\tconst roots = bvh._roots;\n\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\tbuffer = roots[ i ];\n\t\tuint32Array = new Uint32Array( buffer );\n\t\tuint16Array = new Uint16Array( buffer );\n\t\tfloat32Array = new Float32Array( buffer );\n\n\t\t_traverse( 0, byteOffset );\n\t\tbyteOffset += buffer.byteLength;\n\n\t}\n\n\tfunction _traverse( node32Index, byteOffset, force = false ) {\n\n\t\tconst node16Index = node32Index * 2;\n\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\n\t\t\tlet minx = Infinity;\n\t\t\tlet miny = Infinity;\n\t\t\tlet minz = Infinity;\n\t\t\tlet maxx = - Infinity;\n\t\t\tlet maxy = - Infinity;\n\t\t\tlet maxz = - Infinity;\n\n\n\t\t\tfor ( let i = 3 * offset, l = 3 * ( offset + count ); i < l; i ++ ) {\n\n\t\t\t\tlet index = indexArr[ i ];\n\t\t\t\tconst x = posAttr.getX( index );\n\t\t\t\tconst y = posAttr.getY( index );\n\t\t\t\tconst z = posAttr.getZ( index );\n\n\t\t\t\tif ( x < minx ) minx = x;\n\t\t\t\tif ( x > maxx ) maxx = x;\n\n\t\t\t\tif ( y < miny ) miny = y;\n\t\t\t\tif ( y > maxy ) maxy = y;\n\n\t\t\t\tif ( z < minz ) minz = z;\n\t\t\t\tif ( z > maxz ) maxz = z;\n\n\t\t\t}\n\n\n\t\t\tif (\n\t\t\t\tfloat32Array[ node32Index + 0 ] !== minx ||\n\t\t\t\tfloat32Array[ node32Index + 1 ] !== miny ||\n\t\t\t\tfloat32Array[ node32Index + 2 ] !== minz ||\n\n\t\t\t\tfloat32Array[ node32Index + 3 ] !== maxx ||\n\t\t\t\tfloat32Array[ node32Index + 4 ] !== maxy ||\n\t\t\t\tfloat32Array[ node32Index + 5 ] !== maxz\n\t\t\t) {\n\n\t\t\t\tfloat32Array[ node32Index + 0 ] = minx;\n\t\t\t\tfloat32Array[ node32Index + 1 ] = miny;\n\t\t\t\tfloat32Array[ node32Index + 2 ] = minz;\n\n\t\t\t\tfloat32Array[ node32Index + 3 ] = maxx;\n\t\t\t\tfloat32Array[ node32Index + 4 ] = maxy;\n\t\t\t\tfloat32Array[ node32Index + 5 ] = maxz;\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst left = node32Index + 8;\n\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\n\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\n\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\n\t\t\tconst offsetLeft = left + byteOffset;\n\t\t\tconst offsetRight = right + byteOffset;\n\t\t\tlet forceChildren = force;\n\t\t\tlet includesLeft = false;\n\t\t\tlet includesRight = false;\n\n\t\t\tif ( nodeIndices ) {\n\n\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\n\t\t\t\t// then we assume that all children need to be updated.\n\t\t\t\tif ( ! forceChildren ) {\n\n\t\t\t\t\tincludesLeft = nodeIndices.has( offsetLeft );\n\t\t\t\t\tincludesRight = nodeIndices.has( offsetRight );\n\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tincludesLeft = true;\n\t\t\t\tincludesRight = true;\n\n\t\t\t}\n\n\t\t\tconst traverseLeft = forceChildren || includesLeft;\n\t\t\tconst traverseRight = forceChildren || includesRight;\n\n\t\t\tlet leftChange = false;\n\t\t\tif ( traverseLeft ) {\n\n\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tlet rightChange = false;\n\t\t\tif ( traverseRight ) {\n\n\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tconst didChange = leftChange || rightChange;\n\t\t\tif ( didChange ) {\n\n\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tconst lefti = left + i;\n\t\t\t\t\tconst righti = right + i;\n\t\t\t\t\tconst minLeftValue = float32Array[ lefti ];\n\t\t\t\t\tconst maxLeftValue = float32Array[ lefti + 3 ];\n\t\t\t\t\tconst minRightValue = float32Array[ righti ];\n\t\t\t\t\tconst maxRightValue = float32Array[ righti + 3 ];\n\n\t\t\t\t\tfloat32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n\t\t\t\t\tfloat32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn didChange;\n\n\t\t}\n\n\t}\n\n}\n\nexport { refit };\n","/**\n * This function performs intersection tests similar to Ray.intersectBox in three.js,\n * with the difference that the box values are read from an array to improve performance.\n */\nexport function intersectRay( nodeIndex32, array, ray, near, far ) {\n\n\tlet tmin, tmax, tymin, tymax, tzmin, tzmax;\n\n\tconst invdirx = 1 / ray.direction.x,\n\t\tinvdiry = 1 / ray.direction.y,\n\t\tinvdirz = 1 / ray.direction.z;\n\n\tconst ox = ray.origin.x;\n\tconst oy = ray.origin.y;\n\tconst oz = ray.origin.z;\n\n\tlet minx = array[ nodeIndex32 ];\n\tlet maxx = array[ nodeIndex32 + 3 ];\n\n\tlet miny = array[ nodeIndex32 + 1 ];\n\tlet maxy = array[ nodeIndex32 + 3 + 1 ];\n\n\tlet minz = array[ nodeIndex32 + 2 ];\n\tlet maxz = array[ nodeIndex32 + 3 + 2 ];\n\n\tif ( invdirx >= 0 ) {\n\n\t\ttmin = ( minx - ox ) * invdirx;\n\t\ttmax = ( maxx - ox ) * invdirx;\n\n\t} else {\n\n\t\ttmin = ( maxx - ox ) * invdirx;\n\t\ttmax = ( minx - ox ) * invdirx;\n\n\t}\n\n\tif ( invdiry >= 0 ) {\n\n\t\ttymin = ( miny - oy ) * invdiry;\n\t\ttymax = ( maxy - oy ) * invdiry;\n\n\t} else {\n\n\t\ttymin = ( maxy - oy ) * invdiry;\n\t\ttymax = ( miny - oy ) * invdiry;\n\n\t}\n\n\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return false;\n\n\tif ( tymin > tmin || isNaN( tmin ) ) tmin = tymin;\n\n\tif ( tymax < tmax || isNaN( tmax ) ) tmax = tymax;\n\n\tif ( invdirz >= 0 ) {\n\n\t\ttzmin = ( minz - oz ) * invdirz;\n\t\ttzmax = ( maxz - oz ) * invdirz;\n\n\t} else {\n\n\t\ttzmin = ( maxz - oz ) * invdirz;\n\t\ttzmax = ( minz - oz ) * invdirz;\n\n\t}\n\n\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return false;\n\n\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\n\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\n\t//return point closest to the ray (positive side)\n\n\treturn tmin <= far && tmax >= near;\n\n}\n","import { intersectTri } from '../../utils/ThreeRayIntersectUtilities.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\n\n/*************************************************************/\n/* This file is generated from \"iterationUtils.template.js\". */\n/*************************************************************/\n/* eslint-disable indent */\n\nfunction intersectTris_indirect( bvh, side, ray, offset, count, intersections, near, far ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tlet vi = _indirectBuffer ? _indirectBuffer[ i ] : i;\n\t\tintersectTri( geometry, side, ray, vi, intersections, near, far );\n\n\n\t}\n\n}\n\nfunction intersectClosestTri_indirect( bvh, side, ray, offset, count, near, far ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tlet dist = Infinity;\n\tlet res = null;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tlet intersection;\n\t\tintersection = intersectTri( geometry, side, ray, _indirectBuffer ? _indirectBuffer[ i ] : i, null, near, far );\n\n\n\t\tif ( intersection && intersection.distance < dist ) {\n\n\t\t\tres = intersection;\n\t\t\tdist = intersection.distance;\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\nfunction iterateOverTriangles_indirect(\n\toffset,\n\tcount,\n\tbvh,\n\tintersectsTriangleFunc,\n\tcontained,\n\tdepth,\n\ttriangle\n) {\n\n\tconst { geometry } = bvh;\n\tconst { index } = geometry;\n\tconst pos = geometry.attributes.position;\n\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\tlet tri;\n\t\ttri = bvh.resolveTriangleIndex( i );\n\n\t\tsetTriangle( triangle, tri * 3, index, pos );\n\t\ttriangle.needsUpdate = true;\n\n\t\tif ( intersectsTriangleFunc( triangle, tri, contained, depth ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\nexport { intersectClosestTri_indirect, intersectTris_indirect, iterateOverTriangles_indirect };\n","import { intersectRay } from '../utils/intersectUtils.js';\nimport { IS_LEAF, OFFSET, COUNT, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { intersectTris } from '../utils/iterationUtils.generated.js';\nimport '../utils/iterationUtils_indirect.generated.js';\n\n/******************************************************/\n/* This file is generated from \"raycast.template.js\". */\n/******************************************************/\n\nfunction raycast( bvh, root, side, ray, intersects, near, far ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\t_raycast( 0, bvh, side, ray, intersects, near, far );\n\tBufferStack.clearBuffer();\n\n}\n\nfunction _raycast( nodeIndex32, bvh, side, ray, intersects, near, far ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tconst nodeIndex16 = nodeIndex32 * 2;\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\n\t\tintersectTris( bvh, side, ray, offset, count, intersects, near, far );\n\n\n\t} else {\n\n\t\tconst leftIndex = LEFT_NODE( nodeIndex32 );\n\t\tif ( intersectRay( leftIndex, float32Array, ray, near, far ) ) {\n\n\t\t\t_raycast( leftIndex, bvh, side, ray, intersects, near, far );\n\n\t\t}\n\n\t\tconst rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tif ( intersectRay( rightIndex, float32Array, ray, near, far ) ) {\n\n\t\t\t_raycast( rightIndex, bvh, side, ray, intersects, near, far );\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycast };\n","import { IS_LEAF, OFFSET, COUNT, SPLIT_AXIS, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { intersectRay } from '../utils/intersectUtils.js';\nimport { intersectClosestTri } from '../utils/iterationUtils.generated.js';\nimport '../utils/iterationUtils_indirect.generated.js';\n\n/***********************************************************/\n/* This file is generated from \"raycastFirst.template.js\". */\n/***********************************************************/\n\nconst _xyzFields = [ 'x', 'y', 'z' ];\n\nfunction raycastFirst( bvh, root, side, ray, near, far ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _raycastFirst( 0, bvh, side, ray, near, far );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _raycastFirst( nodeIndex32, bvh, side, ray, near, far ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\n\t\t// eslint-disable-next-line no-unreachable\n\t\treturn intersectClosestTri( bvh, side, ray, offset, count, near, far );\n\n\n\t} else {\n\n\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\n\t\t// the ray is coming from, look for an intersection among that side of the tree first\n\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\t\tconst xyzAxis = _xyzFields[ splitAxis ];\n\t\tconst rayDir = ray.direction[ xyzAxis ];\n\t\tconst leftToRight = rayDir >= 0;\n\n\t\t// c1 is the child to check first\n\t\tlet c1, c2;\n\t\tif ( leftToRight ) {\n\n\t\t\tc1 = LEFT_NODE( nodeIndex32 );\n\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t} else {\n\n\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tc2 = LEFT_NODE( nodeIndex32 );\n\n\t\t}\n\n\t\tconst c1Intersection = intersectRay( c1, float32Array, ray, near, far );\n\t\tconst c1Result = c1Intersection ? _raycastFirst( c1, bvh, side, ray, near, far ) : null;\n\n\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\n\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\n\t\tif ( c1Result ) {\n\n\t\t\t// check if the point is within the second bounds\n\t\t\t// \"point\" is in the local frame of the bvh\n\t\t\tconst point = c1Result.point[ xyzAxis ];\n\t\t\tconst isOutside = leftToRight ?\n\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\n\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\n\n\t\t\tif ( isOutside ) {\n\n\t\t\t\treturn c1Result;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// either there was no intersection in the first node, or there could still be a closer\n\t\t// intersection in the second, so check the second node and then take the better of the two\n\t\tconst c2Intersection = intersectRay( c2, float32Array, ray, near, far );\n\t\tconst c2Result = c2Intersection ? _raycastFirst( c2, bvh, side, ray, near, far ) : null;\n\n\t\tif ( c1Result && c2Result ) {\n\n\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n\n\t\t} else {\n\n\t\t\treturn c1Result || c2Result || null;\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycastFirst };\n","import { Box3, Matrix4 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../../math/ExtendedTriangle.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { IS_LEAF, OFFSET, COUNT, BOUNDING_DATA_INDEX } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\n\n/*****************************************************************/\n/* This file is generated from \"intersectsGeometry.template.js\". */\n/*****************************************************************/\n/* eslint-disable indent */\n\nconst boundingBox = /* @__PURE__ */ new Box3();\nconst triangle = /* @__PURE__ */ new ExtendedTriangle();\nconst triangle2 = /* @__PURE__ */ new ExtendedTriangle();\nconst invertedMat = /* @__PURE__ */ new Matrix4();\n\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\n\nfunction intersectsGeometry( bvh, root, otherGeometry, geometryToBvh ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _intersectsGeometry( 0, bvh, otherGeometry, geometryToBvh );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _intersectsGeometry( nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tif ( cachedObb === null ) {\n\n\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\totherGeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\tcachedObb = obb;\n\n\t}\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst thisGeometry = bvh.geometry;\n\t\tconst thisIndex = thisGeometry.index;\n\t\tconst thisPos = thisGeometry.attributes.position;\n\n\t\tconst index = otherGeometry.index;\n\t\tconst pos = otherGeometry.attributes.position;\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\n\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\n\t\t// here.\n\t\tinvertedMat.copy( geometryToBvh ).invert();\n\n\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t// if there's a bounds tree\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2 );\n\t\t\tobb2.matrix.copy( invertedMat );\n\t\t\tobb2.needsUpdate = true;\n\n\t\t\t// TODO: use a triangle iteration function here\n\t\t\tconst res = otherGeometry.boundsTree.shapecast( {\n\n\t\t\t\tintersectsBounds: box => obb2.intersectsBox( box ),\n\n\t\t\t\tintersectsTriangle: tri => {\n\n\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.needsUpdate = true;\n\n\n\t\t\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\t\tsetTriangle( triangle2, i, thisIndex, thisPos );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn res;\n\n\t\t} else {\n\n\t\t\t// if we're just dealing with raw geometry\n\n\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\tsetTriangle( triangle, i, thisIndex, thisPos );\n\n\n\t\t\t\ttriangle.a.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.b.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.c.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\tfor ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\tsetTriangle( triangle2, i2, index, pos );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tif ( triangle.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t}\n\n\n\t\t}\n\n\t} else {\n\n\t\tconst left = nodeIndex32 + 8;\n\t\tconst right = uint32Array[ nodeIndex32 + 6 ];\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox );\n\t\tconst leftIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( left, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( leftIntersection ) return true;\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox );\n\t\tconst rightIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( right, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( rightIntersection ) return true;\n\n\t\treturn false;\n\n\t}\n\n}\n\nexport { intersectsGeometry };\n","import { Matrix4, Vector3 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { getTriCount } from '../build/geometryUtils.js';\nimport { ExtendedTrianglePool } from '../../utils/ExtendedTrianglePool.js';\n\n/*********************************************************************/\n/* This file is generated from \"closestPointToGeometry.template.js\". */\n/*********************************************************************/\n\nconst tempMatrix = /* @__PURE__ */ new Matrix4();\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\nconst temp1 = /* @__PURE__ */ new Vector3();\nconst temp2 = /* @__PURE__ */ new Vector3();\nconst temp3 = /* @__PURE__ */ new Vector3();\nconst temp4 = /* @__PURE__ */ new Vector3();\n\nfunction closestPointToGeometry(\n\tbvh,\n\totherGeometry,\n\tgeometryToBvh,\n\ttarget1 = { },\n\ttarget2 = { },\n\tminThreshold = 0,\n\tmaxThreshold = Infinity,\n) {\n\n\tif ( ! otherGeometry.boundingBox ) {\n\n\t\totherGeometry.computeBoundingBox();\n\n\t}\n\n\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\tobb.needsUpdate = true;\n\n\tconst geometry = bvh.geometry;\n\tconst pos = geometry.attributes.position;\n\tconst index = geometry.index;\n\tconst otherPos = otherGeometry.attributes.position;\n\tconst otherIndex = otherGeometry.index;\n\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\n\tlet tempTarget1 = temp1;\n\tlet tempTargetDest1 = temp2;\n\tlet tempTarget2 = null;\n\tlet tempTargetDest2 = null;\n\n\tif ( target2 ) {\n\n\t\ttempTarget2 = temp3;\n\t\ttempTargetDest2 = temp4;\n\n\t}\n\n\tlet closestDistance = Infinity;\n\tlet closestDistanceTriIndex = null;\n\tlet closestDistanceOtherTriIndex = null;\n\ttempMatrix.copy( geometryToBvh ).invert();\n\tobb2.matrix.copy( tempMatrix );\n\tbvh.shapecast(\n\t\t{\n\n\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\treturn obb.distanceToBox( box );\n\n\t\t\t},\n\n\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\n\n\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\n\t\t\t\t\t// save the bounds to use during triangle checks.\n\t\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\t\tobb2.min.copy( box.min );\n\t\t\t\t\t\tobb2.max.copy( box.max );\n\t\t\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t},\n\n\t\t\tintersectsRange: ( offset, count ) => {\n\n\t\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n\t\t\t\t\t// the closest bounds in the other geometry to check.\n\t\t\t\t\tconst otherBvh = otherGeometry.boundsTree;\n\t\t\t\t\treturn otherBvh.shapecast( {\n\t\t\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\t\t\treturn obb2.distanceToBox( box );\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\n\n\t\t\t\t\t\t\tfor ( let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2 ++ ) {\n\n\n\t\t\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\n\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle, 3 * i, index, pos );\n\n\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t},\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\n\t\t\t\t\tconst triCount = getTriCount( otherGeometry );\n\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\n\t\t\t\t\t\t\tsetTriangle( triangle, 3 * i, index, pos );\n\n\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t}\n\n\t);\n\n\tExtendedTrianglePool.releasePrimitive( triangle );\n\tExtendedTrianglePool.releasePrimitive( triangle2 );\n\n\tif ( closestDistance === Infinity ) {\n\n\t\treturn null;\n\n\t}\n\n\tif ( ! target1.point ) {\n\n\t\ttarget1.point = tempTargetDest1.clone();\n\n\t} else {\n\n\t\ttarget1.point.copy( tempTargetDest1 );\n\n\t}\n\n\ttarget1.distance = closestDistance,\n\ttarget1.faceIndex = closestDistanceTriIndex;\n\n\tif ( target2 ) {\n\n\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\n\t\telse target2.point.copy( tempTargetDest2 );\n\t\ttarget2.point.applyMatrix4( tempMatrix );\n\t\ttempTargetDest1.applyMatrix4( tempMatrix );\n\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\n\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\n\n\t}\n\n\treturn target1;\n\n}\n\nexport { closestPointToGeometry };\n","import { IS_LEAFNODE_FLAG } from '../Constants.js';\n\n/****************************************************/\n/* This file is generated from \"refit.template.js\". */\n/****************************************************/\n\nfunction refit_indirect( bvh, nodeIndices = null ) {\n\n\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\n\n\t\tnodeIndices = new Set( nodeIndices );\n\n\t}\n\n\tconst geometry = bvh.geometry;\n\tconst indexArr = geometry.index ? geometry.index.array : null;\n\tconst posAttr = geometry.attributes.position;\n\n\tlet buffer, uint32Array, uint16Array, float32Array;\n\tlet byteOffset = 0;\n\tconst roots = bvh._roots;\n\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\tbuffer = roots[ i ];\n\t\tuint32Array = new Uint32Array( buffer );\n\t\tuint16Array = new Uint16Array( buffer );\n\t\tfloat32Array = new Float32Array( buffer );\n\n\t\t_traverse( 0, byteOffset );\n\t\tbyteOffset += buffer.byteLength;\n\n\t}\n\n\tfunction _traverse( node32Index, byteOffset, force = false ) {\n\n\t\tconst node16Index = node32Index * 2;\n\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\n\t\t\tlet minx = Infinity;\n\t\t\tlet miny = Infinity;\n\t\t\tlet minz = Infinity;\n\t\t\tlet maxx = - Infinity;\n\t\t\tlet maxy = - Infinity;\n\t\t\tlet maxz = - Infinity;\n\n\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\tconst t = 3 * bvh.resolveTriangleIndex( i );\n\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\tlet index = t + j;\n\t\t\t\t\tindex = indexArr ? indexArr[ index ] : index;\n\n\t\t\t\t\tconst x = posAttr.getX( index );\n\t\t\t\t\tconst y = posAttr.getY( index );\n\t\t\t\t\tconst z = posAttr.getZ( index );\n\n\t\t\t\t\tif ( x < minx ) minx = x;\n\t\t\t\t\tif ( x > maxx ) maxx = x;\n\n\t\t\t\t\tif ( y < miny ) miny = y;\n\t\t\t\t\tif ( y > maxy ) maxy = y;\n\n\t\t\t\t\tif ( z < minz ) minz = z;\n\t\t\t\t\tif ( z > maxz ) maxz = z;\n\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tif (\n\t\t\t\tfloat32Array[ node32Index + 0 ] !== minx ||\n\t\t\t\tfloat32Array[ node32Index + 1 ] !== miny ||\n\t\t\t\tfloat32Array[ node32Index + 2 ] !== minz ||\n\n\t\t\t\tfloat32Array[ node32Index + 3 ] !== maxx ||\n\t\t\t\tfloat32Array[ node32Index + 4 ] !== maxy ||\n\t\t\t\tfloat32Array[ node32Index + 5 ] !== maxz\n\t\t\t) {\n\n\t\t\t\tfloat32Array[ node32Index + 0 ] = minx;\n\t\t\t\tfloat32Array[ node32Index + 1 ] = miny;\n\t\t\t\tfloat32Array[ node32Index + 2 ] = minz;\n\n\t\t\t\tfloat32Array[ node32Index + 3 ] = maxx;\n\t\t\t\tfloat32Array[ node32Index + 4 ] = maxy;\n\t\t\t\tfloat32Array[ node32Index + 5 ] = maxz;\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst left = node32Index + 8;\n\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\n\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\n\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\n\t\t\tconst offsetLeft = left + byteOffset;\n\t\t\tconst offsetRight = right + byteOffset;\n\t\t\tlet forceChildren = force;\n\t\t\tlet includesLeft = false;\n\t\t\tlet includesRight = false;\n\n\t\t\tif ( nodeIndices ) {\n\n\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\n\t\t\t\t// then we assume that all children need to be updated.\n\t\t\t\tif ( ! forceChildren ) {\n\n\t\t\t\t\tincludesLeft = nodeIndices.has( offsetLeft );\n\t\t\t\t\tincludesRight = nodeIndices.has( offsetRight );\n\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tincludesLeft = true;\n\t\t\t\tincludesRight = true;\n\n\t\t\t}\n\n\t\t\tconst traverseLeft = forceChildren || includesLeft;\n\t\t\tconst traverseRight = forceChildren || includesRight;\n\n\t\t\tlet leftChange = false;\n\t\t\tif ( traverseLeft ) {\n\n\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tlet rightChange = false;\n\t\t\tif ( traverseRight ) {\n\n\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tconst didChange = leftChange || rightChange;\n\t\t\tif ( didChange ) {\n\n\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tconst lefti = left + i;\n\t\t\t\t\tconst righti = right + i;\n\t\t\t\t\tconst minLeftValue = float32Array[ lefti ];\n\t\t\t\t\tconst maxLeftValue = float32Array[ lefti + 3 ];\n\t\t\t\t\tconst minRightValue = float32Array[ righti ];\n\t\t\t\t\tconst maxRightValue = float32Array[ righti + 3 ];\n\n\t\t\t\t\tfloat32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n\t\t\t\t\tfloat32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn didChange;\n\n\t\t}\n\n\t}\n\n}\n\nexport { refit_indirect };\n","import { intersectRay } from '../utils/intersectUtils.js';\nimport { IS_LEAF, OFFSET, COUNT, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport '../utils/iterationUtils.generated.js';\nimport { intersectTris_indirect } from '../utils/iterationUtils_indirect.generated.js';\n\n/******************************************************/\n/* This file is generated from \"raycast.template.js\". */\n/******************************************************/\n\nfunction raycast_indirect( bvh, root, side, ray, intersects, near, far ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\t_raycast( 0, bvh, side, ray, intersects, near, far );\n\tBufferStack.clearBuffer();\n\n}\n\nfunction _raycast( nodeIndex32, bvh, side, ray, intersects, near, far ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tconst nodeIndex16 = nodeIndex32 * 2;\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\tintersectTris_indirect( bvh, side, ray, offset, count, intersects, near, far );\n\n\n\t} else {\n\n\t\tconst leftIndex = LEFT_NODE( nodeIndex32 );\n\t\tif ( intersectRay( leftIndex, float32Array, ray, near, far ) ) {\n\n\t\t\t_raycast( leftIndex, bvh, side, ray, intersects, near, far );\n\n\t\t}\n\n\t\tconst rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tif ( intersectRay( rightIndex, float32Array, ray, near, far ) ) {\n\n\t\t\t_raycast( rightIndex, bvh, side, ray, intersects, near, far );\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycast_indirect };\n","import { IS_LEAF, OFFSET, COUNT, SPLIT_AXIS, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { intersectRay } from '../utils/intersectUtils.js';\nimport '../utils/iterationUtils.generated.js';\nimport { intersectClosestTri_indirect } from '../utils/iterationUtils_indirect.generated.js';\n\n/***********************************************************/\n/* This file is generated from \"raycastFirst.template.js\". */\n/***********************************************************/\n\nconst _xyzFields = [ 'x', 'y', 'z' ];\n\nfunction raycastFirst_indirect( bvh, root, side, ray, near, far ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _raycastFirst( 0, bvh, side, ray, near, far );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _raycastFirst( nodeIndex32, bvh, side, ray, near, far ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\treturn intersectClosestTri_indirect( bvh, side, ray, offset, count, near, far );\n\n\n\t} else {\n\n\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\n\t\t// the ray is coming from, look for an intersection among that side of the tree first\n\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\t\tconst xyzAxis = _xyzFields[ splitAxis ];\n\t\tconst rayDir = ray.direction[ xyzAxis ];\n\t\tconst leftToRight = rayDir >= 0;\n\n\t\t// c1 is the child to check first\n\t\tlet c1, c2;\n\t\tif ( leftToRight ) {\n\n\t\t\tc1 = LEFT_NODE( nodeIndex32 );\n\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t} else {\n\n\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tc2 = LEFT_NODE( nodeIndex32 );\n\n\t\t}\n\n\t\tconst c1Intersection = intersectRay( c1, float32Array, ray, near, far );\n\t\tconst c1Result = c1Intersection ? _raycastFirst( c1, bvh, side, ray, near, far ) : null;\n\n\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\n\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\n\t\tif ( c1Result ) {\n\n\t\t\t// check if the point is within the second bounds\n\t\t\t// \"point\" is in the local frame of the bvh\n\t\t\tconst point = c1Result.point[ xyzAxis ];\n\t\t\tconst isOutside = leftToRight ?\n\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\n\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\n\n\t\t\tif ( isOutside ) {\n\n\t\t\t\treturn c1Result;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// either there was no intersection in the first node, or there could still be a closer\n\t\t// intersection in the second, so check the second node and then take the better of the two\n\t\tconst c2Intersection = intersectRay( c2, float32Array, ray, near, far );\n\t\tconst c2Result = c2Intersection ? _raycastFirst( c2, bvh, side, ray, near, far ) : null;\n\n\t\tif ( c1Result && c2Result ) {\n\n\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n\n\t\t} else {\n\n\t\t\treturn c1Result || c2Result || null;\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycastFirst_indirect };\n","import { Box3, Matrix4 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../../math/ExtendedTriangle.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { IS_LEAF, OFFSET, COUNT, BOUNDING_DATA_INDEX } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\n\n/*****************************************************************/\n/* This file is generated from \"intersectsGeometry.template.js\". */\n/*****************************************************************/\n/* eslint-disable indent */\n\nconst boundingBox = /* @__PURE__ */ new Box3();\nconst triangle = /* @__PURE__ */ new ExtendedTriangle();\nconst triangle2 = /* @__PURE__ */ new ExtendedTriangle();\nconst invertedMat = /* @__PURE__ */ new Matrix4();\n\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\n\nfunction intersectsGeometry_indirect( bvh, root, otherGeometry, geometryToBvh ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _intersectsGeometry( 0, bvh, otherGeometry, geometryToBvh );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _intersectsGeometry( nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tif ( cachedObb === null ) {\n\n\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\totherGeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\tcachedObb = obb;\n\n\t}\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst thisGeometry = bvh.geometry;\n\t\tconst thisIndex = thisGeometry.index;\n\t\tconst thisPos = thisGeometry.attributes.position;\n\n\t\tconst index = otherGeometry.index;\n\t\tconst pos = otherGeometry.attributes.position;\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\n\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\n\t\t// here.\n\t\tinvertedMat.copy( geometryToBvh ).invert();\n\n\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t// if there's a bounds tree\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2 );\n\t\t\tobb2.matrix.copy( invertedMat );\n\t\t\tobb2.needsUpdate = true;\n\n\t\t\t// TODO: use a triangle iteration function here\n\t\t\tconst res = otherGeometry.boundsTree.shapecast( {\n\n\t\t\t\tintersectsBounds: box => obb2.intersectsBox( box ),\n\n\t\t\t\tintersectsTriangle: tri => {\n\n\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\t\tsetTriangle( triangle2, 3 * bvh.resolveTriangleIndex( i ), thisIndex, thisPos );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn res;\n\n\t\t} else {\n\n\t\t\t// if we're just dealing with raw geometry\n\t\t\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\tsetTriangle( triangle, 3 * ti, thisIndex, thisPos );\n\n\n\t\t\t\ttriangle.a.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.b.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.c.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\tfor ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\tsetTriangle( triangle2, i2, index, pos );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tif ( triangle.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t}\n\n\t} else {\n\n\t\tconst left = nodeIndex32 + 8;\n\t\tconst right = uint32Array[ nodeIndex32 + 6 ];\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox );\n\t\tconst leftIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( left, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( leftIntersection ) return true;\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox );\n\t\tconst rightIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( right, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( rightIntersection ) return true;\n\n\t\treturn false;\n\n\t}\n\n}\n\nexport { intersectsGeometry_indirect };\n","import { Matrix4, Vector3 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { getTriCount } from '../build/geometryUtils.js';\nimport { ExtendedTrianglePool } from '../../utils/ExtendedTrianglePool.js';\n\n/*********************************************************************/\n/* This file is generated from \"closestPointToGeometry.template.js\". */\n/*********************************************************************/\n\nconst tempMatrix = /* @__PURE__ */ new Matrix4();\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\nconst temp1 = /* @__PURE__ */ new Vector3();\nconst temp2 = /* @__PURE__ */ new Vector3();\nconst temp3 = /* @__PURE__ */ new Vector3();\nconst temp4 = /* @__PURE__ */ new Vector3();\n\nfunction closestPointToGeometry_indirect(\n\tbvh,\n\totherGeometry,\n\tgeometryToBvh,\n\ttarget1 = { },\n\ttarget2 = { },\n\tminThreshold = 0,\n\tmaxThreshold = Infinity,\n) {\n\n\tif ( ! otherGeometry.boundingBox ) {\n\n\t\totherGeometry.computeBoundingBox();\n\n\t}\n\n\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\tobb.needsUpdate = true;\n\n\tconst geometry = bvh.geometry;\n\tconst pos = geometry.attributes.position;\n\tconst index = geometry.index;\n\tconst otherPos = otherGeometry.attributes.position;\n\tconst otherIndex = otherGeometry.index;\n\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\n\tlet tempTarget1 = temp1;\n\tlet tempTargetDest1 = temp2;\n\tlet tempTarget2 = null;\n\tlet tempTargetDest2 = null;\n\n\tif ( target2 ) {\n\n\t\ttempTarget2 = temp3;\n\t\ttempTargetDest2 = temp4;\n\n\t}\n\n\tlet closestDistance = Infinity;\n\tlet closestDistanceTriIndex = null;\n\tlet closestDistanceOtherTriIndex = null;\n\ttempMatrix.copy( geometryToBvh ).invert();\n\tobb2.matrix.copy( tempMatrix );\n\tbvh.shapecast(\n\t\t{\n\n\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\treturn obb.distanceToBox( box );\n\n\t\t\t},\n\n\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\n\n\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\n\t\t\t\t\t// save the bounds to use during triangle checks.\n\t\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\t\tobb2.min.copy( box.min );\n\t\t\t\t\t\tobb2.max.copy( box.max );\n\t\t\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t},\n\n\t\t\tintersectsRange: ( offset, count ) => {\n\n\t\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n\t\t\t\t\t// the closest bounds in the other geometry to check.\n\t\t\t\t\tconst otherBvh = otherGeometry.boundsTree;\n\t\t\t\t\treturn otherBvh.shapecast( {\n\t\t\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\t\t\treturn obb2.distanceToBox( box );\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\n\n\t\t\t\t\t\t\tfor ( let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\t\t\tconst ti2 = otherBvh.resolveTriangleIndex( i2 );\n\t\t\t\t\t\t\t\tsetTriangle( triangle2, 3 * ti2, otherIndex, otherPos );\n\n\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle, 3 * ti, index, pos );\n\n\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t},\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\n\t\t\t\t\tconst triCount = getTriCount( otherGeometry );\n\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\t\t\t\tsetTriangle( triangle, 3 * ti, index, pos );\n\n\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t}\n\n\t);\n\n\tExtendedTrianglePool.releasePrimitive( triangle );\n\tExtendedTrianglePool.releasePrimitive( triangle2 );\n\n\tif ( closestDistance === Infinity ) {\n\n\t\treturn null;\n\n\t}\n\n\tif ( ! target1.point ) {\n\n\t\ttarget1.point = tempTargetDest1.clone();\n\n\t} else {\n\n\t\ttarget1.point.copy( tempTargetDest1 );\n\n\t}\n\n\ttarget1.distance = closestDistance,\n\ttarget1.faceIndex = closestDistanceTriIndex;\n\n\tif ( target2 ) {\n\n\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\n\t\telse target2.point.copy( tempTargetDest2 );\n\t\ttarget2.point.applyMatrix4( tempMatrix );\n\t\ttempTargetDest1.applyMatrix4( tempMatrix );\n\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\n\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\n\n\t}\n\n\treturn target1;\n\n}\n\nexport { closestPointToGeometry_indirect };\n","export function isSharedArrayBufferSupported() {\n\n\treturn typeof SharedArrayBuffer !== 'undefined';\n\n}\n\nexport function convertToBufferType( array, BufferConstructor ) {\n\n\tif ( array === null ) {\n\n\t\treturn array;\n\n\t} else if ( array.buffer ) {\n\n\t\tconst buffer = array.buffer;\n\t\tif ( buffer.constructor === BufferConstructor ) {\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tconst ArrayConstructor = array.constructor;\n\t\tconst result = new ArrayConstructor( new BufferConstructor( buffer.byteLength ) );\n\t\tresult.set( array );\n\t\treturn result;\n\n\t} else {\n\n\t\tif ( array.constructor === BufferConstructor ) {\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tconst result = new BufferConstructor( array.byteLength );\n\t\tnew Uint8Array( result ).set( new Uint8Array( array ) );\n\t\treturn result;\n\n\t}\n\n}\n","import { Box3, Matrix4 } from 'three';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { BOUNDING_DATA_INDEX, COUNT, IS_LEAF, LEFT_NODE, OFFSET, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { PrimitivePool } from '../../utils/PrimitivePool.js';\n\nconst _bufferStack1 = new BufferStack.constructor();\nconst _bufferStack2 = new BufferStack.constructor();\nconst _boxPool = new PrimitivePool( () => new Box3() );\nconst _leftBox1 = new Box3();\nconst _rightBox1 = new Box3();\n\nconst _leftBox2 = new Box3();\nconst _rightBox2 = new Box3();\n\nlet _active = false;\n\nexport function bvhcast( bvh, otherBvh, matrixToLocal, intersectsRanges ) {\n\n\tif ( _active ) {\n\n\t\tthrow new Error( 'MeshBVH: Recursive calls to bvhcast not supported.' );\n\n\t}\n\n\t_active = true;\n\n\tconst roots = bvh._roots;\n\tconst otherRoots = otherBvh._roots;\n\tlet result;\n\tlet offset1 = 0;\n\tlet offset2 = 0;\n\tconst invMat = new Matrix4().copy( matrixToLocal ).invert();\n\n\t// iterate over the first set of roots\n\tfor ( let i = 0, il = roots.length; i < il; i ++ ) {\n\n\t\t_bufferStack1.setBuffer( roots[ i ] );\n\t\toffset2 = 0;\n\n\t\t// prep the initial root box\n\t\tconst localBox = _boxPool.getPrimitive();\n\t\tarrayToBox( BOUNDING_DATA_INDEX( 0 ), _bufferStack1.float32Array, localBox );\n\t\tlocalBox.applyMatrix4( invMat );\n\n\t\t// iterate over the second set of roots\n\t\tfor ( let j = 0, jl = otherRoots.length; j < jl; j ++ ) {\n\n\t\t\t_bufferStack2.setBuffer( otherRoots[ j ] );\n\n\t\t\tresult = _traverse(\n\t\t\t\t0, 0, matrixToLocal, invMat, intersectsRanges,\n\t\t\t\toffset1, offset2, 0, 0,\n\t\t\t\tlocalBox,\n\t\t\t);\n\n\t\t\t_bufferStack2.clearBuffer();\n\t\t\toffset2 += otherRoots[ j ].length;\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// release stack info\n\t\t_boxPool.releasePrimitive( localBox );\n\t\t_bufferStack1.clearBuffer();\n\t\toffset1 += roots[ i ].length;\n\n\t\tif ( result ) {\n\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\t_active = false;\n\treturn result;\n\n}\n\nfunction _traverse(\n\tnode1Index32,\n\tnode2Index32,\n\tmatrix2to1,\n\tmatrix1to2,\n\tintersectsRangesFunc,\n\n\t// offsets for ids\n\tnode1IndexByteOffset = 0,\n\tnode2IndexByteOffset = 0,\n\n\t// tree depth\n\tdepth1 = 0,\n\tdepth2 = 0,\n\n\tcurrBox = null,\n\treversed = false,\n\n) {\n\n\t// get the buffer stacks associated with the current indices\n\tlet bufferStack1, bufferStack2;\n\tif ( reversed ) {\n\n\t\tbufferStack1 = _bufferStack2;\n\t\tbufferStack2 = _bufferStack1;\n\n\t} else {\n\n\t\tbufferStack1 = _bufferStack1;\n\t\tbufferStack2 = _bufferStack2;\n\n\t}\n\n\t// get the local instances of the typed buffers\n\tconst\n\t\tfloat32Array1 = bufferStack1.float32Array,\n\t\tuint32Array1 = bufferStack1.uint32Array,\n\t\tuint16Array1 = bufferStack1.uint16Array,\n\t\tfloat32Array2 = bufferStack2.float32Array,\n\t\tuint32Array2 = bufferStack2.uint32Array,\n\t\tuint16Array2 = bufferStack2.uint16Array;\n\n\tconst node1Index16 = node1Index32 * 2;\n\tconst node2Index16 = node2Index32 * 2;\n\tconst isLeaf1 = IS_LEAF( node1Index16, uint16Array1 );\n\tconst isLeaf2 = IS_LEAF( node2Index16, uint16Array2 );\n\tlet result = false;\n\tif ( isLeaf2 && isLeaf1 ) {\n\n\t\t// if both bounds are leaf nodes then fire the callback if the boxes intersect\n\t\tif ( reversed ) {\n\n\t\t\tresult = intersectsRangesFunc(\n\t\t\t\tOFFSET( node2Index32, uint32Array2 ), COUNT( node2Index32 * 2, uint16Array2 ),\n\t\t\t\tOFFSET( node1Index32, uint32Array1 ), COUNT( node1Index32 * 2, uint16Array1 ),\n\t\t\t\tdepth2, node2IndexByteOffset + node2Index32,\n\t\t\t\tdepth1, node1IndexByteOffset + node1Index32,\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tresult = intersectsRangesFunc(\n\t\t\t\tOFFSET( node1Index32, uint32Array1 ), COUNT( node1Index32 * 2, uint16Array1 ),\n\t\t\t\tOFFSET( node2Index32, uint32Array2 ), COUNT( node2Index32 * 2, uint16Array2 ),\n\t\t\t\tdepth1, node1IndexByteOffset + node1Index32,\n\t\t\t\tdepth2, node2IndexByteOffset + node2Index32,\n\t\t\t);\n\n\t\t}\n\n\t} else if ( isLeaf2 ) {\n\n\t\t// SWAP\n\t\t// If we've traversed to the leaf node on the other bvh then we need to swap over\n\t\t// to traverse down the first one\n\n\t\t// get the new box to use\n\t\tconst newBox = _boxPool.getPrimitive();\n\t\tarrayToBox( BOUNDING_DATA_INDEX( node2Index32 ), float32Array2, newBox );\n\t\tnewBox.applyMatrix4( matrix2to1 );\n\n\t\t// get the child bounds to check before traversal\n\t\tconst cl1 = LEFT_NODE( node1Index32 );\n\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\n\n\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\n\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\n\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\n\t\tresult = (\n\t\t\tintersectCl1 && _traverse(\n\t\t\t\tnode2Index32, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\tnewBox, ! reversed,\n\t\t\t)\n\t\t) || (\n\t\t\tintersectCr1 && _traverse(\n\t\t\t\tnode2Index32, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\tnewBox, ! reversed,\n\t\t\t)\n\t\t);\n\n\t\t_boxPool.releasePrimitive( newBox );\n\n\t} else {\n\n\t\t// if neither are leaves then we should swap if one of the children does not\n\t\t// intersect with the current bounds\n\n\t\t// get the child bounds to check\n\t\tconst cl2 = LEFT_NODE( node2Index32 );\n\t\tconst cr2 = RIGHT_NODE( node2Index32, uint32Array2 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cl2 ), float32Array2, _leftBox2 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cr2 ), float32Array2, _rightBox2 );\n\n\t\tconst leftIntersects = currBox.intersectsBox( _leftBox2 );\n\t\tconst rightIntersects = currBox.intersectsBox( _rightBox2 );\n\t\tif ( leftIntersects && rightIntersects ) {\n\n\t\t\t// continue to traverse both children if they both intersect\n\t\t\tresult = _traverse(\n\t\t\t\tnode1Index32, cl2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\tcurrBox, reversed,\n\t\t\t) || _traverse(\n\t\t\t\tnode1Index32, cr2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\tcurrBox, reversed,\n\t\t\t);\n\n\t\t} else if ( leftIntersects ) {\n\n\t\t\tif ( isLeaf1 ) {\n\n\t\t\t\t// if the current box is a leaf then just continue\n\t\t\t\tresult = _traverse(\n\t\t\t\t\tnode1Index32, cl2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\t\tcurrBox, reversed,\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\t// SWAP\n\t\t\t\t// if only one box intersects then we have to swap to the other bvh to continue\n\t\t\t\tconst newBox = _boxPool.getPrimitive();\n\t\t\t\tnewBox.copy( _leftBox2 ).applyMatrix4( matrix2to1 );\n\n\t\t\t\tconst cl1 = LEFT_NODE( node1Index32 );\n\t\t\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\n\n\t\t\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\n\t\t\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\n\t\t\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\n\t\t\t\tresult = (\n\t\t\t\t\tintersectCl1 && _traverse(\n\t\t\t\t\t\tcl2, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t) || (\n\t\t\t\t\tintersectCr1 && _traverse(\n\t\t\t\t\t\tcl2, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t\t_boxPool.releasePrimitive( newBox );\n\n\t\t\t}\n\n\t\t} else if ( rightIntersects ) {\n\n\t\t\tif ( isLeaf1 ) {\n\n\t\t\t\t// if the current box is a leaf then just continue\n\t\t\t\tresult = _traverse(\n\t\t\t\t\tnode1Index32, cr2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\t\tcurrBox, reversed,\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\t// SWAP\n\t\t\t\t// if only one box intersects then we have to swap to the other bvh to continue\n\t\t\t\tconst newBox = _boxPool.getPrimitive();\n\t\t\t\tnewBox.copy( _rightBox2 ).applyMatrix4( matrix2to1 );\n\n\t\t\t\tconst cl1 = LEFT_NODE( node1Index32 );\n\t\t\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\n\n\t\t\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\n\t\t\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\n\t\t\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\n\t\t\t\tresult = (\n\t\t\t\t\tintersectCl1 && _traverse(\n\t\t\t\t\t\tcr2, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t) || (\n\t\t\t\t\tintersectCr1 && _traverse(\n\t\t\t\t\t\tcr2, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t\t_boxPool.releasePrimitive( newBox );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn result;\n\n}\n\n","import { BufferAttribute, Box3, FrontSide } from 'three';\nimport { CENTER, BYTES_PER_NODE, IS_LEAFNODE_FLAG, SKIP_GENERATION } from './Constants.js';\nimport { buildPackedTree } from './build/buildTree.js';\nimport { OrientedBox } from '../math/OrientedBox.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { ExtendedTrianglePool } from '../utils/ExtendedTrianglePool.js';\nimport { shapecast } from './cast/shapecast.js';\nimport { closestPointToPoint } from './cast/closestPointToPoint.js';\n\nimport { iterateOverTriangles } from './utils/iterationUtils.generated.js';\nimport { refit } from './cast/refit.generated.js';\nimport { raycast } from './cast/raycast.generated.js';\nimport { raycastFirst } from './cast/raycastFirst.generated.js';\nimport { intersectsGeometry } from './cast/intersectsGeometry.generated.js';\nimport { closestPointToGeometry } from './cast/closestPointToGeometry.generated.js';\n\nimport { iterateOverTriangles_indirect } from './utils/iterationUtils_indirect.generated.js';\nimport { refit_indirect } from './cast/refit_indirect.generated.js';\nimport { raycast_indirect } from './cast/raycast_indirect.generated.js';\nimport { raycastFirst_indirect } from './cast/raycastFirst_indirect.generated.js';\nimport { intersectsGeometry_indirect } from './cast/intersectsGeometry_indirect.generated.js';\nimport { closestPointToGeometry_indirect } from './cast/closestPointToGeometry_indirect.generated.js';\nimport { isSharedArrayBufferSupported } from '../utils/BufferUtils.js';\nimport { setTriangle } from '../utils/TriangleUtilities.js';\nimport { bvhcast } from './cast/bvhcast.js';\n\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst tempBox = /* @__PURE__ */ new Box3();\nexport const DEFAULT_OPTIONS = {\n\tstrategy: CENTER,\n\tmaxDepth: 40,\n\tmaxLeafTris: 10,\n\tuseSharedArrayBuffer: false,\n\tsetBoundingBox: true,\n\tonProgress: null,\n\tindirect: false,\n\tverbose: true,\n\trange: null\n};\n\nexport class MeshBVH {\n\n\tstatic serialize( bvh, options = {} ) {\n\n\t\toptions = {\n\t\t\tcloneBuffers: true,\n\t\t\t...options,\n\t\t};\n\n\t\tconst geometry = bvh.geometry;\n\t\tconst rootData = bvh._roots;\n\t\tconst indirectBuffer = bvh._indirectBuffer;\n\t\tconst indexAttribute = geometry.getIndex();\n\t\tlet result;\n\t\tif ( options.cloneBuffers ) {\n\n\t\t\tresult = {\n\t\t\t\troots: rootData.map( root => root.slice() ),\n\t\t\t\tindex: indexAttribute ? indexAttribute.array.slice() : null,\n\t\t\t\tindirectBuffer: indirectBuffer ? indirectBuffer.slice() : null,\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tresult = {\n\t\t\t\troots: rootData,\n\t\t\t\tindex: indexAttribute ? indexAttribute.array : null,\n\t\t\t\tindirectBuffer: indirectBuffer,\n\t\t\t};\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tstatic deserialize( data, geometry, options = {} ) {\n\n\t\toptions = {\n\t\t\tsetIndex: true,\n\t\t\tindirect: Boolean( data.indirectBuffer ),\n\t\t\t...options,\n\t\t};\n\n\t\tconst { index, roots, indirectBuffer } = data;\n\t\tconst bvh = new MeshBVH( geometry, { ...options, [ SKIP_GENERATION ]: true } );\n\t\tbvh._roots = roots;\n\t\tbvh._indirectBuffer = indirectBuffer || null;\n\n\t\tif ( options.setIndex ) {\n\n\t\t\tconst indexAttribute = geometry.getIndex();\n\t\t\tif ( indexAttribute === null ) {\n\n\t\t\t\tconst newIndex = new BufferAttribute( data.index, 1, false );\n\t\t\t\tgeometry.setIndex( newIndex );\n\n\t\t\t} else if ( indexAttribute.array !== index ) {\n\n\t\t\t\tindexAttribute.array.set( index );\n\t\t\t\tindexAttribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bvh;\n\n\t}\n\n\tget indirect() {\n\n\t\treturn ! ! this._indirectBuffer;\n\n\t}\n\n\tconstructor( geometry, options = {} ) {\n\n\t\tif ( ! geometry.isBufferGeometry ) {\n\n\t\t\tthrow new Error( 'MeshBVH: Only BufferGeometries are supported.' );\n\n\t\t} else if ( geometry.index && geometry.index.isInterleavedBufferAttribute ) {\n\n\t\t\tthrow new Error( 'MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.' );\n\n\t\t}\n\n\t\t// default options\n\t\toptions = Object.assign( {\n\n\t\t\t...DEFAULT_OPTIONS,\n\n\t\t\t// undocumented options\n\n\t\t\t// Whether to skip generating the tree. Used for deserialization.\n\t\t\t[ SKIP_GENERATION ]: false,\n\n\t\t}, options );\n\n\t\tif ( options.useSharedArrayBuffer && ! isSharedArrayBufferSupported() ) {\n\n\t\t\tthrow new Error( 'MeshBVH: SharedArrayBuffer is not available.' );\n\n\t\t}\n\n\t\t// retain references to the geometry so we can use them it without having to\n\t\t// take a geometry reference in every function.\n\t\tthis.geometry = geometry;\n\t\tthis._roots = null;\n\t\tthis._indirectBuffer = null;\n\t\tif ( ! options[ SKIP_GENERATION ] ) {\n\n\t\t\tbuildPackedTree( this, options );\n\n\t\t\tif ( ! geometry.boundingBox && options.setBoundingBox ) {\n\n\t\t\t\tgeometry.boundingBox = this.getBoundingBox( new Box3() );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.resolveTriangleIndex = options.indirect ? i => this._indirectBuffer[ i ] : i => i;\n\n\t}\n\n\trefit( nodeIndices = null ) {\n\n\t\tconst refitFunc = this.indirect ? refit_indirect : refit;\n\t\treturn refitFunc( this, nodeIndices );\n\n\t}\n\n\ttraverse( callback, rootIndex = 0 ) {\n\n\t\tconst buffer = this._roots[ rootIndex ];\n\t\tconst uint32Array = new Uint32Array( buffer );\n\t\tconst uint16Array = new Uint16Array( buffer );\n\t\t_traverse( 0 );\n\n\t\tfunction _traverse( node32Index, depth = 0 ) {\n\n\t\t\tconst node16Index = node32Index * 2;\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\t\t\t\tcallback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), offset, count );\n\n\t\t\t} else {\n\n\t\t\t\t// TODO: use node functions here\n\t\t\t\tconst left = node32Index + BYTES_PER_NODE / 4;\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst splitAxis = uint32Array[ node32Index + 7 ];\n\t\t\t\tconst stopTraversal = callback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), splitAxis );\n\n\t\t\t\tif ( ! stopTraversal ) {\n\n\t\t\t\t\t_traverse( left, depth + 1 );\n\t\t\t\t\t_traverse( right, depth + 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/* Core Cast Functions */\n\traycast( ray, materialOrSide = FrontSide, near = 0, far = Infinity ) {\n\n\t\tconst roots = this._roots;\n\t\tconst geometry = this.geometry;\n\t\tconst intersects = [];\n\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\tconst groups = geometry.groups;\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\tconst raycastFunc = this.indirect ? raycast_indirect : raycast;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\t\t\tconst startCount = intersects.length;\n\n\t\t\traycastFunc( this, i, materialSide, ray, intersects, near, far );\n\n\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\tconst materialIndex = groups[ i ].materialIndex;\n\t\t\t\tfor ( let j = startCount, jl = intersects.length; j < jl; j ++ ) {\n\n\t\t\t\t\tintersects[ j ].face.materialIndex = materialIndex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn intersects;\n\n\t}\n\n\traycastFirst( ray, materialOrSide = FrontSide, near = 0, far = Infinity ) {\n\n\t\tconst roots = this._roots;\n\t\tconst geometry = this.geometry;\n\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\tlet closestResult = null;\n\n\t\tconst groups = geometry.groups;\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\tconst raycastFirstFunc = this.indirect ? raycastFirst_indirect : raycastFirst;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\t\t\tconst result = raycastFirstFunc( this, i, materialSide, ray, near, far );\n\t\t\tif ( result != null && ( closestResult == null || result.distance < closestResult.distance ) ) {\n\n\t\t\t\tclosestResult = result;\n\t\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\t\tresult.face.materialIndex = groups[ i ].materialIndex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn closestResult;\n\n\t}\n\n\tintersectsGeometry( otherGeometry, geomToMesh ) {\n\n\t\tlet result = false;\n\t\tconst roots = this._roots;\n\t\tconst intersectsGeometryFunc = this.indirect ? intersectsGeometry_indirect : intersectsGeometry;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tresult = intersectsGeometryFunc( this, i, otherGeometry, geomToMesh );\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tshapecast( callbacks ) {\n\n\t\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\t\tconst iterateFunc = this.indirect ? iterateOverTriangles_indirect : iterateOverTriangles;\n\t\tlet {\n\t\t\tboundsTraverseOrder,\n\t\t\tintersectsBounds,\n\t\t\tintersectsRange,\n\t\t\tintersectsTriangle,\n\t\t} = callbacks;\n\n\t\t// wrap the intersectsRange function\n\t\tif ( intersectsRange && intersectsTriangle ) {\n\n\t\t\tconst originalIntersectsRange = intersectsRange;\n\t\t\tintersectsRange = ( offset, count, contained, depth, nodeIndex ) => {\n\n\t\t\t\tif ( ! originalIntersectsRange( offset, count, contained, depth, nodeIndex ) ) {\n\n\t\t\t\t\treturn iterateFunc( offset, count, this, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t};\n\n\t\t} else if ( ! intersectsRange ) {\n\n\t\t\tif ( intersectsTriangle ) {\n\n\t\t\t\tintersectsRange = ( offset, count, contained, depth ) => {\n\n\t\t\t\t\treturn iterateFunc( offset, count, this, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tintersectsRange = ( offset, count, contained ) => {\n\n\t\t\t\t\treturn contained;\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\t// run shapecast\n\t\tlet result = false;\n\t\tlet byteOffset = 0;\n\t\tconst roots = this._roots;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst root = roots[ i ];\n\t\t\tresult = shapecast( this, i, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tbyteOffset += root.byteLength;\n\n\t\t}\n\n\t\tExtendedTrianglePool.releasePrimitive( triangle );\n\n\t\treturn result;\n\n\t}\n\n\tbvhcast( otherBvh, matrixToLocal, callbacks ) {\n\n\t\tlet {\n\t\t\tintersectsRanges,\n\t\t\tintersectsTriangles,\n\t\t} = callbacks;\n\n\t\tconst triangle1 = ExtendedTrianglePool.getPrimitive();\n\t\tconst indexAttr1 = this.geometry.index;\n\t\tconst positionAttr1 = this.geometry.attributes.position;\n\t\tconst assignTriangle1 = this.indirect ?\n\t\t\ti1 => {\n\n\n\t\t\t\tconst ti = this.resolveTriangleIndex( i1 );\n\t\t\t\tsetTriangle( triangle1, ti * 3, indexAttr1, positionAttr1 );\n\n\t\t\t} :\n\t\t\ti1 => {\n\n\t\t\t\tsetTriangle( triangle1, i1 * 3, indexAttr1, positionAttr1 );\n\n\t\t\t};\n\n\t\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\t\tconst indexAttr2 = otherBvh.geometry.index;\n\t\tconst positionAttr2 = otherBvh.geometry.attributes.position;\n\t\tconst assignTriangle2 = otherBvh.indirect ?\n\t\t\ti2 => {\n\n\t\t\t\tconst ti2 = otherBvh.resolveTriangleIndex( i2 );\n\t\t\t\tsetTriangle( triangle2, ti2 * 3, indexAttr2, positionAttr2 );\n\n\t\t\t} :\n\t\t\ti2 => {\n\n\t\t\t\tsetTriangle( triangle2, i2 * 3, indexAttr2, positionAttr2 );\n\n\t\t\t};\n\n\t\t// generate triangle callback if needed\n\t\tif ( intersectsTriangles ) {\n\n\t\t\tconst iterateOverDoubleTriangles = ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) => {\n\n\t\t\t\tfor ( let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\tassignTriangle2( i2 );\n\n\t\t\t\t\ttriangle2.a.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.b.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.c.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1 ++ ) {\n\n\t\t\t\t\t\tassignTriangle1( i1 );\n\n\t\t\t\t\t\ttriangle1.needsUpdate = true;\n\n\t\t\t\t\t\tif ( intersectsTriangles( triangle1, triangle2, i1, i2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t};\n\n\t\t\tif ( intersectsRanges ) {\n\n\t\t\t\tconst originalIntersectsRanges = intersectsRanges;\n\t\t\t\tintersectsRanges = function ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {\n\n\t\t\t\t\tif ( ! originalIntersectsRanges( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\treturn iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tintersectsRanges = iterateOverDoubleTriangles;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bvhcast( this, otherBvh, matrixToLocal, intersectsRanges );\n\n\t}\n\n\n\t/* Derived Cast Functions */\n\tintersectsBox( box, boxToMesh ) {\n\n\t\tobb.set( box.min, box.max, boxToMesh );\n\t\tobb.needsUpdate = true;\n\n\t\treturn this.shapecast(\n\t\t\t{\n\t\t\t\tintersectsBounds: box => obb.intersectsBox( box ),\n\t\t\t\tintersectsTriangle: tri => obb.intersectsTriangle( tri )\n\t\t\t}\n\t\t);\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn this.shapecast(\n\t\t\t{\n\t\t\t\tintersectsBounds: box => sphere.intersectsBox( box ),\n\t\t\t\tintersectsTriangle: tri => tri.intersectsSphere( sphere )\n\t\t\t}\n\t\t);\n\n\t}\n\n\tclosestPointToGeometry( otherGeometry, geometryToBvh, target1 = { }, target2 = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\tconst closestPointToGeometryFunc = this.indirect ? closestPointToGeometry_indirect : closestPointToGeometry;\n\t\treturn closestPointToGeometryFunc(\n\t\t\tthis,\n\t\t\totherGeometry,\n\t\t\tgeometryToBvh,\n\t\t\ttarget1,\n\t\t\ttarget2,\n\t\t\tminThreshold,\n\t\t\tmaxThreshold,\n\t\t);\n\n\t}\n\n\tclosestPointToPoint( point, target = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\treturn closestPointToPoint(\n\t\t\tthis,\n\t\t\tpoint,\n\t\t\ttarget,\n\t\t\tminThreshold,\n\t\t\tmaxThreshold,\n\t\t);\n\n\t}\n\n\tgetBoundingBox( target ) {\n\n\t\ttarget.makeEmpty();\n\n\t\tconst roots = this._roots;\n\t\troots.forEach( buffer => {\n\n\t\t\tarrayToBox( 0, new Float32Array( buffer ), tempBox );\n\t\t\ttarget.union( tempBox );\n\n\t\t} );\n\n\t\treturn target;\n\n\t}\n\n}\n","const HASH_WIDTH = 1e-6;\nconst HASH_HALF_WIDTH = HASH_WIDTH * 0.5;\nconst HASH_MULTIPLIER = Math.pow( 10, - Math.log10( HASH_WIDTH ) );\nconst HASH_ADDITION = HASH_HALF_WIDTH * HASH_MULTIPLIER;\nexport function hashNumber( v ) {\n\n\treturn ~ ~ ( v * HASH_MULTIPLIER + HASH_ADDITION );\n\n}\n\nexport function hashVertex2( v ) {\n\n\treturn `${ hashNumber( v.x ) },${ hashNumber( v.y ) }`;\n\n}\n\nexport function hashVertex3( v ) {\n\n\treturn `${ hashNumber( v.x ) },${ hashNumber( v.y ) },${ hashNumber( v.z ) }`;\n\n}\n\nexport function hashVertex4( v ) {\n\n\treturn `${ hashNumber( v.x ) },${ hashNumber( v.y ) },${ hashNumber( v.z ) },${ hashNumber( v.w ) }`;\n\n}\n\nexport function hashRay( r ) {\n\n\treturn `${ hashVertex3( r.origin ) }-${ hashVertex3( r.direction ) }`;\n\n}\n\nexport function toNormalizedRay( v0, v1, target ) {\n\n\t// get a normalized direction\n\ttarget\n\t\t.direction\n\t\t.subVectors( v1, v0 )\n\t\t.normalize();\n\n\t// project the origin onto the perpendicular plane that\n\t// passes through 0, 0, 0\n\tconst scalar = v0.dot( target.direction );\n\ttarget.\n\t\torigin\n\t\t.copy( v0 )\n\t\t.addScaledVector( target.direction, - scalar );\n\n\treturn target;\n\n}\n","import { BufferAttribute } from 'three';\n\nexport function areSharedArrayBuffersSupported() {\n\n\treturn typeof SharedArrayBuffer !== 'undefined';\n\n}\n\nexport function convertToSharedArrayBuffer( array ) {\n\n\tif ( array.buffer instanceof SharedArrayBuffer ) {\n\n\t\treturn array;\n\n\t}\n\n\tconst cons = array.constructor;\n\tconst buffer = array.buffer;\n\tconst sharedBuffer = new SharedArrayBuffer( buffer.byteLength );\n\n\tconst uintArray = new Uint8Array( buffer );\n\tconst sharedUintArray = new Uint8Array( sharedBuffer );\n\tsharedUintArray.set( uintArray, 0 );\n\n\treturn new cons( sharedBuffer );\n\n}\n\nexport function getIndexArray( vertexCount, BufferConstructor = ArrayBuffer ) {\n\n\tif ( vertexCount > 65535 ) {\n\n\t\treturn new Uint32Array( new BufferConstructor( 4 * vertexCount ) );\n\n\t} else {\n\n\t\treturn new Uint16Array( new BufferConstructor( 2 * vertexCount ) );\n\n\t}\n\n}\n\nexport function ensureIndex( geo, options ) {\n\n\tif ( ! geo.index ) {\n\n\t\tconst vertexCount = geo.attributes.position.count;\n\t\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\t\tconst index = getIndexArray( vertexCount, BufferConstructor );\n\t\tgeo.setIndex( new BufferAttribute( index, 1 ) );\n\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\tindex[ i ] = i;\n\n\t\t}\n\n\t}\n\n}\n\nexport function getVertexCount( geo ) {\n\n\treturn geo.index ? geo.index.count : geo.attributes.position.count;\n\n}\n\nexport function getTriCount( geo ) {\n\n\treturn getVertexCount( geo ) / 3;\n\n}\n","import { Vector3 } from 'three';\n\nconst DEGENERATE_EPSILON = 1e-8;\nconst _tempVec = new Vector3();\n\nexport function toTriIndex( v ) {\n\n\treturn ~ ~ ( v / 3 );\n\n}\n\nexport function toEdgeIndex( v ) {\n\n\treturn v % 3;\n\n}\n\nexport function sortEdgeFunc( a, b ) {\n\n\treturn a.start - b.start;\n\n}\n\nexport function getProjectedDistance( ray, vec ) {\n\n\treturn _tempVec.subVectors( vec, ray.origin ).dot( ray.direction );\n\n}\n\nexport function hasOverlaps( arr ) {\n\n\tarr = [ ...arr ].sort( sortEdgeFunc );\n\tfor ( let i = 0, l = arr.length; i < l - 1; i ++ ) {\n\n\t\tconst info0 = arr[ i ];\n\t\tconst info1 = arr[ i + 1 ];\n\n\t\tif ( info1.start < info0.end && Math.abs( info1.start - info0.end ) > 1e-5 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\nexport function getEdgeSetLength( arr ) {\n\n\tlet tot = 0;\n\tarr.forEach( ( { start, end } ) => tot += end - start );\n\treturn tot;\n\n}\n\nexport function matchEdges( forward, reverse, disjointConnectivityMap, eps = DEGENERATE_EPSILON ) {\n\n\tforward.sort( sortEdgeFunc );\n\treverse.sort( sortEdgeFunc );\n\n\tfor ( let i = 0; i < forward.length; i ++ ) {\n\n\t\tconst e0 = forward[ i ];\n\t\tfor ( let o = 0; o < reverse.length; o ++ ) {\n\n\t\t\tconst e1 = reverse[ o ];\n\t\t\tif ( e1.start > e0.end ) {\n\n\t\t\t\t// e2 is completely after e1\n\t\t\t\t// break;\n\n\t\t\t\t// NOTE: there are cases where there are overlaps due to precision issues or\n\t\t\t\t// thin / degenerate triangles. Assuming the sibling side has the same issues\n\t\t\t\t// we let the matching work here. Long term we should remove the degenerate\n\t\t\t\t// triangles before this.\n\n\t\t\t} else if ( e0.end < e1.start || e1.end < e0.start ) {\n\n\t\t\t\t// e1 is completely before e2\n\t\t\t\tcontinue;\n\n\t\t\t} else if ( e0.start <= e1.start && e0.end >= e1.end ) {\n\n\t\t\t\t// e1 is larger than and e2 is completely within e1\n\t\t\t\tif ( ! areDistancesDegenerate( e1.end, e0.end ) ) {\n\n\t\t\t\t\tforward.splice( i + 1, 0, {\n\t\t\t\t\t\tstart: e1.end,\n\t\t\t\t\t\tend: e0.end,\n\t\t\t\t\t\tindex: e0.index,\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\te0.end = e1.start;\n\n\t\t\t\te1.start = 0;\n\t\t\t\te1.end = 0;\n\n\t\t\t} else if ( e0.start >= e1.start && e0.end <= e1.end ) {\n\n\t\t\t\t// e2 is larger than and e1 is completely within e2\n\t\t\t\tif ( ! areDistancesDegenerate( e0.end, e1.end ) ) {\n\n\t\t\t\t\treverse.splice( o + 1, 0, {\n\t\t\t\t\t\tstart: e0.end,\n\t\t\t\t\t\tend: e1.end,\n\t\t\t\t\t\tindex: e1.index,\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t\te1.end = e0.start;\n\n\t\t\t\te0.start = 0;\n\t\t\t\te0.end = 0;\n\n\t\t\t} else if ( e0.start <= e1.start && e0.end <= e1.end ) {\n\n\t\t\t\t// e1 overlaps e2 at the beginning\n\t\t\t\tconst tmp = e0.end;\n\t\t\t\te0.end = e1.start;\n\t\t\t\te1.start = tmp;\n\n\t\t\t} else if ( e0.start >= e1.start && e0.end >= e1.end ) {\n\n\t\t\t\t// e1 overlaps e2 at the end\n\t\t\t\tconst tmp = e1.end;\n\t\t\t\te1.end = e0.start;\n\t\t\t\te0.start = tmp;\n\n\t\t\t} else {\n\n\t\t\t\tthrow new Error();\n\n\t\t\t}\n\n\t\t\t// Add the connectivity information\n\t\t\tif ( ! disjointConnectivityMap.has( e0.index ) ) {\n\n\t\t\t\tdisjointConnectivityMap.set( e0.index, [] );\n\n\t\t\t}\n\n\t\t\tif ( ! disjointConnectivityMap.has( e1.index ) ) {\n\n\t\t\t\tdisjointConnectivityMap.set( e1.index, [] );\n\n\t\t\t}\n\n\t\t\tdisjointConnectivityMap\n\t\t\t\t.get( e0.index )\n\t\t\t\t.push( e1.index );\n\n\t\t\tdisjointConnectivityMap\n\t\t\t\t.get( e1.index )\n\t\t\t\t.push( e0.index );\n\n\t\t\tif ( isEdgeDegenerate( e1 ) ) {\n\n\t\t\t\treverse.splice( o, 1 );\n\t\t\t\to --;\n\n\t\t\t}\n\n\t\t\tif ( isEdgeDegenerate( e0 ) ) {\n\n\t\t\t\t// and if we have to remove the current original edge then exit this loop\n\t\t\t\t// so we can work on the next one\n\t\t\t\tforward.splice( i, 1 );\n\t\t\t\ti --;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcleanUpEdgeSet( forward );\n\tcleanUpEdgeSet( reverse );\n\n\tfunction cleanUpEdgeSet( arr ) {\n\n\t\tfor ( let i = 0; i < arr.length; i ++ ) {\n\n\t\t\tif ( isEdgeDegenerate( arr[ i ] ) ) {\n\n\t\t\t\tarr.splice( i, 1 );\n\t\t\t\ti --;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction areDistancesDegenerate( start, end ) {\n\n\t\treturn Math.abs( end - start ) < eps;\n\n\t}\n\n\tfunction isEdgeDegenerate( e ) {\n\n\t\treturn Math.abs( e.end - e.start ) < eps;\n\n\t}\n\n}\n","const DIST_EPSILON = 1e-5;\nconst ANGLE_EPSILON = 1e-4;\n\nexport class RaySet {\n\n\tconstructor() {\n\n\t\tthis._rays = [];\n\n\t}\n\n\taddRay( ray ) {\n\n\t\tthis._rays.push( ray );\n\n\t}\n\n\tfindClosestRay( ray ) {\n\n\t\tconst rays = this._rays;\n\t\tconst inv = ray.clone();\n\t\tinv.direction.multiplyScalar( - 1 );\n\n\t\tlet bestScore = Infinity;\n\t\tlet bestRay = null;\n\t\tfor ( let i = 0, l = rays.length; i < l; i ++ ) {\n\n\t\t\tconst r = rays[ i ];\n\t\t\tif ( skipRay( r, ray ) && skipRay( r, inv ) ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst rayScore = scoreRays( r, ray );\n\t\t\tconst invScore = scoreRays( r, inv );\n\t\t\tconst score = Math.min( rayScore, invScore );\n\t\t\tif ( score < bestScore ) {\n\n\t\t\t\tbestScore = score;\n\t\t\t\tbestRay = r;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bestRay;\n\n\t\tfunction skipRay( r0, r1 ) {\n\n\t\t\tconst distOutOfThreshold = r0.origin.distanceTo( r1.origin ) > DIST_EPSILON;\n\t\t\tconst angleOutOfThreshold = r0.direction.angleTo( r1.direction ) > ANGLE_EPSILON;\n\t\t\treturn angleOutOfThreshold || distOutOfThreshold;\n\n\t\t}\n\n\t\tfunction scoreRays( r0, r1 ) {\n\n\t\t\tconst originDistance = r0.origin.distanceTo( r1.origin );\n\t\t\tconst angleDistance = r0.direction.angleTo( r1.direction );\n\t\t\treturn originDistance / DIST_EPSILON + angleDistance / ANGLE_EPSILON;\n\n\t\t}\n\n\t}\n\n}\n","import { Vector3, Ray } from 'three';\nimport { toEdgeIndex, toTriIndex, matchEdges, getProjectedDistance } from './halfEdgeUtils.js';\nimport { toNormalizedRay } from './hashUtils.js';\nimport { RaySet } from './RaySet.js';\n\nconst _v0 = new Vector3();\nconst _v1 = new Vector3();\nconst _ray = new Ray();\n\nexport function computeDisjointEdges(\n\tgeometry,\n\tunmatchedSet,\n\teps,\n) {\n\n\tconst attributes = geometry.attributes;\n\tconst indexAttr = geometry.index;\n\tconst posAttr = attributes.position;\n\n\tconst disjointConnectivityMap = new Map();\n\tconst fragmentMap = new Map();\n\tconst edges = Array.from( unmatchedSet );\n\tconst rays = new RaySet();\n\n\tfor ( let i = 0, l = edges.length; i < l; i ++ ) {\n\n\t\t// get the triangle edge\n\t\tconst index = edges[ i ];\n\t\tconst triIndex = toTriIndex( index );\n\t\tconst edgeIndex = toEdgeIndex( index );\n\n\t\tlet i0 = 3 * triIndex + edgeIndex;\n\t\tlet i1 = 3 * triIndex + ( edgeIndex + 1 ) % 3;\n\t\tif ( indexAttr ) {\n\n\t\t\ti0 = indexAttr.getX( i0 );\n\t\t\ti1 = indexAttr.getX( i1 );\n\n\t\t}\n\n\t\t_v0.fromBufferAttribute( posAttr, i0 );\n\t\t_v1.fromBufferAttribute( posAttr, i1 );\n\n\t\t// get the ray corresponding to the edge\n\t\ttoNormalizedRay( _v0, _v1, _ray );\n\n\t\t// find the shared ray with other edges\n\t\tlet info;\n\t\tlet commonRay = rays.findClosestRay( _ray );\n\t\tif ( commonRay === null ) {\n\n\t\t\tcommonRay = _ray.clone();\n\t\t\trays.addRay( commonRay );\n\n\t\t}\n\n\t\tif ( ! fragmentMap.has( commonRay ) ) {\n\n\t\t\tfragmentMap.set( commonRay, {\n\n\t\t\t\tforward: [],\n\t\t\t\treverse: [],\n\t\t\t\tray: commonRay,\n\n\t\t\t} );\n\n\t\t}\n\n\t\tinfo = fragmentMap.get( commonRay );\n\n\t\t// store the stride of edge endpoints along the ray\n\t\tlet start = getProjectedDistance( commonRay, _v0 );\n\t\tlet end = getProjectedDistance( commonRay, _v1 );\n\t\tif ( start > end ) {\n\n\t\t\t[ start, end ] = [ end, start ];\n\n\t\t}\n\n\t\tif ( _ray.direction.dot( commonRay.direction ) < 0 ) {\n\n\t\t\tinfo.reverse.push( { start, end, index } );\n\n\t\t} else {\n\n\t\t\tinfo.forward.push( { start, end, index } );\n\n\t\t}\n\n\t}\n\n\t// match the found sibling edges\n\tfragmentMap.forEach( ( { forward, reverse }, ray ) => {\n\n\t\tmatchEdges( forward, reverse, disjointConnectivityMap, eps );\n\n\t\tif ( forward.length === 0 && reverse.length === 0 ) {\n\n\t\t\tfragmentMap.delete( ray );\n\n\t\t}\n\n\t} );\n\n\treturn {\n\t\tdisjointConnectivityMap,\n\t\tfragmentMap,\n\t};\n\n}\n\n","import { Vector2, Vector3, Vector4 } from 'three';\nimport { hashNumber, hashVertex2, hashVertex3, hashVertex4 } from './utils/hashUtils.js';\nimport { getTriCount } from './utils/geometryUtils.js';\nimport { computeDisjointEdges } from './utils/computeDisjointEdges.js';\n\nconst _vec2 = new Vector2();\nconst _vec3 = new Vector3();\nconst _vec4 = new Vector4();\nconst _hashes = [ '', '', '' ];\n\nexport class HalfEdgeMap {\n\n\tconstructor( geometry = null ) {\n\n\t\t// result data\n\t\tthis.data = null;\n\t\tthis.disjointConnections = null;\n\t\tthis.unmatchedDisjointEdges = null;\n\t\tthis.unmatchedEdges = - 1;\n\t\tthis.matchedEdges = - 1;\n\n\t\t// options\n\t\tthis.useDrawRange = true;\n\t\tthis.useAllAttributes = false;\n\t\tthis.matchDisjointEdges = false;\n\t\tthis.degenerateEpsilon = 1e-8;\n\n\t\tif ( geometry ) {\n\n\t\t\tthis.updateFrom( geometry );\n\n\t\t}\n\n\t}\n\n\tgetSiblingTriangleIndex( triIndex, edgeIndex ) {\n\n\t\tconst otherIndex = this.data[ triIndex * 3 + edgeIndex ];\n\t\treturn otherIndex === - 1 ? - 1 : ~ ~ ( otherIndex / 3 );\n\n\t}\n\n\tgetSiblingEdgeIndex( triIndex, edgeIndex ) {\n\n\t\tconst otherIndex = this.data[ triIndex * 3 + edgeIndex ];\n\t\treturn otherIndex === - 1 ? - 1 : ( otherIndex % 3 );\n\n\t}\n\n\tgetDisjointSiblingTriangleIndices( triIndex, edgeIndex ) {\n\n\t\tconst index = triIndex * 3 + edgeIndex;\n\t\tconst arr = this.disjointConnections.get( index );\n\t\treturn arr ? arr.map( i => ~ ~ ( i / 3 ) ) : [];\n\n\t}\n\n\tgetDisjointSiblingEdgeIndices( triIndex, edgeIndex ) {\n\n\t\tconst index = triIndex * 3 + edgeIndex;\n\t\tconst arr = this.disjointConnections.get( index );\n\t\treturn arr ? arr.map( i => i % 3 ) : [];\n\n\t}\n\n\tisFullyConnected() {\n\n\t\treturn this.unmatchedEdges === 0;\n\n\t}\n\n\tupdateFrom( geometry ) {\n\n\t\tconst { useAllAttributes, useDrawRange, matchDisjointEdges, degenerateEpsilon } = this;\n\t\tconst hashFunction = useAllAttributes ? hashAllAttributes : hashPositionAttribute;\n\n\t\t// runs on the assumption that there is a 1 : 1 match of edges\n\t\tconst map = new Map();\n\n\t\t// attributes\n\t\tconst { attributes } = geometry;\n\t\tconst attrKeys = useAllAttributes ? Object.keys( attributes ) : null;\n\t\tconst indexAttr = geometry.index;\n\t\tconst posAttr = attributes.position;\n\n\t\t// get the potential number of triangles\n\t\tlet triCount = getTriCount( geometry );\n\t\tconst maxTriCount = triCount;\n\n\t\t// get the real number of triangles from the based on the draw range\n\t\tlet offset = 0;\n\t\tif ( useDrawRange ) {\n\n\t\t\toffset = geometry.drawRange.start;\n\t\t\tif ( geometry.drawRange.count !== Infinity ) {\n\n\t\t\t\ttriCount = ~ ~ ( geometry.drawRange.count / 3 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// initialize the connectivity buffer - 1 means no connectivity\n\t\tlet data = this.data;\n\t\tif ( ! data || data.length < 3 * maxTriCount ) {\n\n\t\t\tdata = new Int32Array( 3 * maxTriCount );\n\n\t\t}\n\n\t\tdata.fill( - 1 );\n\n\t\t// iterate over all triangles\n\t\tlet matchedEdges = 0;\n\t\tlet unmatchedSet = new Set();\n\t\tfor ( let i = offset, l = triCount * 3 + offset; i < l; i += 3 ) {\n\n\t\t\tconst i3 = i;\n\t\t\tfor ( let e = 0; e < 3; e ++ ) {\n\n\t\t\t\tlet i0 = i3 + e;\n\t\t\t\tif ( indexAttr ) {\n\n\t\t\t\t\ti0 = indexAttr.getX( i0 );\n\n\t\t\t\t}\n\n\t\t\t\t_hashes[ e ] = hashFunction( i0 );\n\n\t\t\t}\n\n\t\t\tfor ( let e = 0; e < 3; e ++ ) {\n\n\t\t\t\tconst nextE = ( e + 1 ) % 3;\n\t\t\t\tconst vh0 = _hashes[ e ];\n\t\t\t\tconst vh1 = _hashes[ nextE ];\n\n\t\t\t\tconst reverseHash = `${ vh1 }_${ vh0 }`;\n\t\t\t\tif ( map.has( reverseHash ) ) {\n\n\t\t\t\t\t// create a reference between the two triangles and clear the hash\n\t\t\t\t\tconst index = i3 + e;\n\t\t\t\t\tconst otherIndex = map.get( reverseHash );\n\t\t\t\t\tdata[ index ] = otherIndex;\n\t\t\t\t\tdata[ otherIndex ] = index;\n\t\t\t\t\tmap.delete( reverseHash );\n\t\t\t\t\tmatchedEdges += 2;\n\t\t\t\t\tunmatchedSet.delete( otherIndex );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// save the triangle and triangle edge index captured in one value\n\t\t\t\t\t// triIndex = ~ ~ ( i0 / 3 );\n\t\t\t\t\t// edgeIndex = i0 % 3;\n\t\t\t\t\tconst hash = `${ vh0 }_${ vh1 }`;\n\t\t\t\t\tconst index = i3 + e;\n\t\t\t\t\tmap.set( hash, index );\n\t\t\t\t\tunmatchedSet.add( index );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( matchDisjointEdges ) {\n\n\t\t\tconst {\n\t\t\t\tfragmentMap,\n\t\t\t\tdisjointConnectivityMap,\n\t\t\t} = computeDisjointEdges( geometry, unmatchedSet, degenerateEpsilon );\n\n\t\t\tunmatchedSet.clear();\n\t\t\tfragmentMap.forEach( ( { forward, reverse } ) => {\n\n\t\t\t\tforward.forEach( ( { index } ) => unmatchedSet.add( index ) );\n\t\t\t\treverse.forEach( ( { index } ) => unmatchedSet.add( index ) );\n\n\t\t\t} );\n\n\t\t\tthis.unmatchedDisjointEdges = fragmentMap;\n\t\t\tthis.disjointConnections = disjointConnectivityMap;\n\t\t\tmatchedEdges = triCount * 3 - unmatchedSet.size;\n\n\t\t}\n\n\t\tthis.matchedEdges = matchedEdges;\n\t\tthis.unmatchedEdges = unmatchedSet.size;\n\t\tthis.data = data;\n\n\t\tfunction hashPositionAttribute( i ) {\n\n\t\t\t_vec3.fromBufferAttribute( posAttr, i );\n\t\t\treturn hashVertex3( _vec3 );\n\n\t\t}\n\n\t\tfunction hashAllAttributes( i ) {\n\n\t\t\tlet result = '';\n\t\t\tfor ( let k = 0, l = attrKeys.length; k < l; k ++ ) {\n\n\t\t\t\tconst attr = attributes[ attrKeys[ k ] ];\n\t\t\t\tlet str;\n\t\t\t\tswitch ( attr.itemSize ) {\n\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tstr = hashNumber( attr.getX( i ) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tstr = hashVertex2( _vec2.fromBufferAttribute( attr, i ) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tstr = hashVertex3( _vec3.fromBufferAttribute( attr, i ) );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tstr = hashVertex4( _vec4.fromBufferAttribute( attr, i ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif ( result !== '' ) {\n\n\t\t\t\t\tresult += '|';\n\n\t\t\t\t}\n\n\t\t\t\tresult += str;\n\n\t\t\t}\n\n\t\t\treturn result;\n\n\t\t}\n\n\t}\n\n}\n","import { Mesh, Matrix4 } from 'three';\nimport { MeshBVH } from 'three-mesh-bvh';\nimport { HalfEdgeMap } from './HalfEdgeMap.js';\nimport { areSharedArrayBuffersSupported, convertToSharedArrayBuffer, ensureIndex, getTriCount } from './utils/geometryUtils.js';\n\nexport class Brush extends Mesh {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tthis.isBrush = true;\n\t\tthis._previousMatrix = new Matrix4();\n\t\tthis._previousMatrix.elements.fill( 0 );\n\n\t}\n\n\tmarkUpdated() {\n\n\t\tthis._previousMatrix.copy( this.matrix );\n\n\t}\n\n\tisDirty() {\n\n\t\tconst { matrix, _previousMatrix } = this;\n\t\tconst el1 = matrix.elements;\n\t\tconst el2 = _previousMatrix.elements;\n\t\tfor ( let i = 0; i < 16; i ++ ) {\n\n\t\t\tif ( el1[ i ] !== el2[ i ] ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tprepareGeometry() {\n\n\t\t// generate shared array buffers\n\t\tconst geometry = this.geometry;\n\t\tconst attributes = geometry.attributes;\n\t\tconst useSharedArrayBuffer = areSharedArrayBuffersSupported();\n\t\tif ( useSharedArrayBuffer ) {\n\n\t\t\tfor ( const key in attributes ) {\n\n\t\t\t\tconst attribute = attributes[ key ];\n\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\tthrow new Error( 'Brush: InterleavedBufferAttributes are not supported.' );\n\n\t\t\t\t}\n\n\t\t\t\tattribute.array = convertToSharedArrayBuffer( attribute.array );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate bounds tree\n\t\tif ( ! geometry.boundsTree ) {\n\n\t\t\tensureIndex( geometry, { useSharedArrayBuffer } );\n\t\t\tgeometry.boundsTree = new MeshBVH( geometry, { maxLeafTris: 3, indirect: true, useSharedArrayBuffer } );\n\n\t\t}\n\n\t\t// generate half edges\n\t\tif ( ! geometry.halfEdges ) {\n\n\t\t\tgeometry.halfEdges = new HalfEdgeMap( geometry );\n\n\t\t}\n\n\t\t// save group indices for materials\n\t\tif ( ! geometry.groupIndices ) {\n\n\t\t\tconst triCount = getTriCount( geometry );\n\t\t\tconst array = new Uint16Array( triCount );\n\t\t\tconst groups = geometry.groups;\n\t\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\t\tconst { start, count } = groups[ i ];\n\t\t\t\tfor ( let g = start / 3, lg = ( start + count ) / 3; g < lg; g ++ ) {\n\n\t\t\t\t\tarray[ g ] = i;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgeometry.groupIndices = array;\n\n\t\t}\n\n\t}\n\n\tdisposeCacheData() {\n\n\t\tconst { geometry } = this;\n\t\tgeometry.halfEdges = null;\n\t\tgeometry.boundsTree = null;\n\t\tgeometry.groupIndices = null;\n\n\t}\n\n}\n","import { Vector3 } from 'three';\n\nconst EPSILON = 1e-14;\nconst _AB = new Vector3();\nconst _AC = new Vector3();\nconst _CB = new Vector3();\n\nexport function isTriDegenerate( tri, eps = EPSILON ) {\n\n\t// compute angles to determine whether they're degenerate\n\t_AB.subVectors( tri.b, tri.a );\n\t_AC.subVectors( tri.c, tri.a );\n\t_CB.subVectors( tri.b, tri.c );\n\n\tconst angle1 = _AB.angleTo( _AC );\t\t\t\t// AB v AC\n\tconst angle2 = _AB.angleTo( _CB );\t\t\t\t// AB v BC\n\tconst angle3 = Math.PI - angle1 - angle2;\t\t// 180deg - angle1 - angle2\n\n\treturn Math.abs( angle1 ) < eps ||\n\t\tMath.abs( angle2 ) < eps ||\n\t\tMath.abs( angle3 ) < eps ||\n\t\ttri.a.distanceToSquared( tri.b ) < eps ||\n\t\ttri.a.distanceToSquared( tri.c ) < eps ||\n\t\ttri.b.distanceToSquared( tri.c ) < eps;\n\n}\n","import { Triangle, Line3, Vector3, Plane } from 'three';\nimport { ExtendedTriangle } from 'three-mesh-bvh';\nimport { isTriDegenerate } from './utils/triangleUtils.js';\n\n// NOTE: these epsilons likely should all be the same since they're used to measure the\n// distance from a point to a plane which needs to be done consistently\nconst EPSILON = 1e-10;\nconst COPLANAR_EPSILON = 1e-10;\nconst PARALLEL_EPSILON = 1e-10;\nconst _edge = new Line3();\nconst _foundEdge = new Line3();\nconst _vec = new Vector3();\nconst _triangleNormal = new Vector3();\nconst _planeNormal = new Vector3();\nconst _plane = new Plane();\nconst _splittingTriangle = new ExtendedTriangle();\n\n// A pool of triangles to avoid unnecessary triangle creation\nclass TrianglePool {\n\n\tconstructor() {\n\n\t\tthis._pool = [];\n\t\tthis._index = 0;\n\n\t}\n\n\tgetTriangle() {\n\n\t\tif ( this._index >= this._pool.length ) {\n\n\t\t\tthis._pool.push( new Triangle() );\n\n\t\t}\n\n\t\treturn this._pool[ this._index ++ ];\n\n\t}\n\n\tclear() {\n\n\t\tthis._index = 0;\n\n\t}\n\n\treset() {\n\n\t\tthis._pool.length = 0;\n\t\tthis._index = 0;\n\n\t}\n\n}\n\n// Utility class for splitting triangles\nexport class TriangleSplitter {\n\n\tconstructor() {\n\n\t\tthis.trianglePool = new TrianglePool();\n\t\tthis.triangles = [];\n\t\tthis.normal = new Vector3();\n\t\tthis.coplanarTriangleUsed = false;\n\n\t}\n\n\t// initialize the class with a triangle\n\tinitialize( tri ) {\n\n\t\tthis.reset();\n\n\t\tconst { triangles, trianglePool, normal } = this;\n\t\tif ( Array.isArray( tri ) ) {\n\n\t\t\tfor ( let i = 0, l = tri.length; i < l; i ++ ) {\n\n\t\t\t\tconst t = tri[ i ];\n\t\t\t\tif ( i === 0 ) {\n\n\t\t\t\t\tt.getNormal( normal );\n\n\t\t\t\t} else if ( Math.abs( 1.0 - t.getNormal( _vec ).dot( normal ) ) > EPSILON ) {\n\n\t\t\t\t\tthrow new Error( 'Triangle Splitter: Cannot initialize with triangles that have different normals.' );\n\n\t\t\t\t}\n\n\t\t\t\tconst poolTri = trianglePool.getTriangle();\n\t\t\t\tpoolTri.copy( t );\n\t\t\t\ttriangles.push( poolTri );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\ttri.getNormal( normal );\n\n\t\t\tconst poolTri = trianglePool.getTriangle();\n\t\t\tpoolTri.copy( tri );\n\t\t\ttriangles.push( poolTri );\n\n\t\t}\n\n\t}\n\n\t// Split the current set of triangles by passing a single triangle in. If the triangle is\n\t// coplanar it will attempt to split by the triangle edge planes\n\tsplitByTriangle( triangle ) {\n\n\t\tconst { normal, triangles } = this;\n\t\ttriangle.getNormal( _triangleNormal ).normalize();\n\n\t\tif ( Math.abs( 1.0 - Math.abs( _triangleNormal.dot( normal ) ) ) < PARALLEL_EPSILON ) {\n\n\t\t\tthis.coplanarTriangleUsed = true;\n\n\t\t\tfor ( let i = 0, l = triangles.length; i < l; i ++ ) {\n\n\t\t\t\tconst t = triangles[ i ];\n\t\t\t\tt.coplanarCount = 0;\n\n\t\t\t}\n\n\t\t\t// if the triangle is coplanar then split by the edge planes\n\t\t\tconst arr = [ triangle.a, triangle.b, triangle.c ];\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst nexti = ( i + 1 ) % 3;\n\n\t\t\t\tconst v0 = arr[ i ];\n\t\t\t\tconst v1 = arr[ nexti ];\n\n\t\t\t\t// plane positive direction is toward triangle center\n\t\t\t\t_vec.subVectors( v1, v0 ).normalize();\n\t\t\t\t_planeNormal.crossVectors( _triangleNormal, _vec );\n\t\t\t\t_plane.setFromNormalAndCoplanarPoint( _planeNormal, v0 );\n\n\t\t\t\tthis.splitByPlane( _plane, triangle );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// otherwise split by the triangle plane\n\t\t\ttriangle.getPlane( _plane );\n\t\t\tthis.splitByPlane( _plane, triangle );\n\n\t\t}\n\n\t}\n\n\t// Split the triangles by the given plan. If a triangle is provided then we ensure we\n\t// intersect the triangle before splitting the plane\n\tsplitByPlane( plane, clippingTriangle ) {\n\n\t\tconst { triangles, trianglePool } = this;\n\n\t\t// init our triangle to check for intersection\n\t\t_splittingTriangle.copy( clippingTriangle );\n\t\t_splittingTriangle.needsUpdate = true;\n\n\t\t// try to split every triangle in the class\n\t\tfor ( let i = 0, l = triangles.length; i < l; i ++ ) {\n\n\t\t\tconst tri = triangles[ i ];\n\n\t\t\t// skip the triangle if we don't intersect with it\n\t\t\tif ( ! _splittingTriangle.intersectsTriangle( tri, _edge, true ) ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst { a, b, c } = tri;\n\t\t\tlet intersects = 0;\n\t\t\tlet vertexSplitEnd = - 1;\n\t\t\tlet coplanarEdge = false;\n\t\t\tlet posSideVerts = [];\n\t\t\tlet negSideVerts = [];\n\t\t\tconst arr = [ a, b, c ];\n\t\t\tfor ( let t = 0; t < 3; t ++ ) {\n\n\t\t\t\t// get the triangle edge\n\t\t\t\tconst tNext = ( t + 1 ) % 3;\n\t\t\t\t_edge.start.copy( arr[ t ] );\n\t\t\t\t_edge.end.copy( arr[ tNext ] );\n\n\t\t\t\t// track if the start point sits on the plane or if it's on the positive side of it\n\t\t\t\t// so we can use that information to determine whether to split later.\n\t\t\t\tconst startDist = plane.distanceToPoint( _edge.start );\n\t\t\t\tconst endDist = plane.distanceToPoint( _edge.end );\n\t\t\t\tif ( Math.abs( startDist ) < COPLANAR_EPSILON && Math.abs( endDist ) < COPLANAR_EPSILON ) {\n\n\t\t\t\t\tcoplanarEdge = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif ( startDist > 0 ) {\n\n\t\t\t\t\tposSideVerts.push( t );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnegSideVerts.push( t );\n\n\t\t\t\t}\n\n\t\t\t\t// we only don't consider this an intersection if the start points hits the plane\n\t\t\t\tif ( Math.abs( startDist ) < COPLANAR_EPSILON ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// double check the end point since the \"intersectLine\" function sometimes does not\n\t\t\t\t// return it as an intersection (see issue #28)\n\t\t\t\t// Because we ignore the start point intersection above we have to make sure we check the end\n\t\t\t\t// point intersection here.\n\t\t\t\tlet didIntersect = ! ! plane.intersectLine( _edge, _vec );\n\t\t\t\tif ( ! didIntersect && Math.abs( endDist ) < COPLANAR_EPSILON ) {\n\n\t\t\t\t\t_vec.copy( _edge.end );\n\t\t\t\t\tdidIntersect = true;\n\n\t\t\t\t}\n\n\t\t\t\t// check if we intersect the plane (ignoring the start point so we don't double count)\n\t\t\t\tif ( didIntersect && ! ( _vec.distanceTo( _edge.start ) < EPSILON ) ) {\n\n\t\t\t\t\t// if we intersect at the end point then we track that point as one that we\n\t\t\t\t\t// have to split down the middle\n\t\t\t\t\tif ( _vec.distanceTo( _edge.end ) < EPSILON ) {\n\n\t\t\t\t\t\tvertexSplitEnd = t;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// track the split edge\n\t\t\t\t\tif ( intersects === 0 ) {\n\n\t\t\t\t\t\t_foundEdge.start.copy( _vec );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_foundEdge.end.copy( _vec );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tintersects ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// skip splitting if:\n\t\t\t// - we have two points on the plane then the plane intersects the triangle exactly on an edge\n\t\t\t// - the plane does not intersect on 2 points\n\t\t\t// - the intersection edge is too small\n\t\t\t// - we're not along a coplanar edge\n\t\t\tif ( ! coplanarEdge && intersects === 2 && _foundEdge.distance() > COPLANAR_EPSILON ) {\n\n\t\t\t\tif ( vertexSplitEnd !== - 1 ) {\n\n\t\t\t\t\tvertexSplitEnd = ( vertexSplitEnd + 1 ) % 3;\n\n\t\t\t\t\t// we're splitting along a vertex\n\t\t\t\t\tlet otherVert1 = 0;\n\t\t\t\t\tif ( otherVert1 === vertexSplitEnd ) {\n\n\t\t\t\t\t\totherVert1 = ( otherVert1 + 1 ) % 3;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet otherVert2 = otherVert1 + 1;\n\t\t\t\t\tif ( otherVert2 === vertexSplitEnd ) {\n\n\t\t\t\t\t\totherVert2 = ( otherVert2 + 1 ) % 3;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst nextTri = trianglePool.getTriangle();\n\t\t\t\t\tnextTri.a.copy( arr[ otherVert2 ] );\n\t\t\t\t\tnextTri.b.copy( _foundEdge.end );\n\t\t\t\t\tnextTri.c.copy( _foundEdge.start );\n\n\t\t\t\t\tif ( ! isTriDegenerate( nextTri ) ) {\n\n\t\t\t\t\t\ttriangles.push( nextTri );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttri.a.copy( arr[ otherVert1 ] );\n\t\t\t\t\ttri.b.copy( _foundEdge.start );\n\t\t\t\t\ttri.c.copy( _foundEdge.end );\n\n\t\t\t\t\t// finish off the adjusted triangle\n\t\t\t\t\tif ( isTriDegenerate( tri ) ) {\n\n\t\t\t\t\t\ttriangles.splice( i, 1 );\n\t\t\t\t\t\ti --;\n\t\t\t\t\t\tl --;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// we're splitting with a quad and a triangle\n\t\t\t\t\t// TODO: what happens when we find that about the pos and negative\n\t\t\t\t\t// sides have only a single vertex?\n\t\t\t\t\tconst singleVert =\n\t\t\t\t\t\tposSideVerts.length >= 2 ?\n\t\t\t\t\t\t\tnegSideVerts[ 0 ] :\n\t\t\t\t\t\t\tposSideVerts[ 0 ];\n\n\t\t\t\t\t// swap the direction of the intersection edge depending on which\n\t\t\t\t\t// side of the plane the single vertex is on to align with the\n\t\t\t\t\t// correct winding order.\n\t\t\t\t\tif ( singleVert === 0 ) {\n\n\t\t\t\t\t\tlet tmp = _foundEdge.start;\n\t\t\t\t\t\t_foundEdge.start = _foundEdge.end;\n\t\t\t\t\t\t_foundEdge.end = tmp;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst nextVert1 = ( singleVert + 1 ) % 3;\n\t\t\t\t\tconst nextVert2 = ( singleVert + 2 ) % 3;\n\n\t\t\t\t\tconst nextTri1 = trianglePool.getTriangle();\n\t\t\t\t\tconst nextTri2 = trianglePool.getTriangle();\n\n\t\t\t\t\t// choose the triangle that has the larger areas (shortest split distance)\n\t\t\t\t\tif ( arr[ nextVert1 ].distanceToSquared( _foundEdge.start ) < arr[ nextVert2 ].distanceToSquared( _foundEdge.end ) ) {\n\n\t\t\t\t\t\tnextTri1.a.copy( arr[ nextVert1 ] );\n\t\t\t\t\t\tnextTri1.b.copy( _foundEdge.start );\n\t\t\t\t\t\tnextTri1.c.copy( _foundEdge.end );\n\n\t\t\t\t\t\tnextTri2.a.copy( arr[ nextVert1 ] );\n\t\t\t\t\t\tnextTri2.b.copy( arr[ nextVert2 ] );\n\t\t\t\t\t\tnextTri2.c.copy( _foundEdge.start );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tnextTri1.a.copy( arr[ nextVert2 ] );\n\t\t\t\t\t\tnextTri1.b.copy( _foundEdge.start );\n\t\t\t\t\t\tnextTri1.c.copy( _foundEdge.end );\n\n\t\t\t\t\t\tnextTri2.a.copy( arr[ nextVert1 ] );\n\t\t\t\t\t\tnextTri2.b.copy( arr[ nextVert2 ] );\n\t\t\t\t\t\tnextTri2.c.copy( _foundEdge.end );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttri.a.copy( arr[ singleVert ] );\n\t\t\t\t\ttri.b.copy( _foundEdge.end );\n\t\t\t\t\ttri.c.copy( _foundEdge.start );\n\n\t\t\t\t\t// don't add degenerate triangles to the list\n\t\t\t\t\tif ( ! isTriDegenerate( nextTri1 ) ) {\n\n\t\t\t\t\t\ttriangles.push( nextTri1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! isTriDegenerate( nextTri2 ) ) {\n\n\t\t\t\t\t\ttriangles.push( nextTri2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// finish off the adjusted triangle\n\t\t\t\t\tif ( isTriDegenerate( tri ) ) {\n\n\t\t\t\t\t\ttriangles.splice( i, 1 );\n\t\t\t\t\t\ti --;\n\t\t\t\t\t\tl --;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( intersects === 3 ) {\n\n\t\t\t\tconsole.warn( 'TriangleClipper: Coplanar clip not handled' );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treset() {\n\n\t\tthis.triangles.length = 0;\n\t\tthis.trianglePool.clear();\n\t\tthis.coplanarTriangleUsed = false;\n\n\t}\n\n}\n","import { areSharedArrayBuffersSupported } from './utils/geometryUtils.js';\n\nfunction ceilToFourByteStride( byteLength ) {\n\n\tbyteLength = ~ ~ byteLength;\n\treturn byteLength + 4 - byteLength % 4;\n\n}\n\n// Make a new array wrapper class that more easily affords expansion when reaching it's max capacity\nexport class TypeBackedArray {\n\n\tconstructor( type, initialSize = 500 ) {\n\n\n\t\tthis.expansionFactor = 1.5;\n\t\tthis.type = type;\n\t\tthis.length = 0;\n\t\tthis.array = null;\n\n\t\tthis.setSize( initialSize );\n\n\t}\n\n\tsetType( type ) {\n\n\t\tif ( this.length !== 0 ) {\n\n\t\t\tthrow new Error( 'TypeBackedArray: Cannot change the type while there is used data in the buffer.' );\n\n\t\t}\n\n\t\tconst buffer = this.array.buffer;\n\t\tthis.array = new type( buffer );\n\t\tthis.type = type;\n\n\t}\n\n\tsetSize( size ) {\n\n\t\tif ( this.array && size === this.array.length ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// ceil to the nearest 4 bytes so we can replace the array with any type using the same buffer\n\t\tconst type = this.type;\n\t\tconst bufferType = areSharedArrayBuffersSupported() ? SharedArrayBuffer : ArrayBuffer;\n\t\tconst newArray = new type( new bufferType( ceilToFourByteStride( size * type.BYTES_PER_ELEMENT ) ) );\n\t\tif ( this.array ) {\n\n\t\t\tnewArray.set( this.array, 0 );\n\n\t\t}\n\n\t\tthis.array = newArray;\n\n\t}\n\n\texpand() {\n\n\t\tconst { array, expansionFactor } = this;\n\t\tthis.setSize( array.length * expansionFactor );\n\n\t}\n\n\tpush( ...args ) {\n\n\t\tlet { array, length } = this;\n\t\tif ( length + args.length > array.length ) {\n\n\t\t\tthis.expand();\n\t\t\tarray = this.array;\n\n\t\t}\n\n\t\tfor ( let i = 0, l = args.length; i < l; i ++ ) {\n\n\t\t\tarray[ length + i ] = args[ i ];\n\n\t\t}\n\n\t\tthis.length += args.length;\n\n\t}\n\n\tclear() {\n\n\t\tthis.length = 0;\n\n\t}\n\n}\n","import { TypeBackedArray } from './TypeBackedArray.js';\n\n// Utility class for for tracking attribute data in type-backed arrays for a set\n// of groups. The set of attributes is kept for each group and are expected to be the\n// same buffer type.\nexport class TypedAttributeData {\n\n\tconstructor() {\n\n\t\tthis.groupAttributes = [ {} ];\n\t\tthis.groupCount = 0;\n\n\t}\n\n\t// returns the buffer type for the given attribute\n\tgetType( name ) {\n\n\t\treturn this.groupAttributes[ 0 ][ name ].type;\n\n\t}\n\n\tgetItemSize( name ) {\n\n\t\treturn this.groupAttributes[ 0 ][ name ].itemSize;\n\n\t}\n\n\tgetNormalized( name ) {\n\n\t\treturn this.groupAttributes[ 0 ][ name ].normalized;\n\n\t}\n\n\tgetCount( index ) {\n\n\t\tif ( this.groupCount <= index ) {\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tconst pos = this.getGroupAttrArray( 'position', index );\n\t\treturn pos.length / pos.itemSize;\n\n\t}\n\n\t// returns the total length required for all groups for the given attribute\n\tgetTotalLength( name ) {\n\n\t\tconst { groupCount, groupAttributes } = this;\n\n\t\tlet length = 0;\n\t\tfor ( let i = 0; i < groupCount; i ++ ) {\n\n\t\t\tconst attrSet = groupAttributes[ i ];\n\t\t\tlength += attrSet[ name ].length;\n\n\t\t}\n\n\t\treturn length;\n\n\t}\n\n\tgetGroupAttrSet( index = 0 ) {\n\n\t\t// TODO: can this be abstracted?\n\t\t// Return the exiting group set if necessary\n\t\tconst { groupAttributes } = this;\n\t\tif ( groupAttributes[ index ] ) {\n\n\t\t\tthis.groupCount = Math.max( this.groupCount, index + 1 );\n\t\t\treturn groupAttributes[ index ];\n\n\t\t}\n\n\t\t// add any new group sets required\n\t\tconst refAttrSet = groupAttributes[ 0 ];\n\t\tthis.groupCount = Math.max( this.groupCount, index + 1 );\n\t\twhile ( index >= groupAttributes.length ) {\n\n\t\t\tconst newAttrSet = {};\n\t\t\tgroupAttributes.push( newAttrSet );\n\t\t\tfor ( const key in refAttrSet ) {\n\n\t\t\t\tconst refAttr = refAttrSet[ key ];\n\t\t\t\tconst newAttr = new TypeBackedArray( refAttr.type );\n\t\t\t\tnewAttr.itemSize = refAttr.itemSize;\n\t\t\t\tnewAttr.normalized = refAttr.normalized;\n\t\t\t\tnewAttrSet[ key ] = newAttr;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn groupAttributes[ index ];\n\n\t}\n\n\t// Get the raw array for the group set of data\n\tgetGroupAttrArray( name, index = 0 ) {\n\n\t\t// throw an error if we've never\n\t\tconst { groupAttributes } = this;\n\t\tconst referenceAttrSet = groupAttributes[ 0 ];\n\t\tconst referenceAttr = referenceAttrSet[ name ];\n\t\tif ( ! referenceAttr ) {\n\n\t\t\tthrow new Error( `TypedAttributeData: Attribute with \"${ name }\" has not been initialized` );\n\n\t\t}\n\n\t\treturn this.getGroupAttrSet( index )[ name ];\n\n\t}\n\n\t// initializes an attribute array with the given name, type, and size\n\tinitializeArray( name, type, itemSize, normalized ) {\n\n\t\tconst { groupAttributes } = this;\n\t\tconst referenceAttrSet = groupAttributes[ 0 ];\n\t\tconst referenceAttr = referenceAttrSet[ name ];\n\t\tif ( referenceAttr ) {\n\n\t\t\tif ( referenceAttr.type !== type ) {\n\n\t\t\t\tfor ( let i = 0, l = groupAttributes.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst arr = groupAttributes[ i ][ name ];\n\t\t\t\t\tarr.setType( type );\n\t\t\t\t\tarr.itemSize = itemSize;\n\t\t\t\t\tarr.normalized = normalized;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0, l = groupAttributes.length; i < l; i ++ ) {\n\n\t\t\t\tconst arr = new TypeBackedArray( type );\n\t\t\t\tarr.itemSize = itemSize;\n\t\t\t\tarr.normalized = normalized;\n\t\t\t\tgroupAttributes[ i ][ name ] = arr;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// Clear all the data\n\tclear() {\n\n\t\tthis.groupCount = 0;\n\n\t\tconst { groupAttributes } = this;\n\t\tgroupAttributes.forEach( attrSet => {\n\n\t\t\tfor ( const key in attrSet ) {\n\n\t\t\t\tattrSet[ key ].clear();\n\n\t\t\t}\n\n\n\t\t} );\n\n\t}\n\n\t// Remove the given key\n\tdelete( key ) {\n\n\t\tthis.groupAttributes.forEach( attrSet => {\n\n\t\t\tdelete attrSet[ key ];\n\n\t\t} );\n\n\t}\n\n\t// Reset the datasets completely\n\treset() {\n\n\t\tthis.groupAttributes = [];\n\t\tthis.groupCount = 0;\n\n\t}\n\n}\n","export class IntersectionMap {\n\n\tconstructor() {\n\n\t\tthis.intersectionSet = {};\n\t\tthis.ids = [];\n\n\t}\n\n\tadd( id, intersectionId ) {\n\n\t\tconst { intersectionSet, ids } = this;\n\t\tif ( ! intersectionSet[ id ] ) {\n\n\t\t\tintersectionSet[ id ] = [];\n\t\t\tids.push( id );\n\n\t\t}\n\n\t\tintersectionSet[ id ].push( intersectionId );\n\n\t}\n\n}\n","export const ADDITION = 0;\nexport const SUBTRACTION = 1;\nexport const REVERSE_SUBTRACTION = 2;\nexport const INTERSECTION = 3;\nexport const DIFFERENCE = 4;\n\n// guaranteed non manifold results\nexport const HOLLOW_SUBTRACTION = 5;\nexport const HOLLOW_INTERSECTION = 6;\n","import { Ray, Matrix4, DoubleSide, Vector3, Vector4, Triangle, Line3 } from 'three';\nimport { IntersectionMap } from '../IntersectionMap.js';\nimport {\n\tADDITION,\n\tSUBTRACTION,\n\tREVERSE_SUBTRACTION,\n\tINTERSECTION,\n\tDIFFERENCE,\n\tHOLLOW_SUBTRACTION,\n\tHOLLOW_INTERSECTION,\n} from '../constants.js';\nimport { isTriDegenerate } from '../utils/triangleUtils.js';\n\nconst _ray = new Ray();\nconst _matrix = new Matrix4();\nconst _tri = new Triangle();\nconst _vec3 = new Vector3();\nconst _vec4a = new Vector4();\nconst _vec4b = new Vector4();\nconst _vec4c = new Vector4();\nconst _vec4_0 = new Vector4();\nconst _vec4_1 = new Vector4();\nconst _vec4_2 = new Vector4();\nconst _edge = new Line3();\nconst _normal = new Vector3();\nconst JITTER_EPSILON = 1e-8;\nconst OFFSET_EPSILON = 1e-15;\n\nexport const BACK_SIDE = - 1;\nexport const FRONT_SIDE = 1;\nexport const COPLANAR_OPPOSITE = - 2;\nexport const COPLANAR_ALIGNED = 2;\n\nexport const INVERT_TRI = 0;\nexport const ADD_TRI = 1;\nexport const SKIP_TRI = 2;\n\nconst FLOATING_COPLANAR_EPSILON = 1e-14;\n\nlet _debugContext = null;\nexport function setDebugContext( debugData ) {\n\n\t_debugContext = debugData;\n\n}\n\nexport function getHitSide( tri, bvh ) {\n\n\ttri.getMidpoint( _ray.origin );\n\ttri.getNormal( _ray.direction );\n\n\tconst hit = bvh.raycastFirst( _ray, DoubleSide );\n\tconst hitBackSide = Boolean( hit && _ray.direction.dot( hit.face.normal ) > 0 );\n\treturn hitBackSide ? BACK_SIDE : FRONT_SIDE;\n\n}\n\nexport function getHitSideWithCoplanarCheck( tri, bvh ) {\n\n\t// random function that returns [ - 0.5, 0.5 ];\n\tfunction rand() {\n\n\t\treturn Math.random() - 0.5;\n\n\t}\n\n\t// get the ray the check the triangle for\n\ttri.getNormal( _normal );\n\t_ray.direction.copy( _normal );\n\ttri.getMidpoint( _ray.origin );\n\n\tconst total = 3;\n\tlet count = 0;\n\tlet minDistance = Infinity;\n\tfor ( let i = 0; i < total; i ++ ) {\n\n\t\t// jitter the ray slightly\n\t\t_ray.direction.x += rand() * JITTER_EPSILON;\n\t\t_ray.direction.y += rand() * JITTER_EPSILON;\n\t\t_ray.direction.z += rand() * JITTER_EPSILON;\n\n\t\t// and invert it so we can account for floating point error by checking both directions\n\t\t// to catch coplanar distances\n\t\t_ray.direction.multiplyScalar( - 1 );\n\n\t\t// check if the ray hit the backside\n\t\tconst hit = bvh.raycastFirst( _ray, DoubleSide );\n\t\tlet hitBackSide = Boolean( hit && _ray.direction.dot( hit.face.normal ) > 0 );\n\t\tif ( hitBackSide ) {\n\n\t\t\tcount ++;\n\n\t\t}\n\n\t\tif ( hit !== null ) {\n\n\t\t\tminDistance = Math.min( minDistance, hit.distance );\n\n\t\t}\n\n\t\t// if we're right up against another face then we're coplanar\n\t\tif ( minDistance <= OFFSET_EPSILON ) {\n\n\t\t\treturn hit.face.normal.dot( _normal ) > 0 ? COPLANAR_ALIGNED : COPLANAR_OPPOSITE;\n\n\t\t}\n\n\t\t// if our current casts meet our requirements then early out\n\t\tif ( count / total > 0.5 || ( i - count + 1 ) / total > 0.5 ) {\n\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\treturn count / total > 0.5 ? BACK_SIDE : FRONT_SIDE;\n\n}\n\n// returns the intersected triangles and returns objects mapping triangle indices to\n// the other triangles intersected\nexport function collectIntersectingTriangles( a, b ) {\n\n\tconst aIntersections = new IntersectionMap();\n\tconst bIntersections = new IntersectionMap();\n\n\t_matrix\n\t\t.copy( a.matrixWorld )\n\t\t.invert()\n\t\t.multiply( b.matrixWorld );\n\n\ta.geometry.boundsTree.bvhcast( b.geometry.boundsTree, _matrix, {\n\n\t\tintersectsTriangles( triangleA, triangleB, ia, ib ) {\n\n\t\t\tif ( ! isTriDegenerate( triangleA ) && ! isTriDegenerate( triangleB ) ) {\n\n\t\t\t\t// due to floating point error it's possible that we can have two overlapping, coplanar triangles\n\t\t\t\t// that are a _tiny_ fraction of a value away from each other. If we find that case then check the\n\t\t\t\t// distance between triangles and if it's small enough consider them intersecting.\n\t\t\t\tlet intersected = triangleA.intersectsTriangle( triangleB, _edge, true );\n\t\t\t\tif ( ! intersected ) {\n\n\t\t\t\t\tconst pa = triangleA.plane;\n\t\t\t\t\tconst pb = triangleB.plane;\n\t\t\t\t\tconst na = pa.normal;\n\t\t\t\t\tconst nb = pb.normal;\n\n\t\t\t\t\tif ( na.dot( nb ) === 1 && Math.abs( pa.constant - pb.constant ) < FLOATING_COPLANAR_EPSILON ) {\n\n\t\t\t\t\t\tintersected = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( intersected ) {\n\n\t\t\t\t\tlet va = a.geometry.boundsTree.resolveTriangleIndex( ia );\n\t\t\t\t\tlet vb = b.geometry.boundsTree.resolveTriangleIndex( ib );\n\t\t\t\t\taIntersections.add( va, vb );\n\t\t\t\t\tbIntersections.add( vb, va );\n\n\t\t\t\t\tif ( _debugContext ) {\n\n\t\t\t\t\t\t_debugContext.addEdge( _edge );\n\t\t\t\t\t\t_debugContext.addIntersectingTriangles( ia, triangleA, ib, triangleB );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t}\n\n\t} );\n\n\treturn { aIntersections, bIntersections };\n\n}\n\n// Add the barycentric interpolated values fro the triangle into the new attribute data\nexport function appendAttributeFromTriangle(\n\ttriIndex,\n\tbaryCoordTri,\n\tgeometry,\n\tmatrixWorld,\n\tnormalMatrix,\n\tattributeData,\n\tinvert = false,\n) {\n\n\tconst attributes = geometry.attributes;\n\tconst indexAttr = geometry.index;\n\tconst i3 = triIndex * 3;\n\tconst i0 = indexAttr.getX( i3 + 0 );\n\tconst i1 = indexAttr.getX( i3 + 1 );\n\tconst i2 = indexAttr.getX( i3 + 2 );\n\n\tfor ( const key in attributeData ) {\n\n\t\t// check if the key we're asking for is in the geometry at all\n\t\tconst attr = attributes[ key ];\n\t\tconst arr = attributeData[ key ];\n\t\tif ( ! ( key in attributes ) ) {\n\n\t\t\tthrow new Error( `CSG Operations: Attribute ${ key } not available on geometry.` );\n\n\t\t}\n\n\t\t// handle normals and positions specially because they require transforming\n\t\t// TODO: handle tangents\n\t\tconst itemSize = attr.itemSize;\n\t\tif ( key === 'position' ) {\n\n\t\t\t_tri.a.fromBufferAttribute( attr, i0 ).applyMatrix4( matrixWorld );\n\t\t\t_tri.b.fromBufferAttribute( attr, i1 ).applyMatrix4( matrixWorld );\n\t\t\t_tri.c.fromBufferAttribute( attr, i2 ).applyMatrix4( matrixWorld );\n\n\t\t\tpushBarycoordInterpolatedValues( _tri.a, _tri.b, _tri.c, baryCoordTri, 3, arr, invert );\n\n\t\t} else if ( key === 'normal' ) {\n\n\t\t\t_tri.a.fromBufferAttribute( attr, i0 ).applyNormalMatrix( normalMatrix );\n\t\t\t_tri.b.fromBufferAttribute( attr, i1 ).applyNormalMatrix( normalMatrix );\n\t\t\t_tri.c.fromBufferAttribute( attr, i2 ).applyNormalMatrix( normalMatrix );\n\n\t\t\tif ( invert ) {\n\n\t\t\t\t_tri.a.multiplyScalar( - 1 );\n\t\t\t\t_tri.b.multiplyScalar( - 1 );\n\t\t\t\t_tri.c.multiplyScalar( - 1 );\n\n\t\t\t}\n\n\t\t\tpushBarycoordInterpolatedValues( _tri.a, _tri.b, _tri.c, baryCoordTri, 3, arr, invert, true );\n\n\t\t} else {\n\n\t\t\t_vec4a.fromBufferAttribute( attr, i0 );\n\t\t\t_vec4b.fromBufferAttribute( attr, i1 );\n\t\t\t_vec4c.fromBufferAttribute( attr, i2 );\n\n\t\t\tpushBarycoordInterpolatedValues( _vec4a, _vec4b, _vec4c, baryCoordTri, itemSize, arr, invert );\n\n\t\t}\n\n\t}\n\n}\n\n// Append all the values of the attributes for the triangle onto the new attribute arrays\nexport function appendAttributesFromIndices(\n\ti0,\n\ti1,\n\ti2,\n\tattributes,\n\tmatrixWorld,\n\tnormalMatrix,\n\tattributeData,\n\tinvert = false,\n) {\n\n\tappendAttributeFromIndex( i0, attributes, matrixWorld, normalMatrix, attributeData, invert );\n\tappendAttributeFromIndex( invert ? i2 : i1, attributes, matrixWorld, normalMatrix, attributeData, invert );\n\tappendAttributeFromIndex( invert ? i1 : i2, attributes, matrixWorld, normalMatrix, attributeData, invert );\n\n}\n\n// Returns the triangle to add when performing an operation\nexport function getOperationAction( operation, hitSide, invert = false ) {\n\n\tswitch ( operation ) {\n\n\t\tcase ADDITION:\n\n\t\t\tif ( hitSide === FRONT_SIDE || ( hitSide === COPLANAR_ALIGNED && ! invert ) ) {\n\n\t\t\t\treturn ADD_TRI;\n\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase SUBTRACTION:\n\n\t\t\tif ( invert ) {\n\n\t\t\t\tif ( hitSide === BACK_SIDE ) {\n\n\t\t\t\t\treturn INVERT_TRI;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( hitSide === FRONT_SIDE || hitSide === COPLANAR_OPPOSITE ) {\n\n\t\t\t\t\treturn ADD_TRI;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase REVERSE_SUBTRACTION:\n\n\t\t\tif ( invert ) {\n\n\t\t\t\tif ( hitSide === FRONT_SIDE || hitSide === COPLANAR_OPPOSITE ) {\n\n\t\t\t\t\treturn ADD_TRI;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( hitSide === BACK_SIDE ) {\n\n\t\t\t\t\treturn INVERT_TRI;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase DIFFERENCE:\n\n\t\t\tif ( hitSide === BACK_SIDE ) {\n\n\t\t\t\treturn INVERT_TRI;\n\n\t\t\t} else if ( hitSide === FRONT_SIDE ) {\n\n\t\t\t\treturn ADD_TRI;\n\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase INTERSECTION:\n\t\t\tif ( hitSide === BACK_SIDE || ( hitSide === COPLANAR_ALIGNED && ! invert ) ) {\n\n\t\t\t\treturn ADD_TRI;\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase HOLLOW_SUBTRACTION:\n\t\t\tif ( ! invert && ( hitSide === FRONT_SIDE || hitSide === COPLANAR_OPPOSITE ) ) {\n\n\t\t\t\treturn ADD_TRI;\n\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase HOLLOW_INTERSECTION:\n\t\t\tif ( ! invert && ( hitSide === BACK_SIDE || hitSide === COPLANAR_ALIGNED ) ) {\n\n\t\t\t\treturn ADD_TRI;\n\n\t\t\t}\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow new Error( `Unrecognized CSG operation enum \"${ operation }\".` );\n\n\t}\n\n\treturn SKIP_TRI;\n\n}\n\n// takes a set of barycentric values in the form of a triangle, a set of vectors, number of components,\n// and whether to invert the result and pushes the new values onto the provided attribute array\nfunction pushBarycoordInterpolatedValues( v0, v1, v2, baryCoordTri, itemSize, attrArr, invert = false, normalize = false ) {\n\n\t// adds the appropriate number of values for the vector onto the array\n\tconst addValues = v => {\n\n\t\tattrArr.push( v.x );\n\t\tif ( itemSize > 1 ) attrArr.push( v.y );\n\t\tif ( itemSize > 2 ) attrArr.push( v.z );\n\t\tif ( itemSize > 3 ) attrArr.push( v.w );\n\n\t};\n\n\t// barycentric interpolate the first component\n\t_vec4_0.set( 0, 0, 0, 0 )\n\t\t.addScaledVector( v0, baryCoordTri.a.x )\n\t\t.addScaledVector( v1, baryCoordTri.a.y )\n\t\t.addScaledVector( v2, baryCoordTri.a.z );\n\n\t_vec4_1.set( 0, 0, 0, 0 )\n\t\t.addScaledVector( v0, baryCoordTri.b.x )\n\t\t.addScaledVector( v1, baryCoordTri.b.y )\n\t\t.addScaledVector( v2, baryCoordTri.b.z );\n\n\t_vec4_2.set( 0, 0, 0, 0 )\n\t\t.addScaledVector( v0, baryCoordTri.c.x )\n\t\t.addScaledVector( v1, baryCoordTri.c.y )\n\t\t.addScaledVector( v2, baryCoordTri.c.z );\n\n\tif ( normalize ) {\n\n\t\t_vec4_0.normalize();\n\t\t_vec4_1.normalize();\n\t\t_vec4_2.normalize();\n\n\t}\n\n\t// if the face is inverted then add the values in an inverted order\n\taddValues( _vec4_0 );\n\n\tif ( invert ) {\n\n\t\taddValues( _vec4_2 );\n\t\taddValues( _vec4_1 );\n\n\t} else {\n\n\t\taddValues( _vec4_1 );\n\t\taddValues( _vec4_2 );\n\n\t}\n\n}\n\n// Adds the values for the given vertex index onto the new attribute arrays\nfunction appendAttributeFromIndex(\n\tindex,\n\tattributes,\n\tmatrixWorld,\n\tnormalMatrix,\n\tattributeData,\n\tinvert = false,\n) {\n\n\tfor ( const key in attributeData ) {\n\n\t\t// check if the key we're asking for is in the geometry at all\n\t\tconst attr = attributes[ key ];\n\t\tconst arr = attributeData[ key ];\n\t\tif ( ! ( key in attributes ) ) {\n\n\t\t\tthrow new Error( `CSG Operations: Attribute ${ key } no available on geometry.` );\n\n\t\t}\n\n\t\t// specially handle the position and normal attributes because they require transforms\n\t\t// TODO: handle tangents\n\t\tconst itemSize = attr.itemSize;\n\t\tif ( key === 'position' ) {\n\n\t\t\t_vec3.fromBufferAttribute( attr, index ).applyMatrix4( matrixWorld );\n\t\t\tarr.push( _vec3.x, _vec3.y, _vec3.z );\n\n\t\t} else if ( key === 'normal' ) {\n\n\t\t\t_vec3.fromBufferAttribute( attr, index ).applyNormalMatrix( normalMatrix );\n\t\t\tif ( invert ) {\n\n\t\t\t\t_vec3.multiplyScalar( - 1 );\n\n\t\t\t}\n\n\t\t\tarr.push( _vec3.x, _vec3.y, _vec3.z );\n\n\t\t} else {\n\n\t\t\tarr.push( attr.getX( index ) );\n\t\t\tif ( itemSize > 1 ) arr.push( attr.getY( index ) );\n\t\t\tif ( itemSize > 2 ) arr.push( attr.getZ( index ) );\n\t\t\tif ( itemSize > 3 ) arr.push( attr.getW( index ) );\n\n\t\t}\n\n\t}\n\n}\n","import { Triangle } from 'three';\nimport { setDebugContext } from '../operations/operationsUtils.js';\n\nclass TriangleIntersectData {\n\n\tconstructor( tri ) {\n\n\t\tthis.triangle = new Triangle().copy( tri );\n\t\tthis.intersects = {};\n\n\t}\n\n\taddTriangle( index, tri ) {\n\n\t\tthis.intersects[ index ] = new Triangle().copy( tri );\n\n\t}\n\n\tgetIntersectArray() {\n\n\t\tconst array = [];\n\t\tconst { intersects } = this;\n\t\tfor ( const key in intersects ) {\n\n\t\t\tarray.push( intersects[ key ] );\n\n\t\t}\n\n\t\treturn array;\n\n\t}\n\n}\n\nclass TriangleIntersectionSets {\n\n\tconstructor() {\n\n\t\tthis.data = {};\n\n\t}\n\n\taddTriangleIntersection( ia, triA, ib, triB ) {\n\n\t\tconst { data } = this;\n\t\tif ( ! data[ ia ] ) {\n\n\t\t\tdata[ ia ] = new TriangleIntersectData( triA );\n\n\t\t}\n\n\t\tdata[ ia ].addTriangle( ib, triB );\n\n\t}\n\n\tgetTrianglesAsArray( id = null ) {\n\n\t\tconst { data } = this;\n\t\tconst arr = [];\n\n\t\tif ( id !== null ) {\n\n\t\t\tif ( id in data ) {\n\n\t\t\t\tarr.push( data[ id ].triangle );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( const key in data ) {\n\n\t\t\t\tarr.push( data[ key ].triangle );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn arr;\n\n\t}\n\n\tgetTriangleIndices() {\n\n\t\treturn Object.keys( this.data ).map( i => parseInt( i ) );\n\n\t}\n\n\tgetIntersectionIndices( id ) {\n\n\t\tconst { data } = this;\n\t\tif ( ! data[ id ] ) {\n\n\t\t\treturn [];\n\n\t\t} else {\n\n\t\t\treturn Object.keys( data[ id ].intersects ).map( i => parseInt( i ) );\n\n\n\t\t}\n\n\t}\n\n\tgetIntersectionsAsArray( id = null, id2 = null ) {\n\n\t\tconst { data } = this;\n\t\tconst triSet = new Set();\n\t\tconst arr = [];\n\n\t\tconst addTriangles = key => {\n\n\t\t\tif ( ! data[ key ] ) return;\n\n\t\t\tif ( id2 !== null ) {\n\n\t\t\t\tif ( data[ key ].intersects[ id2 ] ) {\n\n\t\t\t\t\tarr.push( data[ key ].intersects[ id2 ] );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconst intersects = data[ key ].intersects;\n\t\t\t\tfor ( const key2 in intersects ) {\n\n\t\t\t\t\tif ( ! triSet.has( key2 ) ) {\n\n\t\t\t\t\t\ttriSet.add( key2 );\n\t\t\t\t\t\tarr.push( intersects[ key2 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tif ( id !== null ) {\n\n\t\t\taddTriangles( id );\n\n\t\t} else {\n\n\t\t\tfor ( const key in data ) {\n\n\t\t\t\taddTriangles( key );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn arr;\n\n\t}\n\n\treset() {\n\n\t\tthis.data = {};\n\n\t}\n\n}\n\nexport class OperationDebugData {\n\n\tconstructor() {\n\n\t\tthis.enabled = false;\n\t\tthis.triangleIntersectsA = new TriangleIntersectionSets();\n\t\tthis.triangleIntersectsB = new TriangleIntersectionSets();\n\t\tthis.intersectionEdges = [];\n\n\t}\n\n\taddIntersectingTriangles( ia, triA, ib, triB ) {\n\n\t\tconst { triangleIntersectsA, triangleIntersectsB } = this;\n\t\ttriangleIntersectsA.addTriangleIntersection( ia, triA, ib, triB );\n\t\ttriangleIntersectsB.addTriangleIntersection( ib, triB, ia, triA );\n\n\t}\n\n\taddEdge( edge ) {\n\n\t\tthis.intersectionEdges.push( edge.clone() );\n\n\t}\n\n\treset() {\n\n\t\tthis.triangleIntersectsA.reset();\n\t\tthis.triangleIntersectsB.reset();\n\t\tthis.intersectionEdges = [];\n\n\t}\n\n\tinit() {\n\n\t\tif ( this.enabled ) {\n\n\t\t\tthis.reset();\n\t\t\tsetDebugContext( this );\n\n\t\t}\n\n\t}\n\n\tcomplete() {\n\n\t\tif ( this.enabled ) {\n\n\t\t\tsetDebugContext( null );\n\n\t\t}\n\n\t}\n\n}\n","import { Matrix4, Matrix3, Triangle } from 'three';\nimport {\n\tgetHitSideWithCoplanarCheck,\n\tgetHitSide,\n\tcollectIntersectingTriangles,\n\tappendAttributeFromTriangle,\n\tappendAttributesFromIndices,\n\tgetOperationAction,\n\tSKIP_TRI, INVERT_TRI,\n} from './operationsUtils.js';\nimport { getTriCount } from '../utils/geometryUtils.js';\nimport { HOLLOW_INTERSECTION, HOLLOW_SUBTRACTION } from '../constants.js';\nimport { isTriDegenerate } from '../utils/triangleUtils.js';\n\nconst _matrix = new Matrix4();\nconst _normalMatrix = new Matrix3();\nconst _triA = new Triangle();\nconst _triB = new Triangle();\nconst _tri = new Triangle();\nconst _barycoordTri = new Triangle();\nconst _attr = [];\nconst _actions = [];\n\nfunction getFirstIdFromSet( set ) {\n\n\tfor ( const id of set ) return id;\n\n}\n\n// runs the given operation against a and b using the splitter and appending data to the\n// attributeData object.\nexport function performOperation(\n\ta,\n\tb,\n\toperations,\n\tsplitter,\n\tattributeData,\n\toptions = {},\n) {\n\n\tconst { useGroups = true } = options;\n\tconst { aIntersections, bIntersections } = collectIntersectingTriangles( a, b );\n\n\tconst resultGroups = [];\n\tlet resultMaterials = null;\n\n\tlet groupOffset;\n\tgroupOffset = useGroups ? 0 : - 1;\n\tperformSplitTriangleOperations( a, b, aIntersections, operations, false, splitter, attributeData, groupOffset );\n\tperformWholeTriangleOperations( a, b, aIntersections, operations, false, attributeData, groupOffset );\n\n\t// find whether the set of operations contains a non-hollow operations. If it does then we need\n\t// to perform the second set of triangle additions\n\tconst nonHollow = operations\n\t\t.findIndex( op => op !== HOLLOW_INTERSECTION && op !== HOLLOW_SUBTRACTION ) !== - 1;\n\n\tif ( nonHollow ) {\n\n\t\tgroupOffset = useGroups ? a.geometry.groups.length || 1 : - 1;\n\t\tperformSplitTriangleOperations( b, a, bIntersections, operations, true, splitter, attributeData, groupOffset );\n\t\tperformWholeTriangleOperations( b, a, bIntersections, operations, true, attributeData, groupOffset );\n\n\t}\n\n\t_attr.length = 0;\n\t_actions.length = 0;\n\n\treturn {\n\t\tgroups: resultGroups,\n\t\tmaterials: resultMaterials\n\t};\n\n}\n\n// perform triangle splitting and CSG operations on the set of split triangles\nfunction performSplitTriangleOperations(\n\ta,\n\tb,\n\tintersectionMap,\n\toperations,\n\tinvert,\n\tsplitter,\n\tattributeData,\n\tgroupOffset = 0,\n) {\n\n\tconst invertedGeometry = a.matrixWorld.determinant() < 0;\n\n\t// transforms into the local frame of matrix b\n\t_matrix\n\t\t.copy( b.matrixWorld )\n\t\t.invert()\n\t\t.multiply( a.matrixWorld );\n\n\t_normalMatrix\n\t\t.getNormalMatrix( a.matrixWorld )\n\t\t.multiplyScalar( invertedGeometry ? - 1 : 1 );\n\n\tconst groupIndices = a.geometry.groupIndices;\n\tconst aIndex = a.geometry.index;\n\tconst aPosition = a.geometry.attributes.position;\n\n\tconst bBVH = b.geometry.boundsTree;\n\tconst bIndex = b.geometry.index;\n\tconst bPosition = b.geometry.attributes.position;\n\tconst splitIds = intersectionMap.ids;\n\tconst intersectionSet = intersectionMap.intersectionSet;\n\n\t// iterate over all split triangle indices\n\tfor ( let i = 0, l = splitIds.length; i < l; i ++ ) {\n\n\t\tconst ia = splitIds[ i ];\n\t\tconst groupIndex = groupOffset === - 1 ? 0 : groupIndices[ ia ] + groupOffset;\n\n\t\t// get the triangle in the geometry B local frame\n\t\tconst ia3 = 3 * ia;\n\t\tconst ia0 = aIndex.getX( ia3 + 0 );\n\t\tconst ia1 = aIndex.getX( ia3 + 1 );\n\t\tconst ia2 = aIndex.getX( ia3 + 2 );\n\t\t_triA.a.fromBufferAttribute( aPosition, ia0 ).applyMatrix4( _matrix );\n\t\t_triA.b.fromBufferAttribute( aPosition, ia1 ).applyMatrix4( _matrix );\n\t\t_triA.c.fromBufferAttribute( aPosition, ia2 ).applyMatrix4( _matrix );\n\n\t\t// initialize the splitter with the triangle from geometry A\n\t\tsplitter.reset();\n\t\tsplitter.initialize( _triA );\n\n\t\t// split the triangle with the intersecting triangles from B\n\t\tconst intersectingIndices = intersectionSet[ ia ];\n\t\tfor ( let ib = 0, l = intersectingIndices.length; ib < l; ib ++ ) {\n\n\t\t\tconst ib3 = 3 * intersectingIndices[ ib ];\n\t\t\tconst ib0 = bIndex.getX( ib3 + 0 );\n\t\t\tconst ib1 = bIndex.getX( ib3 + 1 );\n\t\t\tconst ib2 = bIndex.getX( ib3 + 2 );\n\t\t\t_triB.a.fromBufferAttribute( bPosition, ib0 );\n\t\t\t_triB.b.fromBufferAttribute( bPosition, ib1 );\n\t\t\t_triB.c.fromBufferAttribute( bPosition, ib2 );\n\t\t\tsplitter.splitByTriangle( _triB );\n\n\t\t}\n\n\t\t// for all triangles in the split result\n\t\tconst triangles = splitter.triangles;\n\t\tfor ( let ib = 0, l = triangles.length; ib < l; ib ++ ) {\n\n\t\t\t// get the barycentric coordinates of the clipped triangle to add\n\t\t\tconst clippedTri = triangles[ ib ];\n\n\t\t\t// try to use the side derived from the clipping but if it turns out to be\n\t\t\t// uncertain then fall back to the raycasting approach\n\t\t\tconst hitSide = splitter.coplanarTriangleUsed ?\n\t\t\t\tgetHitSideWithCoplanarCheck( clippedTri, bBVH ) :\n\t\t\t\tgetHitSide( clippedTri, bBVH );\n\n\t\t\t_attr.length = 0;\n\t\t\t_actions.length = 0;\n\t\t\tfor ( let o = 0, lo = operations.length; o < lo; o ++ ) {\n\n\t\t\t\tconst op = getOperationAction( operations[ o ], hitSide, invert );\n\t\t\t\tif ( op !== SKIP_TRI ) {\n\n\t\t\t\t\t_actions.push( op );\n\t\t\t\t\t_attr.push( attributeData[ o ].getGroupAttrSet( groupIndex ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( _attr.length !== 0 ) {\n\n\t\t\t\t_triA.getBarycoord( clippedTri.a, _barycoordTri.a );\n\t\t\t\t_triA.getBarycoord( clippedTri.b, _barycoordTri.b );\n\t\t\t\t_triA.getBarycoord( clippedTri.c, _barycoordTri.c );\n\n\t\t\t\tfor ( let k = 0, lk = _attr.length; k < lk; k ++ ) {\n\n\t\t\t\t\tconst attrSet = _attr[ k ];\n\t\t\t\t\tconst action = _actions[ k ];\n\t\t\t\t\tconst invertTri = action === INVERT_TRI;\n\t\t\t\t\tappendAttributeFromTriangle( ia, _barycoordTri, a.geometry, a.matrixWorld, _normalMatrix, attrSet, invertedGeometry !== invertTri );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn splitIds.length;\n\n}\n\n// perform CSG operations on the set of whole triangles using a half edge structure\n// at the moment this isn't always faster due to overhead of building the half edge structure\n// and degraded connectivity due to split triangles.\n\nfunction performWholeTriangleOperations(\n\ta,\n\tb,\n\tsplitTriSet,\n\toperations,\n\tinvert,\n\tattributeData,\n\tgroupOffset = 0,\n) {\n\n\tconst invertedGeometry = a.matrixWorld.determinant() < 0;\n\n\t// matrix for transforming into the local frame of geometry b\n\t_matrix\n\t\t.copy( b.matrixWorld )\n\t\t.invert()\n\t\t.multiply( a.matrixWorld );\n\n\t_normalMatrix\n\t\t.getNormalMatrix( a.matrixWorld )\n\t\t.multiplyScalar( invertedGeometry ? - 1 : 1 );\n\n\tconst bBVH = b.geometry.boundsTree;\n\tconst groupIndices = a.geometry.groupIndices;\n\tconst aIndex = a.geometry.index;\n\tconst aAttributes = a.geometry.attributes;\n\tconst aPosition = aAttributes.position;\n\n\tconst stack = [];\n\tconst halfEdges = a.geometry.halfEdges;\n\tconst traverseSet = new Set();\n\tconst triCount = getTriCount( a.geometry );\n\tfor ( let i = 0, l = triCount; i < l; i ++ ) {\n\n\t\tif ( ! ( i in splitTriSet.intersectionSet ) ) {\n\n\t\t\ttraverseSet.add( i );\n\n\t\t}\n\n\t}\n\n\twhile ( traverseSet.size > 0 ) {\n\n\t\tconst id = getFirstIdFromSet( traverseSet );\n\t\ttraverseSet.delete( id );\n\n\t\tstack.push( id );\n\n\t\t// get the vertex indices\n\t\tconst i3 = 3 * id;\n\t\tconst i0 = aIndex.getX( i3 + 0 );\n\t\tconst i1 = aIndex.getX( i3 + 1 );\n\t\tconst i2 = aIndex.getX( i3 + 2 );\n\n\t\t// get the vertex position in the frame of geometry b so we can\n\t\t// perform hit testing\n\t\t_tri.a.fromBufferAttribute( aPosition, i0 ).applyMatrix4( _matrix );\n\t\t_tri.b.fromBufferAttribute( aPosition, i1 ).applyMatrix4( _matrix );\n\t\t_tri.c.fromBufferAttribute( aPosition, i2 ).applyMatrix4( _matrix );\n\n\t\t// get the side and decide if we need to cull the triangle based on the operation\n\t\tconst hitSide = getHitSide( _tri, bBVH );\n\n\t\t_actions.length = 0;\n\t\t_attr.length = 0;\n\t\tfor ( let o = 0, lo = operations.length; o < lo; o ++ ) {\n\n\t\t\tconst op = getOperationAction( operations[ o ], hitSide, invert );\n\t\t\tif ( op !== SKIP_TRI ) {\n\n\t\t\t\t_actions.push( op );\n\t\t\t\t_attr.push( attributeData[ o ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\twhile ( stack.length > 0 ) {\n\n\t\t\tconst currId = stack.pop();\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst sid = halfEdges.getSiblingTriangleIndex( currId, i );\n\t\t\t\tif ( sid !== - 1 && traverseSet.has( sid ) ) {\n\n\t\t\t\t\tstack.push( sid );\n\t\t\t\t\ttraverseSet.delete( sid );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( _attr.length !== 0 ) {\n\n\t\t\t\tconst i3 = 3 * currId;\n\t\t\t\tconst i0 = aIndex.getX( i3 + 0 );\n\t\t\t\tconst i1 = aIndex.getX( i3 + 1 );\n\t\t\t\tconst i2 = aIndex.getX( i3 + 2 );\n\t\t\t\tconst groupIndex = groupOffset === - 1 ? 0 : groupIndices[ currId ] + groupOffset;\n\n\t\t\t\t_tri.a.fromBufferAttribute( aPosition, i0 );\n\t\t\t\t_tri.b.fromBufferAttribute( aPosition, i1 );\n\t\t\t\t_tri.c.fromBufferAttribute( aPosition, i2 );\n\t\t\t\tif ( ! isTriDegenerate( _tri ) ) {\n\n\t\t\t\t\tfor ( let k = 0, lk = _attr.length; k < lk; k ++ ) {\n\n\t\t\t\t\t\tconst action = _actions[ k ];\n\t\t\t\t\t\tconst attrSet = _attr[ k ].getGroupAttrSet( groupIndex );\n\t\t\t\t\t\tconst invertTri = action === INVERT_TRI;\n\t\t\t\t\t\tappendAttributesFromIndices( i0, i1, i2, aAttributes, a.matrixWorld, _normalMatrix, attrSet, invertTri !== invertedGeometry );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\n","import { BufferAttribute } from 'three';\nimport { TriangleSplitter } from './TriangleSplitter.js';\nimport { TypedAttributeData } from './TypedAttributeData.js';\nimport { OperationDebugData } from './debug/OperationDebugData.js';\nimport { performOperation } from './operations/operations.js';\nimport { Brush } from './Brush.js';\n\n// merges groups with common material indices in place\nfunction joinGroups( groups ) {\n\n\tfor ( let i = 0; i < groups.length - 1; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\t\tconst nextGroup = groups[ i + 1 ];\n\t\tif ( group.materialIndex === nextGroup.materialIndex ) {\n\n\t\t\tconst start = group.start;\n\t\t\tconst end = nextGroup.start + nextGroup.count;\n\t\t\tnextGroup.start = start;\n\t\t\tnextGroup.count = end - start;\n\n\t\t\tgroups.splice( i, 1 );\n\t\t\ti --;\n\n\t\t}\n\n\t}\n\n}\n\n// initialize the target geometry and attribute data to be based on\n// the given reference geometry\nfunction prepareAttributesData( referenceGeometry, targetGeometry, attributeData, relevantAttributes ) {\n\n\tattributeData.clear();\n\n\t// initialize and clear unused data from the attribute buffers and vice versa\n\tconst aAttributes = referenceGeometry.attributes;\n\tfor ( let i = 0, l = relevantAttributes.length; i < l; i ++ ) {\n\n\t\tconst key = relevantAttributes[ i ];\n\t\tconst aAttr = aAttributes[ key ];\n\t\tattributeData.initializeArray( key, aAttr.array.constructor, aAttr.itemSize, aAttr.normalized );\n\n\t}\n\n\tfor ( const key in attributeData.attributes ) {\n\n\t\tif ( ! relevantAttributes.includes( key ) ) {\n\n\t\t\tattributeData.delete( key );\n\n\t\t}\n\n\t}\n\n\tfor ( const key in targetGeometry.attributes ) {\n\n\t\tif ( ! relevantAttributes.includes( key ) ) {\n\n\t\t\ttargetGeometry.deleteAttribute( key );\n\t\t\ttargetGeometry.dispose();\n\n\t\t}\n\n\t}\n\n}\n\n// Assigns the given tracked attribute data to the geometry and returns whether the\n// geometry needs to be disposed of.\nfunction assignBufferData( geometry, attributeData, groupOrder ) {\n\n\tlet needsDisposal = false;\n\tlet drawRange = - 1;\n\n\t// set the data\n\tconst attributes = geometry.attributes;\n\tconst referenceAttrSet = attributeData.groupAttributes[ 0 ];\n\tfor ( const key in referenceAttrSet ) {\n\n\t\tconst requiredLength = attributeData.getTotalLength( key );\n\t\tconst type = attributeData.getType( key );\n\t\tconst itemSize = attributeData.getItemSize( key );\n\t\tconst normalized = attributeData.getNormalized( key );\n\t\tlet geoAttr = attributes[ key ];\n\t\tif ( ! geoAttr || geoAttr.array.length < requiredLength ) {\n\n\t\t\t// create the attribute if it doesn't exist yet\n\t\t\tgeoAttr = new BufferAttribute( new type( requiredLength ), itemSize, normalized );\n\t\t\tgeometry.setAttribute( key, geoAttr );\n\t\t\tneedsDisposal = true;\n\n\t\t}\n\n\t\t// assign the data to the geometry attribute buffers in the provided order\n\t\t// of the groups list\n\t\tlet offset = 0;\n\t\tfor ( let i = 0, l = Math.min( groupOrder.length, attributeData.groupCount ); i < l; i ++ ) {\n\n\t\t\tconst index = groupOrder[ i ].index;\n\t\t\tconst { array, type, length } = attributeData.groupAttributes[ index ][ key ];\n\t\t\tconst trimmedArray = new type( array.buffer, 0, length );\n\t\t\tgeoAttr.array.set( trimmedArray, offset );\n\t\t\toffset += trimmedArray.length;\n\n\t\t}\n\n\t\tgeoAttr.needsUpdate = true;\n\t\tdrawRange = requiredLength / geoAttr.itemSize;\n\n\t}\n\n\t// remove or update the index appropriately\n\tif ( geometry.index ) {\n\n\t\tconst indexArray = geometry.index.array;\n\t\tif ( indexArray.length < drawRange ) {\n\n\t\t\tgeometry.index = null;\n\t\t\tneedsDisposal = true;\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0, l = indexArray.length; i < l; i ++ ) {\n\n\t\t\t\tindexArray[ i ] = i;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// initialize the groups\n\tlet groupOffset = 0;\n\tgeometry.clearGroups();\n\tfor ( let i = 0, l = Math.min( groupOrder.length, attributeData.groupCount ); i < l; i ++ ) {\n\n\t\tconst { index, materialIndex } = groupOrder[ i ];\n\t\tconst vertCount = attributeData.getCount( index );\n\t\tif ( vertCount !== 0 ) {\n\n\t\t\tgeometry.addGroup( groupOffset, vertCount, materialIndex );\n\t\t\tgroupOffset += vertCount;\n\n\t\t}\n\n\t}\n\n\t// update the draw range\n\tgeometry.setDrawRange( 0, drawRange );\n\n\t// remove the bounds tree if it exists because its now out of date\n\t// TODO: can we have this dispose in the same way that a brush does?\n\t// TODO: why are half edges and group indices not removed here?\n\tgeometry.boundsTree = null;\n\n\tif ( needsDisposal ) {\n\n\t\tgeometry.dispose();\n\n\t}\n\n}\n\n// Returns the list of materials used for the given set of groups\nfunction getMaterialList( groups, materials ) {\n\n\tlet result = materials;\n\tif ( ! Array.isArray( materials ) ) {\n\n\t\tresult = [];\n\t\tgroups.forEach( g => {\n\n\t\t\tresult[ g.materialIndex ] = materials;\n\n\t\t} );\n\n\t}\n\n\treturn result;\n\n}\n\n// Utility class for performing CSG operations\nexport class Evaluator {\n\n\tconstructor() {\n\n\t\tthis.triangleSplitter = new TriangleSplitter();\n\t\tthis.attributeData = [];\n\t\tthis.attributes = [ 'position', 'uv', 'normal' ];\n\t\tthis.useGroups = true;\n\t\tthis.consolidateGroups = true;\n\t\tthis.debug = new OperationDebugData();\n\n\t}\n\n\tgetGroupRanges( geometry ) {\n\n\t\treturn ! this.useGroups || geometry.groups.length === 0 ?\n\t\t\t[ { start: 0, count: Infinity, materialIndex: 0 } ] :\n\t\t\tgeometry.groups.map( group => ( { ...group } ) );\n\n\t}\n\n\tevaluate( a, b, operations, targetBrushes = new Brush() ) {\n\n\t\tlet wasArray = true;\n\t\tif ( ! Array.isArray( operations ) ) {\n\n\t\t\toperations = [ operations ];\n\n\t\t}\n\n\t\tif ( ! Array.isArray( targetBrushes ) ) {\n\n\t\t\ttargetBrushes = [ targetBrushes ];\n\t\t\twasArray = false;\n\n\t\t}\n\n\t\tif ( targetBrushes.length !== operations.length ) {\n\n\t\t\tthrow new Error( 'Evaluator: operations and target array passed as different sizes.' );\n\n\t\t}\n\n\t\ta.prepareGeometry();\n\t\tb.prepareGeometry();\n\n\t\tconst {\n\t\t\ttriangleSplitter,\n\t\t\tattributeData,\n\t\t\tattributes,\n\t\t\tuseGroups,\n\t\t\tconsolidateGroups,\n\t\t\tdebug,\n\t\t} = this;\n\n\t\t// expand the attribute data array to the necessary size\n\t\twhile ( attributeData.length < targetBrushes.length ) {\n\n\t\t\tattributeData.push( new TypedAttributeData() );\n\n\t\t}\n\n\t\t// prepare the attribute data buffer information\n\t\ttargetBrushes.forEach( ( brush, i ) => {\n\n\t\t\tprepareAttributesData( a.geometry, brush.geometry, attributeData[ i ], attributes );\n\n\t\t} );\n\n\t\t// run the operation to fill the list of attribute data\n\t\tdebug.init();\n\t\tperformOperation( a, b, operations, triangleSplitter, attributeData, { useGroups } );\n\t\tdebug.complete();\n\n\t\t// get the materials and group ranges\n\t\tconst aGroups = this.getGroupRanges( a.geometry );\n\t\tconst aMaterials = getMaterialList( aGroups, a.material );\n\n\t\tconst bGroups = this.getGroupRanges( b.geometry );\n\t\tconst bMaterials = getMaterialList( bGroups, b.material );\n\t\tbGroups.forEach( g => g.materialIndex += aMaterials.length );\n\n\t\tlet groups = [ ...aGroups, ...bGroups ]\n\t\t\t.map( ( group, index ) => ( { ...group, index } ) );\n\n\t\t// generate the minimum set of materials needed for the list of groups and adjust the groups\n\t\t// if they're needed\n\t\tif ( useGroups ) {\n\n\t\t\tconst allMaterials = [ ...aMaterials, ...bMaterials ];\n\t\t\tif ( consolidateGroups ) {\n\n\t\t\t\tgroups = groups\n\t\t\t\t\t.map( group => {\n\n\t\t\t\t\t\tconst mat = allMaterials[ group.materialIndex ];\n\t\t\t\t\t\tgroup.materialIndex = allMaterials.indexOf( mat );\n\t\t\t\t\t\treturn group;\n\n\t\t\t\t\t} )\n\t\t\t\t\t.sort( ( a, b ) => {\n\n\t\t\t\t\t\treturn a.materialIndex - b.materialIndex;\n\n\t\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\t// create a map from old to new index and remove materials that aren't used\n\t\t\tconst finalMaterials = [];\n\t\t\tfor ( let i = 0, l = allMaterials.length; i < l; i ++ ) {\n\n\t\t\t\tlet foundGroup = false;\n\t\t\t\tfor ( let g = 0, lg = groups.length; g < lg; g ++ ) {\n\n\t\t\t\t\tconst group = groups[ g ];\n\t\t\t\t\tif ( group.materialIndex === i ) {\n\n\t\t\t\t\t\tfoundGroup = true;\n\t\t\t\t\t\tgroup.materialIndex = finalMaterials.length;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( foundGroup ) {\n\n\t\t\t\t\tfinalMaterials.push( allMaterials[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\ttargetBrushes.forEach( tb => {\n\n\t\t\t\ttb.material = finalMaterials;\n\n\t\t\t} );\n\n\t\t} else {\n\n\t\t\tgroups = [ { start: 0, count: Infinity, index: 0, materialIndex: 0 } ];\n\t\t\ttargetBrushes.forEach( tb => {\n\n\t\t\t\ttb.material = aMaterials[ 0 ];\n\n\t\t\t} );\n\n\t\t}\n\n\t\t// apply groups and attribute data to the geometry\n\t\ttargetBrushes.forEach( ( brush, i ) => {\n\n\t\t\tconst targetGeometry = brush.geometry;\n\t\t\tassignBufferData( targetGeometry, attributeData[ i ], groups );\n\t\t\tif ( consolidateGroups ) {\n\n\t\t\t\tjoinGroups( targetGeometry.groups );\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn wasArray ? targetBrushes : targetBrushes[ 0 ];\n\n\t}\n\n\t// TODO: fix\n\tevaluateHierarchy( root, target = new Brush() ) {\n\n\t\troot.updateMatrixWorld( true );\n\n\t\tconst flatTraverse = ( obj, cb ) => {\n\n\t\t\tconst children = obj.children;\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = children[ i ];\n\t\t\t\tif ( child.isOperationGroup ) {\n\n\t\t\t\t\tflatTraverse( child, cb );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcb( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\n\t\tconst traverse = brush => {\n\n\t\t\tconst children = brush.children;\n\t\t\tlet didChange = false;\n\t\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = children[ i ];\n\t\t\t\tdidChange = traverse( child ) || didChange;\n\n\t\t\t}\n\n\t\t\tconst isDirty = brush.isDirty();\n\t\t\tif ( isDirty ) {\n\n\t\t\t\tbrush.markUpdated();\n\n\t\t\t}\n\n\t\t\tif ( didChange && ! brush.isOperationGroup ) {\n\n\t\t\t\tlet result;\n\t\t\t\tflatTraverse( brush, child => {\n\n\t\t\t\t\tif ( ! result ) {\n\n\t\t\t\t\t\tresult = this.evaluate( brush, child, child.operation );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tresult = this.evaluate( result, child, child.operation );\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t\tbrush._cachedGeometry = result.geometry;\n\t\t\t\tbrush._cachedMaterials = result.material;\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\treturn didChange || isDirty;\n\n\t\t\t}\n\n\t\t};\n\n\t\ttraverse( root );\n\n\t\ttarget.geometry = root._cachedGeometry;\n\t\ttarget.material = root._cachedMaterials;\n\n\t\treturn target;\n\n\t}\n\n\treset() {\n\n\t\tthis.triangleSplitter.reset();\n\n\t}\n\n}\n","\r\nuniform float uTime;\r\nuniform float uPositionFrecuency;\r\nuniform float uStrength;\r\nuniform float uWarpFrequency;\r\nuniform float uWarpStrength;\r\n\r\nvarying vec3 vPosition;\r\nvarying float vUpDot;\r\n#include ../includes/simplexNoise2d.glsl\r\n\r\nfloat getElevation(vec2 position)\r\n{\r\n    //warpedPosition\r\n    vec2 warpedPosition = position;\r\n    warpedPosition += uTime * 0.2;\r\n    warpedPosition += simplexNoise2d(warpedPosition * uWarpFrequency * uPositionFrecuency) * uWarpStrength;\r\n    \r\n    float elevation = 0.0;\r\n    elevation += simplexNoise2d(warpedPosition * uPositionFrecuency ) / 2.0;\r\n    elevation += simplexNoise2d(warpedPosition * uPositionFrecuency * 2.0) / 4.0;\r\n    elevation += simplexNoise2d(warpedPosition * uPositionFrecuency * 4.0) / 8.0;\r\n\r\n    //plateau\r\n    float sign = sign(elevation);\r\n    elevation = pow(abs(elevation), 2.0) * sign;\r\n    elevation *= uStrength;\r\n    return elevation;\r\n}\r\nvoid main(){\r\n\r\n    // neighbours positions\r\n    float shift = 0.01;\r\n    vec3 positionA = position + vec3(shift, 0.0, 0.0);\r\n    vec3 positionB = position + vec3(0.0, 0.0, -shift);\r\n    \r\n    //Elevation\r\n    float elevation = getElevation(csm_Position.xz);\r\n    csm_Position.y += elevation;\r\n    positionA.y = getElevation(positionA.xz);\r\n    positionB.y = getElevation(positionB.xz);\r\n\r\n    //Compute Normal \r\n    vec3 toA = normalize(positionA - csm_Position);\r\n    vec3 toB = normalize(positionB - csm_Position);\r\n    csm_Normal = cross(toA, toB);\r\n    vPosition = csm_Position;\r\n    vPosition.xz += uTime * 0.2;\r\n    vUpDot = dot(csm_Normal, vec3(0.0, 1.0, 0.0));\r\n    // gl_Position = projectionMatrix * modelViewMatrix * vec4(csm_Position, 1.0);\r\n}","\r\nuniform vec3 uColorWaterDeep;\r\nuniform vec3 uColorWaterShallow;\r\nuniform vec3 uColorSand;\r\nuniform vec3 uColorSnow;\r\nuniform vec3 uColorGrass;\r\nuniform vec3 uColorRock;\r\n\r\nvarying vec3 vPosition;\r\nvarying float vUpDot;\r\n\r\n#include ../includes/simplexNoise2d.glsl\r\nvoid main(){\r\n    //color \r\n    vec3 color = vec3(1.0);\r\n\r\n    //water\r\n    float surfaceWaterMix = smoothstep(-1.0,  -0.1, vPosition.y);\r\n    color = mix(uColorWaterDeep, uColorWaterShallow, surfaceWaterMix);\r\n\r\n    //sand \r\n    float sandMix = step(-0.1, vPosition.y);\r\n    color = mix(color, uColorSand, sandMix);\r\n\r\n    //grass\r\n    float grassMix = step(-0.06, vPosition.y); \r\n    color = mix(color, uColorGrass, grassMix);\r\n\r\n    // //rock\r\n    float rockMix = vUpDot;\r\n    // rockMix =  1.0 - step(0.8,  rockMix);\r\n    rockMix =  1.0 - smoothstep(0.8,  0.9,  rockMix);\r\n    rockMix *= step(-0.06, vPosition.y); \r\n    color = mix(color, uColorRock, rockMix);\r\n    // color = vec3(rockMix);\r\n\r\n\r\n     //snow\r\n     float snowThreshold = 0.45;\r\n     snowThreshold += simplexNoise2d(vPosition.xz * 15.0) * 0.1;\r\n     float snowMix = step(snowThreshold,  vPosition.y);\r\n     color = mix(color, uColorSnow, snowMix);\r\n\r\n    // //rock\r\n    // float rockMix = smoothstep(0.0,  0.1, vPosition.y);\r\n    // color = mix(color, uColorRock, rockMix);\r\n\r\n   \r\n    csm_DiffuseColor = vec4(color, 1.0);\r\n    // csm_FragColor = vec4(uColorRock, 1.0);\r\n}","import { useFrame } from \"@react-three/fiber\";\r\nimport { useRef } from \"react\";\r\nimport { SUBTRACTION ,Brush, Evaluator } from \"three-bvh-csg\"\r\nimport * as THREE from \"three\";\r\nimport { useControls } from \"leva\";\r\nimport CustomShaderMaterial from \"three-custom-shader-material/vanilla\";\r\nimport vertexShader from \"./vertex.glsl\"\r\nimport fragmentShader from \"./fragment.glsl\"\r\nexport default function ProceduralTerrain() {\r\n\r\n    const controls = useControls({\r\n        positionFrecuency: { value: 0.2, min: 0, max: 1 },\r\n        strength: { value: 2.0, min: 0, max: 10 },\r\n        warpFrequency: { value: 5.0, min: 0, max: 10 },\r\n        warpStrength: { value: 0.5, min: 0, max: 1 },\r\n        colorWaterDeep: { value: \"#002b3d\" },\r\n        colorWaterShallow: { value: \"#66a8ff\" },\r\n        colorSand: { value: \"#ffe894\" },\r\n        colorSnow: { value: \"#ffffff\" },\r\n        colorGrass: { value: \"#85d534\" },\r\n        colorRock: { value: \"#525137\" },\r\n    })\r\n    //brushes\r\n    const boardFill = new Brush(new THREE.BoxGeometry(11, 2, 11))\r\n    const boardHole = new Brush(new THREE.BoxGeometry(10, 2, 10))\r\n\r\n    \r\n    //evaluate\r\n    const evaluator = new Evaluator()\r\n    const board = evaluator.evaluate(boardFill, boardHole, SUBTRACTION)\r\n    board.material = new THREE.MeshStandardMaterial({\r\n        color: new THREE.Color(\"#ffffff\"),\r\n        roughness: 1,\r\n        metalness: 0,\r\n        // envMapIntensity: 0.5\r\n    })\r\n    board.castShadow = true;\r\n    board.receiveShadow = true;\r\n\r\n    //terrain \r\n    const geomtery = new THREE.PlaneGeometry(10,10,500,500)\r\n    geomtery.rotateX(-Math.PI * 0.5)\r\n\r\n    const uniforms = {\r\n        uTime: new THREE.Uniform(0),\r\n        uPositionFrecuency: new THREE.Uniform(controls.positionFrecuency),\r\n        uStrength: new THREE.Uniform(controls.strength),\r\n        uWarpFrequency: new THREE.Uniform(controls.warpFrequency),\r\n        uWarpStrength: new THREE.Uniform(controls.warpStrength),\r\n        uColorWaterDeep: new THREE.Uniform(new THREE.Color(controls.colorWaterDeep)),\r\n        uColorWaterShallow: new THREE.Uniform(new THREE.Color(controls.colorWaterShallow)),\r\n        uColorSand: new THREE.Uniform(new THREE.Color(controls.colorSand)),\r\n        uColorSnow: new THREE.Uniform(new THREE.Color(controls.colorSnow)),\r\n        uColorGrass: new THREE.Uniform(new THREE.Color(controls.colorGrass)),\r\n        uColorRock: new THREE.Uniform(new THREE.Color(controls.colorRock)),\r\n    }\r\n    const material = new  CustomShaderMaterial({\r\n\r\n        //CSM\r\n        baseMaterial: new THREE.MeshStandardMaterial(),\r\n        vertexShader: vertexShader,\r\n        fragmentShader: fragmentShader,\r\n        silent: true,\r\n        //mesh Standard Material\r\n        uniforms: uniforms,\r\n        roughness: 0.5,\r\n        metalness: 0,\r\n        // envMapIntensity: 0.5\r\n    })\r\n    const depthMaterial = new CustomShaderMaterial({\r\n        // CSM \r\n        baseMaterial: new THREE.MeshDepthMaterial(),\r\n        vertexShader: vertexShader,\r\n        uniforms: uniforms,\r\n        silent: true,\r\n        //depth Material\r\n        depthPacking: THREE.RGBADepthPacking,\r\n        \r\n    })\r\n    useFrame((_, delta) => {\r\n        uniforms.uTime.value += delta;\r\n    })\r\n\r\n\r\n\r\n    return (\r\n        <>\r\n        <primitive object={board} />\r\n        <mesh \r\n            geometry={geomtery} material={material} \r\n            customDepthMaterial={depthMaterial}\r\n            receiveShadow={true} castShadow={true}\r\n        >\r\n        </mesh>\r\n        {/* WATER */}\r\n        <mesh \r\n            position={[0, -0.1, 0]}\r\n            rotation={[-Math.PI * 0.5, 0, 0]}\r\n        >\r\n            <planeGeometry args={[10,10,500,500]} />\r\n            <meshPhysicalMaterial color={new THREE.Color(controls.colorWaterShallow)} transmission={1} roughness={0}/>\r\n        </mesh>\r\n        </>\r\n    )\r\n}"],"names":["CENTER","AVERAGE","SAH","CONTAINED","TRIANGLE_INTERSECT_COST","TRAVERSAL_COST","BYTES_PER_NODE","IS_LEAFNODE_FLAG","FLOAT32_EPSILON","SKIP_GENERATION","getVertexCount","geo","getTriCount","getIndexArray","vertexCount","BufferConstructor","ensureIndex","options","index","BufferAttribute","i","getFullGeometryRange","range","triCount","drawRange","start","end","offset","count","getRootIndexRanges","ranges","rangeBoundaries","drawRangeStart","drawRangeEnd","group","groupStart","groupEnd","sortedBoundaries","a","b","hasGroupGaps","geometry","groups","finalGroup","total","getBounds","triangleBounds","target","centroidTarget","minx","miny","minz","maxx","maxy","maxz","cminx","cminy","cminz","cmaxx","cmaxy","cmaxz","cx","hx","lx","rx","cy","hy","ly","ry","cz","hz","lz","rz","computeTriangleBounds","posAttr","normalized","posArr","bufferOffset","stride","getters","tri","tri3","tri6","ai","bi","ci","el","c","min","max","halfExtents","el2","arrayToBox","nodeIndex32","array","getLongestEdgeIndex","bounds","splitDimIdx","splitDist","dist","copyBounds","source","unionBounds","aVal","bVal","d","d3","expandByTriangleBounds","startIndex","tCenter","tHalf","tMin","tMax","computeSurfaceArea","d0","d1","d2","BIN_COUNT","binsSort","sahBins","leftBounds","getOptimalSplit","nodeBoundingData","centroidBoundingData","strategy","axis","pos","getAverage","rootSurfaceArea","bestCost","cStart","cEnd","axisLeft","binWidth","truncatedBins","bin","leftCacheBounds","rightCacheBounds","splitCount","center","leftCount","rightCount","rightBounds","leftProb","rightProb","cost","binIndex","lastBin","nextBin","binCount","avg","MeshBVHNode","partition","indirectBuffer","split","left","right","axisOffset","t0","tb","partition_indirect","t","IS_LEAF","n16","uint16Array","OFFSET","n32","uint32Array","COUNT","LEFT_NODE","RIGHT_NODE","SPLIT_AXIS","float32Array","uint8Array","MAX_POINTER","countNodes","node","populateBuffer","byteOffset","buffer","_populateBuffer","stride4Offset","stride2Offset","isLeaf","boundingData","l","offset2","splitAxis","nextUnusedPointer","generateIndirectBuffer","useSharedArrayBuffer","useUint32","byteCount","buildTree","bvh","maxDepth","verbose","maxLeafTris","onProgress","indirect","indexArray","partionFunc","totalTriangles","cacheCentroidBoundingData","reachedMaxDepth","root","splitNode","triggerProgress","trianglesProcessed","depth","splitOffset","lstart","lcount","rstart","rcount","buildPackedTree","geometryRanges","nodeCount","SeparatingAxisBounds","points","field","val","p","other","Vector3","box","boxMin","boxMax","x","y","z","closestPointLineToLine","dir1","dir2","v02","l1","l2","result","v0","v10","v2","v32","d0232","d3210","d3232","d0210","denom","closestPointsSegmentToSegment","paramResult","Vector2","temp1","temp2","target1","target2","p2","closestPoint","closestPoint2","sphereIntersectTriangle","closestPointTemp","projectedPointTemp","planeTemp","Plane","lineTemp","Line3","sphere","triangle","radius","plane","pp","ZERO_EPSILON","isNearZero","value","ExtendedTriangle","Triangle","args","Sphere","satAxes","satBounds","axis0","sab0","axis1","sab1","axis2","sab2","axis3","sab3","point1","point2","edge","segment","distSq","closestDistanceSq","nexti","saTri2","arr1","arr2","cachedSatBounds","cachedSatBounds2","cachedAxis","dir","tempDir","edge1","edge2","tempPoint","triIntersectPlane","targetEdge","startPointIntersection","startIntersects","doesIntersect","suppressLog","plane1","plane2","satBounds1","satAxes1","sb","sa","satBounds2","satAxes2","sa1","i2","sa2","count1","count2","tmp","s1","e1","s2","e2","separated1","separated2","point","cornerFields","line1","line2","lineTarget","otherVec","thisVec","f11","f12","f21","f22","OrientedBox","matrix","Matrix4","v","minVec","pi","alignedSatBounds","aabbBounds","saTri","pointsArr","triSatBounds","triSatAxes","xyzFields","segments1","segments2","threshold","threshold2","i1","nextIndex","nextIndex2","index2","p1","f1","f2","f3","PrimitivePool","getNewPrimitive","primitives","primitive","ExtendedTrianglePoolBase","ExtendedTrianglePool","_BufferStack","stack","prevBuffer","BufferStack","_box1","_box2","boxStack","boxPool","Box3","shapecast","intersectsBounds","intersectsRange","boundsTraverseOrder","shapecastTraverse","length","intersectsBoundsFunc","intersectsRangeFunc","nodeScoreFunc","nodeIndexByteOffset","nodeIndex16","getLeftOffset","getRightEndOffset","c1","c2","score1","score2","box1","box2","temp","isC1Leaf","c1Intersection","c1StopTraversal","isC2Leaf","c2Intersection","c2StopTraversal","closestPointToPoint","minThreshold","maxThreshold","minThresholdSq","maxThresholdSq","closestDistanceTriIndex","score","triIndex","closestDistance","_vA","_vB","_vC","_uvA","_uvB","_uvC","_normalA","_normalB","_normalC","_intersectionPoint","checkIntersection","ray","pA","pB","pC","side","near","far","intersect","BackSide","DoubleSide","distance","checkBufferGeometryIntersection","position","normal","uv","uv1","intersection","face","intersectTri","intersections","triOffset","setTriangle","ta","tc","i0","intersectTris","_indirectBuffer","intersectClosestTri","res","iterateOverTriangles","intersectsTriangleFunc","contained","refit","nodeIndices","indexArr","roots","_traverse","node32Index","force","node16Index","offsetLeft","offsetRight","forceChildren","includesLeft","includesRight","traverseLeft","traverseRight","leftChange","rightChange","didChange","lefti","righti","minLeftValue","maxLeftValue","minRightValue","maxRightValue","intersectRay","tmin","tmax","tymin","tymax","tzmin","tzmax","invdirx","invdiry","invdirz","ox","oy","oz","intersectTris_indirect","vi","intersectClosestTri_indirect","iterateOverTriangles_indirect","raycast","intersects","_raycast","leftIndex","rightIndex","_xyzFields","raycastFirst","_raycastFirst","xyzAxis","leftToRight","c1Result","c2Result","boundingBox","triangle2","invertedMat","obb","obb2","intersectsGeometry","otherGeometry","geometryToBvh","_intersectsGeometry","cachedObb","thisGeometry","thisIndex","thisPos","tempMatrix","temp3","temp4","closestPointToGeometry","otherPos","otherIndex","tempTarget1","tempTargetDest1","tempTarget2","tempTargetDest2","closestDistanceOtherTriIndex","otherOffset","otherCount","refit_indirect","j","raycast_indirect","raycastFirst_indirect","intersectsGeometry_indirect","ti","closestPointToGeometry_indirect","otherBvh","ti2","isSharedArrayBufferSupported","_bufferStack1","_bufferStack2","_boxPool","_leftBox1","_rightBox1","_leftBox2","_rightBox2","_active","bvhcast","matrixToLocal","intersectsRanges","otherRoots","offset1","invMat","il","localBox","jl","node1Index32","node2Index32","matrix2to1","matrix1to2","intersectsRangesFunc","node1IndexByteOffset","node2IndexByteOffset","depth1","depth2","currBox","reversed","bufferStack1","bufferStack2","float32Array1","uint32Array1","uint16Array1","float32Array2","uint32Array2","uint16Array2","node1Index16","node2Index16","isLeaf1","isLeaf2","newBox","cl1","cr1","intersectCl1","intersectCr1","cl2","cr2","leftIntersects","rightIntersects","tempBox","DEFAULT_OPTIONS","MeshBVH","rootData","indexAttribute","data","newIndex","callback","rootIndex","materialOrSide","FrontSide","isMaterial","isArrayMaterial","raycastFunc","materialSide","startCount","materialIndex","closestResult","raycastFirstFunc","geomToMesh","intersectsGeometryFunc","callbacks","iterateFunc","intersectsTriangle","originalIntersectsRange","nodeIndex","intersectsTriangles","triangle1","indexAttr1","positionAttr1","assignTriangle1","indexAttr2","positionAttr2","assignTriangle2","iterateOverDoubleTriangles","index1","originalIntersectsRanges","boxToMesh","HASH_WIDTH","HASH_HALF_WIDTH","HASH_MULTIPLIER","HASH_ADDITION","hashNumber","hashVertex2","hashVertex3","hashVertex4","toNormalizedRay","v1","scalar","areSharedArrayBuffersSupported","convertToSharedArrayBuffer","cons","sharedBuffer","uintArray","DEGENERATE_EPSILON","_tempVec","toTriIndex","toEdgeIndex","sortEdgeFunc","getProjectedDistance","vec","matchEdges","forward","reverse","disjointConnectivityMap","eps","e0","o","areDistancesDegenerate","isEdgeDegenerate","cleanUpEdgeSet","arr","e","DIST_EPSILON","ANGLE_EPSILON","RaySet","rays","inv","bestScore","bestRay","r","skipRay","rayScore","scoreRays","invScore","r0","r1","distOutOfThreshold","originDistance","angleDistance","_v0","_v1","_ray","Ray","computeDisjointEdges","unmatchedSet","attributes","indexAttr","fragmentMap","edges","edgeIndex","info","commonRay","_vec2","_vec3","_vec4","Vector4","_hashes","HalfEdgeMap","useAllAttributes","useDrawRange","matchDisjointEdges","degenerateEpsilon","hashFunction","hashAllAttributes","hashPositionAttribute","map","attrKeys","maxTriCount","matchedEdges","i3","nextE","vh0","vh1","reverseHash","hash","k","attr","str","Brush","Mesh","_previousMatrix","el1","key","attribute","g","lg","EPSILON","_AB","_AC","_CB","isTriDegenerate","angle1","angle2","angle3","COPLANAR_EPSILON","PARALLEL_EPSILON","_edge","_foundEdge","_vec","_triangleNormal","_planeNormal","_plane","_splittingTriangle","TrianglePool","TriangleSplitter","triangles","trianglePool","poolTri","clippingTriangle","vertexSplitEnd","coplanarEdge","posSideVerts","negSideVerts","tNext","startDist","endDist","didIntersect","otherVert1","otherVert2","nextTri","singleVert","nextVert1","nextVert2","nextTri1","nextTri2","ceilToFourByteStride","byteLength","TypeBackedArray","type","initialSize","size","bufferType","newArray","expansionFactor","TypedAttributeData","name","groupCount","groupAttributes","attrSet","refAttrSet","newAttrSet","refAttr","newAttr","itemSize","referenceAttr","IntersectionMap","id","intersectionId","intersectionSet","ids","ADDITION","SUBTRACTION","REVERSE_SUBTRACTION","INTERSECTION","DIFFERENCE","HOLLOW_SUBTRACTION","HOLLOW_INTERSECTION","_matrix","_tri","_vec4a","_vec4b","_vec4c","_vec4_0","_vec4_1","_vec4_2","_normal","JITTER_EPSILON","OFFSET_EPSILON","BACK_SIDE","FRONT_SIDE","COPLANAR_OPPOSITE","COPLANAR_ALIGNED","INVERT_TRI","ADD_TRI","SKIP_TRI","FLOATING_COPLANAR_EPSILON","_debugContext","setDebugContext","debugData","getHitSide","hit","getHitSideWithCoplanarCheck","rand","minDistance","collectIntersectingTriangles","aIntersections","bIntersections","triangleA","triangleB","ia","ib","intersected","pa","pb","na","nb","va","vb","appendAttributeFromTriangle","baryCoordTri","matrixWorld","normalMatrix","attributeData","invert","pushBarycoordInterpolatedValues","appendAttributesFromIndices","appendAttributeFromIndex","getOperationAction","operation","hitSide","attrArr","normalize","addValues","TriangleIntersectData","TriangleIntersectionSets","triA","triB","id2","triSet","addTriangles","key2","OperationDebugData","triangleIntersectsA","triangleIntersectsB","_normalMatrix","Matrix3","_triA","_triB","_barycoordTri","_attr","_actions","getFirstIdFromSet","set","performOperation","operations","splitter","useGroups","resultGroups","resultMaterials","groupOffset","performSplitTriangleOperations","performWholeTriangleOperations","op","intersectionMap","invertedGeometry","groupIndices","aIndex","aPosition","bBVH","bIndex","bPosition","splitIds","groupIndex","ia3","ia0","ia1","ia2","intersectingIndices","ib3","ib0","ib1","ib2","clippedTri","lo","lk","invertTri","splitTriSet","aAttributes","halfEdges","traverseSet","currId","sid","action","joinGroups","nextGroup","prepareAttributesData","referenceGeometry","targetGeometry","relevantAttributes","aAttr","assignBufferData","groupOrder","needsDisposal","referenceAttrSet","requiredLength","geoAttr","trimmedArray","vertCount","getMaterialList","materials","Evaluator","targetBrushes","wasArray","triangleSplitter","consolidateGroups","debug","brush","aGroups","aMaterials","bGroups","bMaterials","allMaterials","mat","finalMaterials","foundGroup","flatTraverse","obj","cb","children","child","traverse","isDirty","vertex_default","fragment_default","ProceduralTerrain","controls","useControls","boardFill","THREE.BoxGeometry","boardHole","board","THREE.MeshStandardMaterial","THREE.Color","geomtery","THREE.PlaneGeometry","uniforms","THREE.Uniform","material","CustomShaderMaterial","vertexShader","fragmentShader","depthMaterial","THREE.MeshDepthMaterial","THREE.RGBADepthPacking","useFrame","_","delta","jsxs","Fragment","jsx"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54]}