{"version":3,"file":"shader-A3Lrx_-v.js","sources":["../../node_modules/three/examples/jsm/postprocessing/Pass.js","../../node_modules/three/examples/jsm/misc/GPUComputationRenderer.js","../../src/shaders/GPUParticles/vertex.glsl","../../src/shaders/GPUParticles/fragment.glsl","../../src/shaders/GPUParticles/gpgpu/particles.glsl","../../src/shaders/GPUParticles/shader.jsx"],"sourcesContent":["import {\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tOrthographicCamera,\n\tMesh\n} from 'three';\n\nclass Pass {\n\n\tconstructor() {\n\n\t\tthis.isPass = true;\n\n\t\t// if set to true, the pass is processed by the composer\n\t\tthis.enabled = true;\n\n\t\t// if set to true, the pass indicates to swap read and write buffer after rendering\n\t\tthis.needsSwap = true;\n\n\t\t// if set to true, the pass clears its buffer before rendering\n\t\tthis.clear = false;\n\n\t\t// if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.\n\t\tthis.renderToScreen = false;\n\n\t}\n\n\tsetSize( /* width, height */ ) {}\n\n\trender( /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */ ) {\n\n\t\tconsole.error( 'THREE.Pass: .render() must be implemented in derived pass.' );\n\n\t}\n\n\tdispose() {}\n\n}\n\n// Helper for passes that need to fill the viewport with a single quad.\n\nconst _camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\n// https://github.com/mrdoob/three.js/pull/21358\n\nclass FullscreenTriangleGeometry extends BufferGeometry {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( [ - 1, 3, 0, - 1, - 1, 0, 3, - 1, 0 ], 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( [ 0, 2, 0, 0, 2, 0 ], 2 ) );\n\n\t}\n\n}\n\nconst _geometry = new FullscreenTriangleGeometry();\n\nclass FullScreenQuad {\n\n\tconstructor( material ) {\n\n\t\tthis._mesh = new Mesh( _geometry, material );\n\n\t}\n\n\tdispose() {\n\n\t\tthis._mesh.geometry.dispose();\n\n\t}\n\n\trender( renderer ) {\n\n\t\trenderer.render( this._mesh, _camera );\n\n\t}\n\n\tget material() {\n\n\t\treturn this._mesh.material;\n\n\t}\n\n\tset material( value ) {\n\n\t\tthis._mesh.material = value;\n\n\t}\n\n}\n\nexport { Pass, FullScreenQuad };\n","import {\n\tClampToEdgeWrapping,\n\tDataTexture,\n\tFloatType,\n\tNearestFilter,\n\tRGBAFormat,\n\tShaderMaterial,\n\tWebGLRenderTarget\n} from 'three';\n\nimport { FullScreenQuad } from '../postprocessing/Pass.js';\n\n/**\n * GPUComputationRenderer, based on SimulationRenderer by zz85\n *\n * The GPUComputationRenderer uses the concept of variables. These variables are RGBA float textures that hold 4 floats\n * for each compute element (texel)\n *\n * Each variable has a fragment shader that defines the computation made to obtain the variable in question.\n * You can use as many variables you need, and make dependencies so you can use textures of other variables in the shader\n * (the sampler uniforms are added automatically) Most of the variables will need themselves as dependency.\n *\n * The renderer has actually two render targets per variable, to make ping-pong. Textures from the current frame are used\n * as inputs to render the textures of the next frame.\n *\n * The render targets of the variables can be used as input textures for your visualization shaders.\n *\n * Variable names should be valid identifiers and should not collide with THREE GLSL used identifiers.\n * a common approach could be to use 'texture' prefixing the variable name; i.e texturePosition, textureVelocity...\n *\n * The size of the computation (sizeX * sizeY) is defined as 'resolution' automatically in the shader. For example:\n * #DEFINE resolution vec2( 1024.0, 1024.0 )\n *\n * -------------\n *\n * Basic use:\n *\n * // Initialization...\n *\n * // Create computation renderer\n * const gpuCompute = new GPUComputationRenderer( 1024, 1024, renderer );\n *\n * // Create initial state float textures\n * const pos0 = gpuCompute.createTexture();\n * const vel0 = gpuCompute.createTexture();\n * // and fill in here the texture data...\n *\n * // Add texture variables\n * const velVar = gpuCompute.addVariable( \"textureVelocity\", fragmentShaderVel, pos0 );\n * const posVar = gpuCompute.addVariable( \"texturePosition\", fragmentShaderPos, vel0 );\n *\n * // Add variable dependencies\n * gpuCompute.setVariableDependencies( velVar, [ velVar, posVar ] );\n * gpuCompute.setVariableDependencies( posVar, [ velVar, posVar ] );\n *\n * // Add custom uniforms\n * velVar.material.uniforms.time = { value: 0.0 };\n *\n * // Check for completeness\n * const error = gpuCompute.init();\n * if ( error !== null ) {\n *\t\tconsole.error( error );\n  * }\n *\n *\n * // In each frame...\n *\n * // Compute!\n * gpuCompute.compute();\n *\n * // Update texture uniforms in your visualization materials with the gpu renderer output\n * myMaterial.uniforms.myTexture.value = gpuCompute.getCurrentRenderTarget( posVar ).texture;\n *\n * // Do your rendering\n * renderer.render( myScene, myCamera );\n *\n * -------------\n *\n * Also, you can use utility functions to create ShaderMaterial and perform computations (rendering between textures)\n * Note that the shaders can have multiple input textures.\n *\n * const myFilter1 = gpuCompute.createShaderMaterial( myFilterFragmentShader1, { theTexture: { value: null } } );\n * const myFilter2 = gpuCompute.createShaderMaterial( myFilterFragmentShader2, { theTexture: { value: null } } );\n *\n * const inputTexture = gpuCompute.createTexture();\n *\n * // Fill in here inputTexture...\n *\n * myFilter1.uniforms.theTexture.value = inputTexture;\n *\n * const myRenderTarget = gpuCompute.createRenderTarget();\n * myFilter2.uniforms.theTexture.value = myRenderTarget.texture;\n *\n * const outputRenderTarget = gpuCompute.createRenderTarget();\n *\n * // Now use the output texture where you want:\n * myMaterial.uniforms.map.value = outputRenderTarget.texture;\n *\n * // And compute each frame, before rendering to screen:\n * gpuCompute.doRenderTarget( myFilter1, myRenderTarget );\n * gpuCompute.doRenderTarget( myFilter2, outputRenderTarget );\n *\n *\n *\n * @param {int} sizeX Computation problem size is always 2d: sizeX * sizeY elements.\n * @param {int} sizeY Computation problem size is always 2d: sizeX * sizeY elements.\n * @param {WebGLRenderer} renderer The renderer\n  */\n\nclass GPUComputationRenderer {\n\n\tconstructor( sizeX, sizeY, renderer ) {\n\n\t\tthis.variables = [];\n\n\t\tthis.currentTextureIndex = 0;\n\n\t\tlet dataType = FloatType;\n\n\t\tconst passThruUniforms = {\n\t\t\tpassThruTexture: { value: null }\n\t\t};\n\n\t\tconst passThruShader = createShaderMaterial( getPassThroughFragmentShader(), passThruUniforms );\n\n\t\tconst quad = new FullScreenQuad( passThruShader );\n\n\t\tthis.setDataType = function ( type ) {\n\n\t\t\tdataType = type;\n\t\t\treturn this;\n\n\t\t};\n\n\t\tthis.addVariable = function ( variableName, computeFragmentShader, initialValueTexture ) {\n\n\t\t\tconst material = this.createShaderMaterial( computeFragmentShader );\n\n\t\t\tconst variable = {\n\t\t\t\tname: variableName,\n\t\t\t\tinitialValueTexture: initialValueTexture,\n\t\t\t\tmaterial: material,\n\t\t\t\tdependencies: null,\n\t\t\t\trenderTargets: [],\n\t\t\t\twrapS: null,\n\t\t\t\twrapT: null,\n\t\t\t\tminFilter: NearestFilter,\n\t\t\t\tmagFilter: NearestFilter\n\t\t\t};\n\n\t\t\tthis.variables.push( variable );\n\n\t\t\treturn variable;\n\n\t\t};\n\n\t\tthis.setVariableDependencies = function ( variable, dependencies ) {\n\n\t\t\tvariable.dependencies = dependencies;\n\n\t\t};\n\n\t\tthis.init = function () {\n\n\t\t\tif ( renderer.capabilities.maxVertexTextures === 0 ) {\n\n\t\t\t\treturn 'No support for vertex shader textures.';\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < this.variables.length; i ++ ) {\n\n\t\t\t\tconst variable = this.variables[ i ];\n\n\t\t\t\t// Creates rendertargets and initialize them with input texture\n\t\t\t\tvariable.renderTargets[ 0 ] = this.createRenderTarget( sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter );\n\t\t\t\tvariable.renderTargets[ 1 ] = this.createRenderTarget( sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter );\n\t\t\t\tthis.renderTexture( variable.initialValueTexture, variable.renderTargets[ 0 ] );\n\t\t\t\tthis.renderTexture( variable.initialValueTexture, variable.renderTargets[ 1 ] );\n\n\t\t\t\t// Adds dependencies uniforms to the ShaderMaterial\n\t\t\t\tconst material = variable.material;\n\t\t\t\tconst uniforms = material.uniforms;\n\n\t\t\t\tif ( variable.dependencies !== null ) {\n\n\t\t\t\t\tfor ( let d = 0; d < variable.dependencies.length; d ++ ) {\n\n\t\t\t\t\t\tconst depVar = variable.dependencies[ d ];\n\n\t\t\t\t\t\tif ( depVar.name !== variable.name ) {\n\n\t\t\t\t\t\t\t// Checks if variable exists\n\t\t\t\t\t\t\tlet found = false;\n\n\t\t\t\t\t\t\tfor ( let j = 0; j < this.variables.length; j ++ ) {\n\n\t\t\t\t\t\t\t\tif ( depVar.name === this.variables[ j ].name ) {\n\n\t\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( ! found ) {\n\n\t\t\t\t\t\t\t\treturn 'Variable dependency not found. Variable=' + variable.name + ', dependency=' + depVar.name;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tuniforms[ depVar.name ] = { value: null };\n\n\t\t\t\t\t\tmaterial.fragmentShader = '\\nuniform sampler2D ' + depVar.name + ';\\n' + material.fragmentShader;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.currentTextureIndex = 0;\n\n\t\t\treturn null;\n\n\t\t};\n\n\t\tthis.compute = function () {\n\n\t\t\tconst currentTextureIndex = this.currentTextureIndex;\n\t\t\tconst nextTextureIndex = this.currentTextureIndex === 0 ? 1 : 0;\n\n\t\t\tfor ( let i = 0, il = this.variables.length; i < il; i ++ ) {\n\n\t\t\t\tconst variable = this.variables[ i ];\n\n\t\t\t\t// Sets texture dependencies uniforms\n\t\t\t\tif ( variable.dependencies !== null ) {\n\n\t\t\t\t\tconst uniforms = variable.material.uniforms;\n\n\t\t\t\t\tfor ( let d = 0, dl = variable.dependencies.length; d < dl; d ++ ) {\n\n\t\t\t\t\t\tconst depVar = variable.dependencies[ d ];\n\n\t\t\t\t\t\tuniforms[ depVar.name ].value = depVar.renderTargets[ currentTextureIndex ].texture;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Performs the computation for this variable\n\t\t\t\tthis.doRenderTarget( variable.material, variable.renderTargets[ nextTextureIndex ] );\n\n\t\t\t}\n\n\t\t\tthis.currentTextureIndex = nextTextureIndex;\n\n\t\t};\n\n\t\tthis.getCurrentRenderTarget = function ( variable ) {\n\n\t\t\treturn variable.renderTargets[ this.currentTextureIndex ];\n\n\t\t};\n\n\t\tthis.getAlternateRenderTarget = function ( variable ) {\n\n\t\t\treturn variable.renderTargets[ this.currentTextureIndex === 0 ? 1 : 0 ];\n\n\t\t};\n\n\t\tthis.dispose = function () {\n\n\t\t\tquad.dispose();\n\n\t\t\tconst variables = this.variables;\n\n\t\t\tfor ( let i = 0; i < variables.length; i ++ ) {\n\n\t\t\t\tconst variable = variables[ i ];\n\n\t\t\t\tif ( variable.initialValueTexture ) variable.initialValueTexture.dispose();\n\n\t\t\t\tconst renderTargets = variable.renderTargets;\n\n\t\t\t\tfor ( let j = 0; j < renderTargets.length; j ++ ) {\n\n\t\t\t\t\tconst renderTarget = renderTargets[ j ];\n\t\t\t\t\trenderTarget.dispose();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction addResolutionDefine( materialShader ) {\n\n\t\t\tmaterialShader.defines.resolution = 'vec2( ' + sizeX.toFixed( 1 ) + ', ' + sizeY.toFixed( 1 ) + ' )';\n\n\t\t}\n\n\t\tthis.addResolutionDefine = addResolutionDefine;\n\n\n\t\t// The following functions can be used to compute things manually\n\n\t\tfunction createShaderMaterial( computeFragmentShader, uniforms ) {\n\n\t\t\tuniforms = uniforms || {};\n\n\t\t\tconst material = new ShaderMaterial( {\n\t\t\t\tname: 'GPUComputationShader',\n\t\t\t\tuniforms: uniforms,\n\t\t\t\tvertexShader: getPassThroughVertexShader(),\n\t\t\t\tfragmentShader: computeFragmentShader\n\t\t\t} );\n\n\t\t\taddResolutionDefine( material );\n\n\t\t\treturn material;\n\n\t\t}\n\n\t\tthis.createShaderMaterial = createShaderMaterial;\n\n\t\tthis.createRenderTarget = function ( sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter ) {\n\n\t\t\tsizeXTexture = sizeXTexture || sizeX;\n\t\t\tsizeYTexture = sizeYTexture || sizeY;\n\n\t\t\twrapS = wrapS || ClampToEdgeWrapping;\n\t\t\twrapT = wrapT || ClampToEdgeWrapping;\n\n\t\t\tminFilter = minFilter || NearestFilter;\n\t\t\tmagFilter = magFilter || NearestFilter;\n\n\t\t\tconst renderTarget = new WebGLRenderTarget( sizeXTexture, sizeYTexture, {\n\t\t\t\twrapS: wrapS,\n\t\t\t\twrapT: wrapT,\n\t\t\t\tminFilter: minFilter,\n\t\t\t\tmagFilter: magFilter,\n\t\t\t\tformat: RGBAFormat,\n\t\t\t\ttype: dataType,\n\t\t\t\tdepthBuffer: false\n\t\t\t} );\n\n\t\t\treturn renderTarget;\n\n\t\t};\n\n\t\tthis.createTexture = function () {\n\n\t\t\tconst data = new Float32Array( sizeX * sizeY * 4 );\n\t\t\tconst texture = new DataTexture( data, sizeX, sizeY, RGBAFormat, FloatType );\n\t\t\ttexture.needsUpdate = true;\n\t\t\treturn texture;\n\n\t\t};\n\n\t\tthis.renderTexture = function ( input, output ) {\n\n\t\t\t// Takes a texture, and render out in rendertarget\n\t\t\t// input = Texture\n\t\t\t// output = RenderTarget\n\n\t\t\tpassThruUniforms.passThruTexture.value = input;\n\n\t\t\tthis.doRenderTarget( passThruShader, output );\n\n\t\t\tpassThruUniforms.passThruTexture.value = null;\n\n\t\t};\n\n\t\tthis.doRenderTarget = function ( material, output ) {\n\n\t\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\t\tconst currentXrEnabled = renderer.xr.enabled;\n\t\t\tconst currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n\n\t\t\trenderer.xr.enabled = false; // Avoid camera modification\n\t\t\trenderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\t\t\tquad.material = material;\n\t\t\trenderer.setRenderTarget( output );\n\t\t\tquad.render( renderer );\n\t\t\tquad.material = passThruShader;\n\n\t\t\trenderer.xr.enabled = currentXrEnabled;\n\t\t\trenderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n\n\t\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\t};\n\n\t\t// Shaders\n\n\t\tfunction getPassThroughVertexShader() {\n\n\t\t\treturn\t'void main()\t{\\n' +\n\t\t\t\t\t'\\n' +\n\t\t\t\t\t'\tgl_Position = vec4( position, 1.0 );\\n' +\n\t\t\t\t\t'\\n' +\n\t\t\t\t\t'}\\n';\n\n\t\t}\n\n\t\tfunction getPassThroughFragmentShader() {\n\n\t\t\treturn\t'uniform sampler2D passThruTexture;\\n' +\n\t\t\t\t\t'\\n' +\n\t\t\t\t\t'void main() {\\n' +\n\t\t\t\t\t'\\n' +\n\t\t\t\t\t'\tvec2 uv = gl_FragCoord.xy / resolution.xy;\\n' +\n\t\t\t\t\t'\\n' +\n\t\t\t\t\t'\tgl_FragColor = texture2D( passThruTexture, uv );\\n' +\n\t\t\t\t\t'\\n' +\n\t\t\t\t\t'}\\n';\n\n\t\t}\n\n\t}\n\n}\n\nexport { GPUComputationRenderer };\n","uniform vec2 uResolution;\r\nuniform float uTime;\r\nuniform float uSize;\r\nuniform sampler2D uParticlesTexture;\r\n\r\nvarying vec3 vColor;\r\n\r\nattribute vec2 aParticlesUv;\r\nattribute vec3 aColor;\r\nattribute float aSize;\r\nvoid main() {\r\n\r\n    vec4 particle = texture(uParticlesTexture, aParticlesUv);\r\n    //Final Position \r\n    vec4 modelPosition = modelMatrix * vec4(particle.xyz, 1.0);\r\n    vec4 viewPosition = viewMatrix * modelPosition;\r\n    vec4 projectedPosition = projectionMatrix * viewPosition;\r\n    gl_Position = projectedPosition;\r\n    \r\n    //point size\r\n    float sizeIn = smoothstep(0.0, 0.1, particle.a);\r\n    float sizeOut = 1.0 - smoothstep(0.7, 1.0, particle.a);\r\n    float size = min(sizeIn, sizeOut);\r\n    gl_PointSize = uSize * uResolution.y * aSize * size;\r\n    gl_PointSize *= (1.0/ -viewPosition.z);\r\n\r\n    //varyings\r\n    vColor = aColor;\r\n}","varying vec3 vColor;\r\n\r\nvoid main() {\r\n    float distanceToCenter = length(gl_PointCoord - 0.5);\r\n    if(distanceToCenter > 0.5) {\r\n        discard;\r\n    }\r\n\r\n    gl_FragColor = vec4(vColor, 1.0);\r\n\r\n    #include <tonemapping_fragment>\r\n    #include <colorspace_fragment>\r\n}\r\n","uniform float uTime;\r\nuniform float uDeltaTime;\r\nuniform float uFlowFieldInfluence;\r\nuniform float uFlowFieldStrength;\r\nuniform float uFlowFieldFrequency;\r\nuniform sampler2D uBase;\r\n\r\n#include ../../includes/simplexNoise4d.glsl\r\nvoid main() \r\n{\r\n    float time = uTime * 0.02;\r\n    //particles\r\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\r\n    vec4 particle = texture(uParticles, uv);\r\n    vec4 base = texture(uBase, uv);\r\n    \r\n\r\n    //dead\r\n    if(particle.a >= 1.0)\r\n    {\r\n\r\n        particle.a = mod(particle.a, 1.0);\r\n        particle.xyz = base.xyz;\r\n    }\r\n    //alive\r\n    else\r\n    {\r\n        // Strength\r\n        float strength = simplexNoise4d(vec4(base.xyz * 0.2, time+1.0));\r\n        float flowFieldInfluence = (uFlowFieldInfluence - 0.5) * (-2.0);\r\n        strength = smoothstep(flowFieldInfluence, 1.0, strength);\r\n        // Flow Field \r\n        vec3 flowField = vec3(\r\n            simplexNoise4d(vec4(particle.xyz * uFlowFieldFrequency, time)),\r\n            simplexNoise4d(vec4(particle.xyz * uFlowFieldFrequency + 1.0, time)),\r\n            simplexNoise4d(vec4(particle.xyz * uFlowFieldFrequency + 2.0, time))\r\n        );\r\n\r\n        flowField = normalize(flowField);\r\n        particle.xyz += flowField  * uDeltaTime * strength * uFlowFieldStrength;\r\n\r\n        //decay\r\n        particle.a += uDeltaTime * 0.3;\r\n    }\r\n   \r\n\r\n    gl_FragColor = particle;   \r\n}","\r\n\r\nimport * as THREE from \"three\"\r\nimport { useRef, useState } from \"react\";\r\nimport { useFrame } from \"@react-three/fiber\";\r\nimport ExampleModel from \"../../models/models\";\r\nimport { useControls, button } from \"leva\";\r\nimport { GPUComputationRenderer } from \"three/examples/jsm/misc/GPUComputationRenderer\"\r\n\r\nimport { useGLTF } from \"@react-three/drei\"\r\nimport { Suspense } from \"react\";\r\nimport Placeholder from \"../../models/Placeholder\";\r\nimport { useThree } from \"@react-three/fiber\";\r\n\r\nimport vertexShader from \"./vertex.glsl\";\r\nimport fragmentShader from \"./fragment.glsl\";\r\nimport GPGPUParticlesShader from \"./gpgpu/particles.glsl\"\r\n\r\nexport default function GPGPUParticles(args) {\r\n    // const particlesGeometry = useRef()\r\n    document.body.style.backgroundColor = \"#29191f\"    \r\n\r\n    console.log(GPGPUParticlesShader);\r\n    const model = useGLTF('models/ship/model.glb')\r\n   \r\n    // Particles \r\n    const particles = {}\r\n    const controls = useControls({\r\n        size: {value: 0.05, min: 0.0, max: 0.10},\r\n      flowFieldInfluence: {value: 0.5, min: 0.0, max: 1.0},\r\n      flowFieldStrength: {value: 0.5, min: 0.0, max: 10.0},\r\n      flowFieldFrequency: {value: 0.2, min: 0.0, max: 1.0}\r\n    })\r\n    \r\n    const renderer = useThree((state) => state.gl)\r\n    console.log(renderer);\r\n    const scene = useThree((state) => state.scene)\r\n    const sizes = {\r\n        width: window.innerWidth,\r\n        height: window.innerHeight\r\n    }\r\n\r\n    // Base Geometry\r\n    const baseGeometry = {}\r\n    baseGeometry.instance = model.scene.children[0].geometry\r\n    baseGeometry.count = baseGeometry.instance.attributes.position.count\r\n\r\n    \r\n    \r\n    // GPU Compute \r\n    const gpgpu = {}\r\n    gpgpu.size = Math.sqrt(baseGeometry.count)\r\n    gpgpu.size = Math.ceil(gpgpu.size)\r\n    gpgpu.computation = new GPUComputationRenderer(gpgpu.size, gpgpu.size, renderer)\r\n    \r\n    //base Particles\r\n    const baseParticlesTexture = gpgpu.computation.createTexture()\r\n\r\n    for (let i = 0; i < baseGeometry.count; i++) {\r\n        const i3 = i * 3;\r\n        const i4 = i * 4;\r\n        \r\n        //position baswed on geometry\r\n        baseParticlesTexture.image.data[i4] = baseGeometry.instance.attributes.position.array[i3]\r\n        baseParticlesTexture.image.data[i4 + 1] = baseGeometry.instance.attributes.position.array[i3 + 1]\r\n        baseParticlesTexture.image.data[i4 + 2] = baseGeometry.instance.attributes.position.array[i3 + 2]\r\n        baseParticlesTexture.image.data[i4 + 3] = Math.random()\r\n    }\r\n     \r\n\r\n    //particles variables\r\n    gpgpu.particlesVariable = gpgpu.computation.addVariable(\r\n        \"uParticles\",  //name of the texture \r\n        GPGPUParticlesShader,  //shader where is inserted\r\n        baseParticlesTexture //inserted textured\r\n    )\r\n    console.log(gpgpu.particlesVariable);\r\n    gpgpu.computation.setVariableDependencies(gpgpu.particlesVariable, [gpgpu.particlesVariable])\r\n   \r\n    // UNIFORMS\r\n\r\n    gpgpu.particlesVariable.material.uniforms.uTime = new THREE.Uniform(0.0)\r\n    gpgpu.particlesVariable.material.uniforms.uDeltaTime = new THREE.Uniform(0.0)\r\n    gpgpu.particlesVariable.material.uniforms.uBase = new THREE.Uniform(baseParticlesTexture)\r\n    gpgpu.particlesVariable.material.uniforms.uFlowFieldInfluence = new THREE.Uniform(controls.flowFieldInfluence)\r\n    gpgpu.particlesVariable.material.uniforms.uFlowFieldStrength = new THREE.Uniform(controls.flowFieldStrength)\r\n    gpgpu.particlesVariable.material.uniforms.uFlowFieldFrequency = new THREE.Uniform(controls.flowFieldFrequency)\r\n\r\n    //init\r\n    gpgpu.computation.init()\r\n\r\n    \r\n    //Geometry for particles\r\n    const particlesUvArray = new Float32Array(baseGeometry.count * 2)\r\n    const sizesArray = new Float32Array(baseGeometry.count)\r\n\r\n    for (let y = 0; y < gpgpu.size; y++) {\r\n        for(let x = 0; x < gpgpu.size; x++) {\r\n            const i = (y * gpgpu.size) + x\r\n            const i2 = i * 2\r\n            //particles uv\r\n            const uvX = (x + 0.5) / gpgpu.size\r\n            const uvY = (y + 0.5) / gpgpu.size\r\n            \r\n            particlesUvArray[i2] = uvX\r\n            particlesUvArray[i2 + 1] = uvY\r\n\r\n\r\n            //particles size\r\n            sizesArray[i] = Math.random() \r\n        }\r\n    }\r\n    particles.geometry = new THREE.BufferGeometry()\r\n    particles.geometry.setDrawRange(0, baseGeometry.count)\r\n    particles.geometry.setAttribute(\"aParticlesUv\", new THREE.BufferAttribute(particlesUvArray, 2))\r\n    particles.geometry.setAttribute(\"aColor\", baseGeometry.instance.attributes.color)\r\n    particles.geometry.setAttribute(\"aSize\", new THREE.BufferAttribute(sizesArray, 1))\r\n\r\n    particles.material = new THREE.ShaderMaterial({\r\n        vertexShader: vertexShader,\r\n        fragmentShader: fragmentShader,\r\n        // blending: THREE.AdditiveBlending,\r\n        // depthWrite: false,\r\n        uniforms:\r\n        {\r\n            uParticlesTexture: new THREE.Uniform(),\r\n            uSize:new THREE.Uniform(controls.size),\r\n            uResolution: new THREE.Uniform(new THREE.Vector2(window.innerWidth, window.innerHeight)),\r\n            \r\n        }\r\n    })\r\n    \r\n    useFrame((_, delta) => {\r\n        sizes.width = window.innerWidth;\r\n        sizes.height = window.innerHeight;\r\n        particles.material.uniforms.uResolution.value.set(sizes.width, sizes.height);\r\n         // GPGPU UPDATE\r\n         console.log(delta);\r\n         \r\n        gpgpu.particlesVariable.material.uniforms.uDeltaTime.value = Math.min(delta, 0.01);\r\n        gpgpu.particlesVariable.material.uniforms.uTime.value += 0.01;\r\n        gpgpu.computation.compute()\r\n        particles.material.uniforms.uParticlesTexture.value = gpgpu.computation.getCurrentRenderTarget(gpgpu.particlesVariable).texture\r\n\r\n    })\r\n    console.log(gpgpu.computation.getCurrentRenderTarget(gpgpu.particlesVariable).texture);\r\n  \r\n    \r\n   \r\n   \r\n    \r\n\r\n\r\n    return (\r\n        <>\r\n            <points material={particles.material} geometry={particles.geometry}>\r\n            </points>\r\n            \r\n            {/* debug */}\r\n            {/* <mesh position={[3,0,0]} material={gpgpu.debugMaterial} geometry={gpgpu.debugGeometry} >\r\n                <planeGeometry args={[3,3]}  />\r\n                <meshBasicMaterial map={gpgpu.computation.getCurrentRenderTarget(gpgpu.particlesVariable).texture}/>\r\n            </mesh> */}\r\n        </>\r\n    )\r\n}\r\n\r\n"],"names":["_camera","OrthographicCamera","FullscreenTriangleGeometry","BufferGeometry","Float32BufferAttribute","_geometry","FullScreenQuad","material","Mesh","renderer","value","GPUComputationRenderer","sizeX","sizeY","dataType","FloatType","passThruUniforms","passThruShader","createShaderMaterial","getPassThroughFragmentShader","quad","type","variableName","computeFragmentShader","initialValueTexture","variable","NearestFilter","dependencies","i","uniforms","d","depVar","found","j","currentTextureIndex","nextTextureIndex","il","dl","variables","renderTargets","addResolutionDefine","materialShader","ShaderMaterial","getPassThroughVertexShader","sizeXTexture","sizeYTexture","wrapS","wrapT","minFilter","magFilter","ClampToEdgeWrapping","WebGLRenderTarget","RGBAFormat","data","texture","DataTexture","input","output","currentRenderTarget","currentXrEnabled","currentShadowAutoUpdate","vertex_default","fragment_default","particles_default","GPGPUParticles","args","GPGPUParticlesShader","model","useGLTF","particles","controls","useControls","useThree","state","sizes","baseGeometry","gpgpu","baseParticlesTexture","i3","i4","THREE.Uniform","particlesUvArray","sizesArray","y","x","i2","uvX","uvY","THREE.BufferGeometry","THREE.BufferAttribute","THREE.ShaderMaterial","vertexShader","fragmentShader","THREE.Vector2","useFrame","_","delta","jsx","Fragment"],"mappings":"8LAyCA,MAAMA,EAAU,IAAIC,EAAoB,GAAK,EAAG,EAAG,GAAK,EAAG,CAAG,EAI9D,MAAMC,UAAmCC,CAAe,CAEvD,aAAc,CAEb,MAAO,EAEP,KAAK,aAAc,WAAY,IAAIC,EAAwB,CAAE,GAAK,EAAG,EAAG,GAAK,GAAK,EAAG,EAAG,GAAK,CAAC,EAAI,EAAK,EACvG,KAAK,aAAc,KAAM,IAAIA,EAAwB,CAAE,EAAG,EAAG,EAAG,EAAG,EAAG,CAAG,EAAE,CAAC,CAAI,CAElF,CAEA,CAEA,MAAMC,EAAY,IAAIH,EAEtB,MAAMI,CAAe,CAEpB,YAAaC,EAAW,CAEvB,KAAK,MAAQ,IAAIC,EAAMH,EAAWE,CAAU,CAE9C,CAEC,SAAU,CAET,KAAK,MAAM,SAAS,QAAS,CAE/B,CAEC,OAAQE,EAAW,CAElBA,EAAS,OAAQ,KAAK,MAAOT,CAAS,CAExC,CAEC,IAAI,UAAW,CAEd,OAAO,KAAK,MAAM,QAEpB,CAEC,IAAI,SAAUU,EAAQ,CAErB,KAAK,MAAM,SAAWA,CAExB,CAEA,CCiBA,MAAMC,CAAuB,CAE5B,YAAaC,EAAOC,EAAOJ,EAAW,CAErC,KAAK,UAAY,CAAE,EAEnB,KAAK,oBAAsB,EAE3B,IAAIK,EAAWC,EAEf,MAAMC,EAAmB,CACxB,gBAAiB,CAAE,MAAO,IAAI,CAC9B,EAEKC,EAAiBC,EAAsBC,EAA4B,EAAIH,CAAkB,EAEzFI,EAAO,IAAId,EAAgBW,CAAgB,EAEjD,KAAK,YAAc,SAAWI,EAAO,CAEpC,OAAAP,EAAWO,EACJ,IAEP,EAED,KAAK,YAAc,SAAWC,EAAcC,EAAuBC,EAAsB,CAExF,MAAMjB,EAAW,KAAK,qBAAsBgB,CAAuB,EAE7DE,EAAW,CAChB,KAAMH,EACN,oBAAqBE,EACrB,SAAUjB,EACV,aAAc,KACd,cAAe,CAAE,EACjB,MAAO,KACP,MAAO,KACP,UAAWmB,EACX,UAAWA,CACX,EAED,YAAK,UAAU,KAAMD,CAAU,EAExBA,CAEP,EAED,KAAK,wBAA0B,SAAWA,EAAUE,EAAe,CAElEF,EAAS,aAAeE,CAExB,EAED,KAAK,KAAO,UAAY,CAEvB,GAAKlB,EAAS,aAAa,oBAAsB,EAEhD,MAAO,yCAIR,QAAUmB,EAAI,EAAGA,EAAI,KAAK,UAAU,OAAQA,IAAO,CAElD,MAAMH,EAAW,KAAK,UAAWG,CAAG,EAGpCH,EAAS,cAAe,CAAC,EAAK,KAAK,mBAAoBb,EAAOC,EAAOY,EAAS,MAAOA,EAAS,MAAOA,EAAS,UAAWA,EAAS,SAAW,EAC7IA,EAAS,cAAe,CAAC,EAAK,KAAK,mBAAoBb,EAAOC,EAAOY,EAAS,MAAOA,EAAS,MAAOA,EAAS,UAAWA,EAAS,SAAW,EAC7I,KAAK,cAAeA,EAAS,oBAAqBA,EAAS,cAAe,EAAK,EAC/E,KAAK,cAAeA,EAAS,oBAAqBA,EAAS,cAAe,EAAK,EAG/E,MAAMlB,EAAWkB,EAAS,SACpBI,EAAWtB,EAAS,SAE1B,GAAKkB,EAAS,eAAiB,KAE9B,QAAUK,EAAI,EAAGA,EAAIL,EAAS,aAAa,OAAQK,IAAO,CAEzD,MAAMC,EAASN,EAAS,aAAcK,CAAG,EAEzC,GAAKC,EAAO,OAASN,EAAS,KAAO,CAGpC,IAAIO,EAAQ,GAEZ,QAAUC,EAAI,EAAGA,EAAI,KAAK,UAAU,OAAQA,IAE3C,GAAKF,EAAO,OAAS,KAAK,UAAWE,CAAG,EAAC,KAAO,CAE/CD,EAAQ,GACR,KAET,CAIO,GAAK,CAAEA,EAEN,MAAO,2CAA6CP,EAAS,KAAO,gBAAkBM,EAAO,IAIrG,CAEMF,EAAUE,EAAO,IAAM,EAAG,CAAE,MAAO,IAAM,EAEzCxB,EAAS,eAAiB;AAAA,oBAAyBwB,EAAO,KAAO;AAAA,EAAQxB,EAAS,cAExF,CAIA,CAEG,YAAK,oBAAsB,EAEpB,IAEP,EAED,KAAK,QAAU,UAAY,CAE1B,MAAM2B,EAAsB,KAAK,oBAC3BC,EAAmB,KAAK,sBAAwB,EAAI,EAAI,EAE9D,QAAUP,EAAI,EAAGQ,EAAK,KAAK,UAAU,OAAQR,EAAIQ,EAAIR,IAAO,CAE3D,MAAMH,EAAW,KAAK,UAAWG,CAAG,EAGpC,GAAKH,EAAS,eAAiB,KAAO,CAErC,MAAMI,EAAWJ,EAAS,SAAS,SAEnC,QAAUK,EAAI,EAAGO,EAAKZ,EAAS,aAAa,OAAQK,EAAIO,EAAIP,IAAO,CAElE,MAAMC,EAASN,EAAS,aAAcK,CAAG,EAEzCD,EAAUE,EAAO,MAAO,MAAQA,EAAO,cAAeG,CAAmB,EAAG,OAElF,CAEA,CAGI,KAAK,eAAgBT,EAAS,SAAUA,EAAS,cAAeU,EAAoB,CAExF,CAEG,KAAK,oBAAsBA,CAE3B,EAED,KAAK,uBAAyB,SAAWV,EAAW,CAEnD,OAAOA,EAAS,cAAe,KAAK,mBAAqB,CAEzD,EAED,KAAK,yBAA2B,SAAWA,EAAW,CAErD,OAAOA,EAAS,cAAe,KAAK,sBAAwB,EAAI,EAAI,CAAG,CAEvE,EAED,KAAK,QAAU,UAAY,CAE1BL,EAAK,QAAS,EAEd,MAAMkB,EAAY,KAAK,UAEvB,QAAUV,EAAI,EAAGA,EAAIU,EAAU,OAAQV,IAAO,CAE7C,MAAMH,EAAWa,EAAWV,CAAG,EAE1BH,EAAS,qBAAsBA,EAAS,oBAAoB,QAAS,EAE1E,MAAMc,EAAgBd,EAAS,cAE/B,QAAUQ,EAAI,EAAGA,EAAIM,EAAc,OAAQN,IAErBM,EAAeN,CAAG,EAC1B,QAAS,CAI3B,CAEG,EAED,SAASO,EAAqBC,EAAiB,CAE9CA,EAAe,QAAQ,WAAa,SAAW7B,EAAM,QAAS,CAAG,EAAG,KAAOC,EAAM,QAAS,CAAG,EAAG,IAEnG,CAEE,KAAK,oBAAsB2B,EAK3B,SAAStB,EAAsBK,EAAuBM,EAAW,CAEhEA,EAAWA,GAAY,CAAE,EAEzB,MAAMtB,EAAW,IAAImC,EAAgB,CACpC,KAAM,uBACN,SAAUb,EACV,aAAcc,EAA4B,EAC1C,eAAgBpB,CACpB,CAAM,EAEH,OAAAiB,EAAqBjC,CAAU,EAExBA,CAEV,CAEE,KAAK,qBAAuBW,EAE5B,KAAK,mBAAqB,SAAW0B,EAAcC,EAAcC,EAAOC,EAAOC,EAAWC,EAAY,CAErG,OAAAL,EAAeA,GAAgBhC,EAC/BiC,EAAeA,GAAgBhC,EAE/BiC,EAAQA,GAASI,EACjBH,EAAQA,GAASG,EAEjBF,EAAYA,GAAatB,EACzBuB,EAAYA,GAAavB,EAEJ,IAAIyB,EAAmBP,EAAcC,EAAc,CACvE,MAAOC,EACP,MAAOC,EACP,UAAWC,EACX,UAAWC,EACX,OAAQG,EACR,KAAMtC,EACN,YAAa,EACjB,CAAM,CAIH,EAED,KAAK,cAAgB,UAAY,CAEhC,MAAMuC,EAAO,IAAI,aAAczC,EAAQC,EAAQ,CAAG,EAC5CyC,EAAU,IAAIC,EAAaF,EAAMzC,EAAOC,EAAOuC,EAAYrC,CAAW,EAC5E,OAAAuC,EAAQ,YAAc,GACfA,CAEP,EAED,KAAK,cAAgB,SAAWE,EAAOC,EAAS,CAM/CzC,EAAiB,gBAAgB,MAAQwC,EAEzC,KAAK,eAAgBvC,EAAgBwC,CAAQ,EAE7CzC,EAAiB,gBAAgB,MAAQ,IAEzC,EAED,KAAK,eAAiB,SAAWT,EAAUkD,EAAS,CAEnD,MAAMC,EAAsBjD,EAAS,gBAAiB,EAEhDkD,EAAmBlD,EAAS,GAAG,QAC/BmD,EAA0BnD,EAAS,UAAU,WAEnDA,EAAS,GAAG,QAAU,GACtBA,EAAS,UAAU,WAAa,GAChCW,EAAK,SAAWb,EAChBE,EAAS,gBAAiBgD,CAAQ,EAClCrC,EAAK,OAAQX,CAAU,EACvBW,EAAK,SAAWH,EAEhBR,EAAS,GAAG,QAAUkD,EACtBlD,EAAS,UAAU,WAAamD,EAEhCnD,EAAS,gBAAiBiD,CAAqB,CAE/C,EAID,SAASf,GAA6B,CAErC,MAAO;AAAA;AAAA;AAAA;AAAA;AAAA,CAMV,CAEE,SAASxB,GAA+B,CAEvC,MAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,CAUV,CAEA,CAEA,CC3aA,IAAA0C,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCAAC,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCAAC,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCkBA,SAAwBC,EAAeC,EAAM,CAEhC,SAAA,KAAK,MAAM,gBAAkB,UAEtC,QAAQ,IAAIC,CAAoB,EAC1B,MAAAC,EAAQC,EAAQ,uBAAuB,EAGvCC,EAAY,CAAC,EACbC,EAAWC,EAAY,CACzB,KAAM,CAAC,MAAO,IAAM,IAAK,EAAK,IAAK,EAAI,EACzC,mBAAoB,CAAC,MAAO,GAAK,IAAK,EAAK,IAAK,CAAG,EACnD,kBAAmB,CAAC,MAAO,GAAK,IAAK,EAAK,IAAK,EAAI,EACnD,mBAAoB,CAAC,MAAO,GAAK,IAAK,EAAK,IAAK,CAAG,CAAA,CACpD,EAEK9D,EAAW+D,EAAUC,GAAUA,EAAM,EAAE,EAC7C,QAAQ,IAAIhE,CAAQ,EACN+D,EAAUC,GAAUA,EAAM,KAAK,EAC7C,MAAMC,EAAQ,CACV,MAAO,OAAO,WACd,OAAQ,OAAO,WACnB,EAGMC,EAAe,CAAC,EACtBA,EAAa,SAAWR,EAAM,MAAM,SAAS,CAAC,EAAE,SAChDQ,EAAa,MAAQA,EAAa,SAAS,WAAW,SAAS,MAK/D,MAAMC,EAAQ,CAAC,EACfA,EAAM,KAAO,KAAK,KAAKD,EAAa,KAAK,EACzCC,EAAM,KAAO,KAAK,KAAKA,EAAM,IAAI,EACjCA,EAAM,YAAc,IAAIjE,EAAuBiE,EAAM,KAAMA,EAAM,KAAMnE,CAAQ,EAGzE,MAAAoE,EAAuBD,EAAM,YAAY,cAAc,EAE7D,QAAShD,EAAI,EAAGA,EAAI+C,EAAa,MAAO/C,IAAK,CACzC,MAAMkD,EAAKlD,EAAI,EACTmD,EAAKnD,EAAI,EAGMiD,EAAA,MAAM,KAAKE,CAAE,EAAIJ,EAAa,SAAS,WAAW,SAAS,MAAMG,CAAE,EACnED,EAAA,MAAM,KAAKE,EAAK,CAAC,EAAIJ,EAAa,SAAS,WAAW,SAAS,MAAMG,EAAK,CAAC,EAC3ED,EAAA,MAAM,KAAKE,EAAK,CAAC,EAAIJ,EAAa,SAAS,WAAW,SAAS,MAAMG,EAAK,CAAC,EAChGD,EAAqB,MAAM,KAAKE,EAAK,CAAC,EAAI,KAAK,OAAO,CAAA,CAKpDH,EAAA,kBAAoBA,EAAM,YAAY,YACxC,aACAV,EACAW,CACJ,EACQ,QAAA,IAAID,EAAM,iBAAiB,EACnCA,EAAM,YAAY,wBAAwBA,EAAM,kBAAmB,CAACA,EAAM,iBAAiB,CAAC,EAI5FA,EAAM,kBAAkB,SAAS,SAAS,MAAQ,IAAII,EAAc,CAAG,EACvEJ,EAAM,kBAAkB,SAAS,SAAS,WAAa,IAAII,EAAc,CAAG,EAC5EJ,EAAM,kBAAkB,SAAS,SAAS,MAAQ,IAAII,EAAcH,CAAoB,EAClFD,EAAA,kBAAkB,SAAS,SAAS,oBAAsB,IAAII,EAAcV,EAAS,kBAAkB,EACvGM,EAAA,kBAAkB,SAAS,SAAS,mBAAqB,IAAII,EAAcV,EAAS,iBAAiB,EACrGM,EAAA,kBAAkB,SAAS,SAAS,oBAAsB,IAAII,EAAcV,EAAS,kBAAkB,EAG7GM,EAAM,YAAY,KAAK,EAIvB,MAAMK,EAAmB,IAAI,aAAaN,EAAa,MAAQ,CAAC,EAC1DO,EAAa,IAAI,aAAaP,EAAa,KAAK,EAEtD,QAASQ,EAAI,EAAGA,EAAIP,EAAM,KAAMO,IAC5B,QAAQC,EAAI,EAAGA,EAAIR,EAAM,KAAMQ,IAAK,CAC1B,MAAAxD,EAAKuD,EAAIP,EAAM,KAAQQ,EACvBC,EAAKzD,EAAI,EAET0D,GAAOF,EAAI,IAAOR,EAAM,KACxBW,GAAOJ,EAAI,IAAOP,EAAM,KAE9BK,EAAiBI,CAAE,EAAIC,EACNL,EAAAI,EAAK,CAAC,EAAIE,EAIhBL,EAAAtD,CAAC,EAAI,KAAK,OAAO,CAAA,CAG1B,OAAAyC,EAAA,SAAW,IAAImB,EACzBnB,EAAU,SAAS,aAAa,EAAGM,EAAa,KAAK,EAC3CN,EAAA,SAAS,aAAa,eAAgB,IAAIoB,EAAsBR,EAAkB,CAAC,CAAC,EAC9FZ,EAAU,SAAS,aAAa,SAAUM,EAAa,SAAS,WAAW,KAAK,EACtEN,EAAA,SAAS,aAAa,QAAS,IAAIoB,EAAsBP,EAAY,CAAC,CAAC,EAEvEb,EAAA,SAAW,IAAIqB,EAAqB,CAAA,aAC1CC,EAAA,eACAC,EAGA,SACA,CACI,kBAAmB,IAAIZ,EACvB,MAAM,IAAIA,EAAcV,EAAS,IAAI,EACrC,YAAa,IAAIU,EAAc,IAAIa,EAAc,OAAO,WAAY,OAAO,WAAW,CAAC,CAAA,CAE3F,CACH,EAEQC,EAAA,CAACC,EAAGC,IAAU,CACnBtB,EAAM,MAAQ,OAAO,WACrBA,EAAM,OAAS,OAAO,YACZL,EAAA,SAAS,SAAS,YAAY,MAAM,IAAIK,EAAM,MAAOA,EAAM,MAAM,EAE1E,QAAQ,IAAIsB,CAAK,EAEZpB,EAAA,kBAAkB,SAAS,SAAS,WAAW,MAAQ,KAAK,IAAIoB,EAAO,GAAI,EACjFpB,EAAM,kBAAkB,SAAS,SAAS,MAAM,OAAS,IACzDA,EAAM,YAAY,QAAQ,EAChBP,EAAA,SAAS,SAAS,kBAAkB,MAAQO,EAAM,YAAY,uBAAuBA,EAAM,iBAAiB,EAAE,OAAA,CAE3H,EACD,QAAQ,IAAIA,EAAM,YAAY,uBAAuBA,EAAM,iBAAiB,EAAE,OAAO,EASjFqB,EAAA,IAAAC,EAAA,SAAA,CACI,eAAC,SAAO,CAAA,SAAU7B,EAAU,SAAU,SAAUA,EAAU,QAAA,CAC1D,CAOJ,CAAA,CAER","x_google_ignoreList":[0,1]}